(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a2, prop, b[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/toastify-js/src/toastify.js
  var require_toastify = __commonJS({
    "node_modules/toastify-js/src/toastify.js"(exports, module) {
      (function(root, factory) {
        if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          root.Toastify = factory();
        }
      })(exports, function(global2) {
        var Toastify2 = function(options) {
          return new Toastify2.lib.init(options);
        }, version = "1.12.0";
        Toastify2.defaults = {
          oldestFirst: true,
          text: "Toastify is awesome!",
          node: void 0,
          duration: 3e3,
          selector: void 0,
          callback: function() {
          },
          destination: void 0,
          newWindow: false,
          close: false,
          gravity: "toastify-top",
          positionLeft: false,
          position: "",
          backgroundColor: "",
          avatar: "",
          className: "",
          stopOnFocus: true,
          onClick: function() {
          },
          offset: { x: 0, y: 0 },
          escapeMarkup: true,
          ariaLive: "polite",
          style: { background: "" }
        };
        Toastify2.lib = Toastify2.prototype = {
          toastify: version,
          constructor: Toastify2,
          // Initializing the object with required parameters
          init: function(options) {
            if (!options) {
              options = {};
            }
            this.options = {};
            this.toastElement = null;
            this.options.text = options.text || Toastify2.defaults.text;
            this.options.node = options.node || Toastify2.defaults.node;
            this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify2.defaults.duration;
            this.options.selector = options.selector || Toastify2.defaults.selector;
            this.options.callback = options.callback || Toastify2.defaults.callback;
            this.options.destination = options.destination || Toastify2.defaults.destination;
            this.options.newWindow = options.newWindow || Toastify2.defaults.newWindow;
            this.options.close = options.close || Toastify2.defaults.close;
            this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : Toastify2.defaults.gravity;
            this.options.positionLeft = options.positionLeft || Toastify2.defaults.positionLeft;
            this.options.position = options.position || Toastify2.defaults.position;
            this.options.backgroundColor = options.backgroundColor || Toastify2.defaults.backgroundColor;
            this.options.avatar = options.avatar || Toastify2.defaults.avatar;
            this.options.className = options.className || Toastify2.defaults.className;
            this.options.stopOnFocus = options.stopOnFocus === void 0 ? Toastify2.defaults.stopOnFocus : options.stopOnFocus;
            this.options.onClick = options.onClick || Toastify2.defaults.onClick;
            this.options.offset = options.offset || Toastify2.defaults.offset;
            this.options.escapeMarkup = options.escapeMarkup !== void 0 ? options.escapeMarkup : Toastify2.defaults.escapeMarkup;
            this.options.ariaLive = options.ariaLive || Toastify2.defaults.ariaLive;
            this.options.style = options.style || Toastify2.defaults.style;
            if (options.backgroundColor) {
              this.options.style.background = options.backgroundColor;
            }
            return this;
          },
          // Building the DOM element
          buildToast: function() {
            if (!this.options) {
              throw "Toastify is not initialized";
            }
            var divElement = document.createElement("div");
            divElement.className = "toastify on " + this.options.className;
            if (!!this.options.position) {
              divElement.className += " toastify-" + this.options.position;
            } else {
              if (this.options.positionLeft === true) {
                divElement.className += " toastify-left";
                console.warn("Property `positionLeft` will be depreciated in further versions. Please use `position` instead.");
              } else {
                divElement.className += " toastify-right";
              }
            }
            divElement.className += " " + this.options.gravity;
            if (this.options.backgroundColor) {
              console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
            }
            for (var property in this.options.style) {
              divElement.style[property] = this.options.style[property];
            }
            if (this.options.ariaLive) {
              divElement.setAttribute("aria-live", this.options.ariaLive);
            }
            if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
              divElement.appendChild(this.options.node);
            } else {
              if (this.options.escapeMarkup) {
                divElement.innerText = this.options.text;
              } else {
                divElement.innerHTML = this.options.text;
              }
              if (this.options.avatar !== "") {
                var avatarElement = document.createElement("img");
                avatarElement.src = this.options.avatar;
                avatarElement.className = "toastify-avatar";
                if (this.options.position == "left" || this.options.positionLeft === true) {
                  divElement.appendChild(avatarElement);
                } else {
                  divElement.insertAdjacentElement("afterbegin", avatarElement);
                }
              }
            }
            if (this.options.close === true) {
              var closeElement = document.createElement("button");
              closeElement.type = "button";
              closeElement.setAttribute("aria-label", "Close");
              closeElement.className = "toast-close";
              closeElement.innerHTML = "&#10006;";
              closeElement.addEventListener(
                "click",
                (function(event) {
                  event.stopPropagation();
                  this.removeElement(this.toastElement);
                  window.clearTimeout(this.toastElement.timeOutValue);
                }).bind(this)
              );
              var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
              if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
                divElement.insertAdjacentElement("afterbegin", closeElement);
              } else {
                divElement.appendChild(closeElement);
              }
            }
            if (this.options.stopOnFocus && this.options.duration > 0) {
              var self2 = this;
              divElement.addEventListener(
                "mouseover",
                function(event) {
                  window.clearTimeout(divElement.timeOutValue);
                }
              );
              divElement.addEventListener(
                "mouseleave",
                function() {
                  divElement.timeOutValue = window.setTimeout(
                    function() {
                      self2.removeElement(divElement);
                    },
                    self2.options.duration
                  );
                }
              );
            }
            if (typeof this.options.destination !== "undefined") {
              divElement.addEventListener(
                "click",
                (function(event) {
                  event.stopPropagation();
                  if (this.options.newWindow === true) {
                    window.open(this.options.destination, "_blank");
                  } else {
                    window.location = this.options.destination;
                  }
                }).bind(this)
              );
            }
            if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
              divElement.addEventListener(
                "click",
                (function(event) {
                  event.stopPropagation();
                  this.options.onClick();
                }).bind(this)
              );
            }
            if (typeof this.options.offset === "object") {
              var x = getAxisOffsetAValue("x", this.options);
              var y = getAxisOffsetAValue("y", this.options);
              var xOffset = this.options.position == "left" ? x : "-" + x;
              var yOffset = this.options.gravity == "toastify-top" ? y : "-" + y;
              divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";
            }
            return divElement;
          },
          // Displaying the toast
          showToast: function() {
            this.toastElement = this.buildToast();
            var rootElement;
            if (typeof this.options.selector === "string") {
              rootElement = document.getElementById(this.options.selector);
            } else if (this.options.selector instanceof HTMLElement || typeof ShadowRoot !== "undefined" && this.options.selector instanceof ShadowRoot) {
              rootElement = this.options.selector;
            } else {
              rootElement = document.body;
            }
            if (!rootElement) {
              throw "Root element is not defined";
            }
            var elementToInsert = Toastify2.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
            rootElement.insertBefore(this.toastElement, elementToInsert);
            Toastify2.reposition();
            if (this.options.duration > 0) {
              this.toastElement.timeOutValue = window.setTimeout(
                (function() {
                  this.removeElement(this.toastElement);
                }).bind(this),
                this.options.duration
              );
            }
            return this;
          },
          hideToast: function() {
            if (this.toastElement.timeOutValue) {
              clearTimeout(this.toastElement.timeOutValue);
            }
            this.removeElement(this.toastElement);
          },
          // Removing the element from the DOM
          removeElement: function(toastElement) {
            toastElement.className = toastElement.className.replace(" on", "");
            window.setTimeout(
              (function() {
                if (this.options.node && this.options.node.parentNode) {
                  this.options.node.parentNode.removeChild(this.options.node);
                }
                if (toastElement.parentNode) {
                  toastElement.parentNode.removeChild(toastElement);
                }
                this.options.callback.call(toastElement);
                Toastify2.reposition();
              }).bind(this),
              400
            );
          }
        };
        Toastify2.reposition = function() {
          var topLeftOffsetSize = {
            top: 15,
            bottom: 15
          };
          var topRightOffsetSize = {
            top: 15,
            bottom: 15
          };
          var offsetSize = {
            top: 15,
            bottom: 15
          };
          var allToasts = document.getElementsByClassName("toastify");
          var classUsed;
          for (var i2 = 0; i2 < allToasts.length; i2++) {
            if (containsClass(allToasts[i2], "toastify-top") === true) {
              classUsed = "toastify-top";
            } else {
              classUsed = "toastify-bottom";
            }
            var height = allToasts[i2].offsetHeight;
            classUsed = classUsed.substr(9, classUsed.length - 1);
            var offset = 15;
            var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
            if (width <= 360) {
              allToasts[i2].style[classUsed] = offsetSize[classUsed] + "px";
              offsetSize[classUsed] += height + offset;
            } else {
              if (containsClass(allToasts[i2], "toastify-left") === true) {
                allToasts[i2].style[classUsed] = topLeftOffsetSize[classUsed] + "px";
                topLeftOffsetSize[classUsed] += height + offset;
              } else {
                allToasts[i2].style[classUsed] = topRightOffsetSize[classUsed] + "px";
                topRightOffsetSize[classUsed] += height + offset;
              }
            }
          }
          return this;
        };
        function getAxisOffsetAValue(axis, options) {
          if (options.offset[axis]) {
            if (isNaN(options.offset[axis])) {
              return options.offset[axis];
            } else {
              return options.offset[axis] + "px";
            }
          }
          return "0px";
        }
        function containsClass(elem, yourClass) {
          if (!elem || typeof yourClass !== "string") {
            return false;
          } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
            return true;
          } else {
            return false;
          }
        }
        Toastify2.lib.init.prototype = Toastify2.lib;
        return Toastify2;
      });
    }
  });

  // node_modules/plyr/dist/plyr.min.js
  var require_plyr_min = __commonJS({
    "node_modules/plyr/dist/plyr.min.js"(exports, module) {
      "object" == typeof navigator && function(e2, t2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define("Plyr", t2) : (e2 = "undefined" != typeof globalThis ? globalThis : e2 || self).Plyr = t2();
      }(exports, function() {
        "use strict";
        function e2(e3, t3, i3) {
          return (t3 = function(e4) {
            var t4 = function(e5, t5) {
              if ("object" != typeof e5 || null === e5)
                return e5;
              var i4 = e5[Symbol.toPrimitive];
              if (void 0 !== i4) {
                var s3 = i4.call(e5, t5 || "default");
                if ("object" != typeof s3)
                  return s3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t5 ? String : Number)(e5);
            }(e4, "string");
            return "symbol" == typeof t4 ? t4 : String(t4);
          }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
        }
        function t2(e3, t3) {
          for (var i3 = 0; i3 < t3.length; i3++) {
            var s3 = t3[i3];
            s3.enumerable = s3.enumerable || false, s3.configurable = true, "value" in s3 && (s3.writable = true), Object.defineProperty(e3, s3.key, s3);
          }
        }
        function i2(e3, t3, i3) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
        }
        function s2(e3, t3) {
          var i3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var s3 = Object.getOwnPropertySymbols(e3);
            t3 && (s3 = s3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), i3.push.apply(i3, s3);
          }
          return i3;
        }
        function n2(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? s2(Object(n3), true).forEach(function(t4) {
              i2(e3, t4, n3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : s2(Object(n3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
            });
          }
          return e3;
        }
        var a2 = { addCSS: true, thumbWidth: 15, watch: true };
        var l2 = function(e3) {
          return null != e3 ? e3.constructor : null;
        }, r2 = function(e3, t3) {
          return !!(e3 && t3 && e3 instanceof t3);
        }, o2 = function(e3) {
          return null == e3;
        }, c2 = function(e3) {
          return l2(e3) === Object;
        }, u2 = function(e3) {
          return l2(e3) === String;
        }, h2 = function(e3) {
          return Array.isArray(e3);
        }, d2 = function(e3) {
          return r2(e3, NodeList);
        }, m = { nullOrUndefined: o2, object: c2, number: function(e3) {
          return l2(e3) === Number && !Number.isNaN(e3);
        }, string: u2, boolean: function(e3) {
          return l2(e3) === Boolean;
        }, function: function(e3) {
          return l2(e3) === Function;
        }, array: h2, nodeList: d2, element: function(e3) {
          return r2(e3, Element);
        }, event: function(e3) {
          return r2(e3, Event);
        }, empty: function(e3) {
          return o2(e3) || (u2(e3) || h2(e3) || d2(e3)) && !e3.length || c2(e3) && !Object.keys(e3).length;
        } };
        function p2(e3, t3) {
          if (1 > t3) {
            var i3 = function(e4) {
              var t4 = "".concat(e4).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
              return t4 ? Math.max(0, (t4[1] ? t4[1].length : 0) - (t4[2] ? +t4[2] : 0)) : 0;
            }(t3);
            return parseFloat(e3.toFixed(i3));
          }
          return Math.round(e3 / t3) * t3;
        }
        var g = function() {
          function e3(t3, i3) {
            (function(e4, t4) {
              if (!(e4 instanceof t4))
                throw new TypeError("Cannot call a class as a function");
            })(this, e3), m.element(t3) ? this.element = t3 : m.string(t3) && (this.element = document.querySelector(t3)), m.element(this.element) && m.empty(this.element.rangeTouch) && (this.config = n2({}, a2, {}, i3), this.init());
          }
          return function(e4, i3, s3) {
            i3 && t2(e4.prototype, i3), s3 && t2(e4, s3);
          }(e3, [{ key: "init", value: function() {
            e3.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(true), this.element.rangeTouch = this);
          } }, { key: "destroy", value: function() {
            e3.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(false), this.element.rangeTouch = null);
          } }, { key: "listeners", value: function(e4) {
            var t3 = this, i3 = e4 ? "addEventListener" : "removeEventListener";
            ["touchstart", "touchmove", "touchend"].forEach(function(e5) {
              t3.element[i3](e5, function(e6) {
                return t3.set(e6);
              }, false);
            });
          } }, { key: "get", value: function(t3) {
            if (!e3.enabled || !m.event(t3))
              return null;
            var i3, s3 = t3.target, n3 = t3.changedTouches[0], a3 = parseFloat(s3.getAttribute("min")) || 0, l3 = parseFloat(s3.getAttribute("max")) || 100, r3 = parseFloat(s3.getAttribute("step")) || 1, o3 = s3.getBoundingClientRect(), c3 = 100 / o3.width * (this.config.thumbWidth / 2) / 100;
            return 0 > (i3 = 100 / o3.width * (n3.clientX - o3.left)) ? i3 = 0 : 100 < i3 && (i3 = 100), 50 > i3 ? i3 -= (100 - 2 * i3) * c3 : 50 < i3 && (i3 += 2 * (i3 - 50) * c3), a3 + p2(i3 / 100 * (l3 - a3), r3);
          } }, { key: "set", value: function(t3) {
            e3.enabled && m.event(t3) && !t3.target.disabled && (t3.preventDefault(), t3.target.value = this.get(t3), function(e4, t4) {
              if (e4 && t4) {
                var i3 = new Event(t4, { bubbles: true });
                e4.dispatchEvent(i3);
              }
            }(t3.target, "touchend" === t3.type ? "change" : "input"));
          } }], [{ key: "setup", value: function(t3) {
            var i3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, s3 = null;
            if (m.empty(t3) || m.string(t3) ? s3 = Array.from(document.querySelectorAll(m.string(t3) ? t3 : 'input[type="range"]')) : m.element(t3) ? s3 = [t3] : m.nodeList(t3) ? s3 = Array.from(t3) : m.array(t3) && (s3 = t3.filter(m.element)), m.empty(s3))
              return null;
            var l3 = n2({}, a2, {}, i3);
            if (m.string(t3) && l3.watch) {
              var r3 = new MutationObserver(function(i4) {
                Array.from(i4).forEach(function(i5) {
                  Array.from(i5.addedNodes).forEach(function(i6) {
                    m.element(i6) && function(e4, t4) {
                      return (function() {
                        return Array.from(document.querySelectorAll(t4)).includes(this);
                      }).call(e4, t4);
                    }(i6, t3) && new e3(i6, l3);
                  });
                });
              });
              r3.observe(document.body, { childList: true, subtree: true });
            }
            return s3.map(function(t4) {
              return new e3(t4, i3);
            });
          } }, { key: "enabled", get: function() {
            return "ontouchstart" in document.documentElement;
          } }]), e3;
        }();
        const f = (e3) => null != e3 ? e3.constructor : null, y = (e3, t3) => Boolean(e3 && t3 && e3 instanceof t3), b = (e3) => null == e3, v2 = (e3) => f(e3) === Object, w = (e3) => f(e3) === String, T = (e3) => "function" == typeof e3, k = (e3) => Array.isArray(e3), C = (e3) => y(e3, NodeList), A = (e3) => b(e3) || (w(e3) || k(e3) || C(e3)) && !e3.length || v2(e3) && !Object.keys(e3).length;
        var S = { nullOrUndefined: b, object: v2, number: (e3) => f(e3) === Number && !Number.isNaN(e3), string: w, boolean: (e3) => f(e3) === Boolean, function: T, array: k, weakMap: (e3) => y(e3, WeakMap), nodeList: C, element: (e3) => null !== e3 && "object" == typeof e3 && 1 === e3.nodeType && "object" == typeof e3.style && "object" == typeof e3.ownerDocument, textNode: (e3) => f(e3) === Text, event: (e3) => y(e3, Event), keyboardEvent: (e3) => y(e3, KeyboardEvent), cue: (e3) => y(e3, window.TextTrackCue) || y(e3, window.VTTCue), track: (e3) => y(e3, TextTrack) || !b(e3) && w(e3.kind), promise: (e3) => y(e3, Promise) && T(e3.then), url: (e3) => {
          if (y(e3, window.URL))
            return true;
          if (!w(e3))
            return false;
          let t3 = e3;
          e3.startsWith("http://") && e3.startsWith("https://") || (t3 = "http://".concat(e3));
          try {
            return !A(new URL(t3).hostname);
          } catch (e4) {
            return false;
          }
        }, empty: A };
        const E = (() => {
          const e3 = document.createElement("span"), t3 = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }, i3 = Object.keys(t3).find((t4) => void 0 !== e3.style[t4]);
          return !!S.string(i3) && t3[i3];
        })();
        function P(e3, t3) {
          setTimeout(() => {
            try {
              e3.hidden = true, e3.offsetHeight, e3.hidden = false;
            } catch (e4) {
            }
          }, t3);
        }
        var M = { isIE: Boolean(window.document.documentMode), isEdge: /Edge/g.test(navigator.userAgent), isWebKit: "WebkitAppearance" in document.documentElement.style && !/Edge/g.test(navigator.userAgent), isIPhone: /iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1, isIPadOS: "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1, isIos: /iPad|iPhone|iPod/gi.test(navigator.userAgent) && navigator.maxTouchPoints > 1 };
        function N(e3, t3) {
          return t3.split(".").reduce((e4, t4) => e4 && e4[t4], e3);
        }
        function x(e3 = {}, ...t3) {
          if (!t3.length)
            return e3;
          const i3 = t3.shift();
          return S.object(i3) ? (Object.keys(i3).forEach((t4) => {
            S.object(i3[t4]) ? (Object.keys(e3).includes(t4) || Object.assign(e3, { [t4]: {} }), x(e3[t4], i3[t4])) : Object.assign(e3, { [t4]: i3[t4] });
          }), x(e3, ...t3)) : e3;
        }
        function L(e3, t3) {
          const i3 = e3.length ? e3 : [e3];
          Array.from(i3).reverse().forEach((e4, i4) => {
            const s3 = i4 > 0 ? t3.cloneNode(true) : t3, n3 = e4.parentNode, a3 = e4.nextSibling;
            s3.appendChild(e4), a3 ? n3.insertBefore(s3, a3) : n3.appendChild(s3);
          });
        }
        function I(e3, t3) {
          S.element(e3) && !S.empty(t3) && Object.entries(t3).filter(([, e4]) => !S.nullOrUndefined(e4)).forEach(([t4, i3]) => e3.setAttribute(t4, i3));
        }
        function $(e3, t3, i3) {
          const s3 = document.createElement(e3);
          return S.object(t3) && I(s3, t3), S.string(i3) && (s3.innerText = i3), s3;
        }
        function _(e3, t3, i3, s3) {
          S.element(t3) && t3.appendChild($(e3, i3, s3));
        }
        function O(e3) {
          S.nodeList(e3) || S.array(e3) ? Array.from(e3).forEach(O) : S.element(e3) && S.element(e3.parentNode) && e3.parentNode.removeChild(e3);
        }
        function j(e3) {
          if (!S.element(e3))
            return;
          let { length: t3 } = e3.childNodes;
          for (; t3 > 0; )
            e3.removeChild(e3.lastChild), t3 -= 1;
        }
        function q(e3, t3) {
          return S.element(t3) && S.element(t3.parentNode) && S.element(e3) ? (t3.parentNode.replaceChild(e3, t3), e3) : null;
        }
        function D(e3, t3) {
          if (!S.string(e3) || S.empty(e3))
            return {};
          const i3 = {}, s3 = x({}, t3);
          return e3.split(",").forEach((e4) => {
            const t4 = e4.trim(), n3 = t4.replace(".", ""), a3 = t4.replace(/[[\]]/g, "").split("="), [l3] = a3, r3 = a3.length > 1 ? a3[1].replace(/["']/g, "") : "";
            switch (t4.charAt(0)) {
              case ".":
                S.string(s3.class) ? i3.class = "".concat(s3.class, " ").concat(n3) : i3.class = n3;
                break;
              case "#":
                i3.id = t4.replace("#", "");
                break;
              case "[":
                i3[l3] = r3;
            }
          }), x(s3, i3);
        }
        function H(e3, t3) {
          if (!S.element(e3))
            return;
          let i3 = t3;
          S.boolean(i3) || (i3 = !e3.hidden), e3.hidden = i3;
        }
        function R(e3, t3, i3) {
          if (S.nodeList(e3))
            return Array.from(e3).map((e4) => R(e4, t3, i3));
          if (S.element(e3)) {
            let s3 = "toggle";
            return void 0 !== i3 && (s3 = i3 ? "add" : "remove"), e3.classList[s3](t3), e3.classList.contains(t3);
          }
          return false;
        }
        function F(e3, t3) {
          return S.element(e3) && e3.classList.contains(t3);
        }
        function V(e3, t3) {
          const { prototype: i3 } = Element;
          return (i3.matches || i3.webkitMatchesSelector || i3.mozMatchesSelector || i3.msMatchesSelector || function() {
            return Array.from(document.querySelectorAll(t3)).includes(this);
          }).call(e3, t3);
        }
        function U(e3) {
          return this.elements.container.querySelectorAll(e3);
        }
        function B(e3) {
          return this.elements.container.querySelector(e3);
        }
        function W(e3 = null, t3 = false) {
          S.element(e3) && e3.focus({ preventScroll: true, focusVisible: t3 });
        }
        const z = { "audio/ogg": "vorbis", "audio/wav": "1", "video/webm": "vp8, vorbis", "video/mp4": "avc1.42E01E, mp4a.40.2", "video/ogg": "theora" }, K = { audio: "canPlayType" in document.createElement("audio"), video: "canPlayType" in document.createElement("video"), check(e3, t3) {
          const i3 = K[e3] || "html5" !== t3;
          return { api: i3, ui: i3 && K.rangeInput };
        }, pip: !(M.isIPhone || !S.function($("video").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || $("video").disablePictureInPicture)), airplay: S.function(window.WebKitPlaybackTargetAvailabilityEvent), playsinline: "playsInline" in document.createElement("video"), mime(e3) {
          if (S.empty(e3))
            return false;
          const [t3] = e3.split("/");
          let i3 = e3;
          if (!this.isHTML5 || t3 !== this.type)
            return false;
          Object.keys(z).includes(i3) && (i3 += '; codecs="'.concat(z[e3], '"'));
          try {
            return Boolean(i3 && this.media.canPlayType(i3).replace(/no/, ""));
          } catch (e4) {
            return false;
          }
        }, textTracks: "textTracks" in document.createElement("video"), rangeInput: (() => {
          const e3 = document.createElement("input");
          return e3.type = "range", "range" === e3.type;
        })(), touch: "ontouchstart" in document.documentElement, transitions: false !== E, reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches }, Y = (() => {
          let e3 = false;
          try {
            const t3 = Object.defineProperty({}, "passive", { get: () => (e3 = true, null) });
            window.addEventListener("test", null, t3), window.removeEventListener("test", null, t3);
          } catch (e4) {
          }
          return e3;
        })();
        function Q(e3, t3, i3, s3 = false, n3 = true, a3 = false) {
          if (!e3 || !("addEventListener" in e3) || S.empty(t3) || !S.function(i3))
            return;
          const l3 = t3.split(" ");
          let r3 = a3;
          Y && (r3 = { passive: n3, capture: a3 }), l3.forEach((t4) => {
            this && this.eventListeners && s3 && this.eventListeners.push({ element: e3, type: t4, callback: i3, options: r3 }), e3[s3 ? "addEventListener" : "removeEventListener"](t4, i3, r3);
          });
        }
        function X(e3, t3 = "", i3, s3 = true, n3 = false) {
          Q.call(this, e3, t3, i3, true, s3, n3);
        }
        function J(e3, t3 = "", i3, s3 = true, n3 = false) {
          Q.call(this, e3, t3, i3, false, s3, n3);
        }
        function G(e3, t3 = "", i3, s3 = true, n3 = false) {
          const a3 = (...l3) => {
            J(e3, t3, a3, s3, n3), i3.apply(this, l3);
          };
          Q.call(this, e3, t3, a3, true, s3, n3);
        }
        function Z(e3, t3 = "", i3 = false, s3 = {}) {
          if (!S.element(e3) || S.empty(t3))
            return;
          const n3 = new CustomEvent(t3, { bubbles: i3, detail: __spreadProps(__spreadValues({}, s3), { plyr: this }) });
          e3.dispatchEvent(n3);
        }
        function ee() {
          this && this.eventListeners && (this.eventListeners.forEach((e3) => {
            const { element: t3, type: i3, callback: s3, options: n3 } = e3;
            t3.removeEventListener(i3, s3, n3);
          }), this.eventListeners = []);
        }
        function te() {
          return new Promise((e3) => this.ready ? setTimeout(e3, 0) : X.call(this, this.elements.container, "ready", e3)).then(() => {
          });
        }
        function ie(e3) {
          S.promise(e3) && e3.then(null, () => {
          });
        }
        function se(e3) {
          return S.array(e3) ? e3.filter((t3, i3) => e3.indexOf(t3) === i3) : e3;
        }
        function ne(e3, t3) {
          return S.array(e3) && e3.length ? e3.reduce((e4, i3) => Math.abs(i3 - t3) < Math.abs(e4 - t3) ? i3 : e4) : null;
        }
        function ae(e3) {
          return !(!window || !window.CSS) && window.CSS.supports(e3);
        }
        const le = [[1, 1], [4, 3], [3, 4], [5, 4], [4, 5], [3, 2], [2, 3], [16, 10], [10, 16], [16, 9], [9, 16], [21, 9], [9, 21], [32, 9], [9, 32]].reduce((e3, [t3, i3]) => __spreadProps(__spreadValues({}, e3), { [t3 / i3]: [t3, i3] }), {});
        function re(e3) {
          if (!(S.array(e3) || S.string(e3) && e3.includes(":")))
            return false;
          return (S.array(e3) ? e3 : e3.split(":")).map(Number).every(S.number);
        }
        function oe(e3) {
          if (!S.array(e3) || !e3.every(S.number))
            return null;
          const [t3, i3] = e3, s3 = (e4, t4) => 0 === t4 ? e4 : s3(t4, e4 % t4), n3 = s3(t3, i3);
          return [t3 / n3, i3 / n3];
        }
        function ce(e3) {
          const t3 = (e4) => re(e4) ? e4.split(":").map(Number) : null;
          let i3 = t3(e3);
          if (null === i3 && (i3 = t3(this.config.ratio)), null === i3 && !S.empty(this.embed) && S.array(this.embed.ratio) && ({ ratio: i3 } = this.embed), null === i3 && this.isHTML5) {
            const { videoWidth: e4, videoHeight: t4 } = this.media;
            i3 = [e4, t4];
          }
          return oe(i3);
        }
        function ue(e3) {
          if (!this.isVideo)
            return {};
          const { wrapper: t3 } = this.elements, i3 = ce.call(this, e3);
          if (!S.array(i3))
            return {};
          const [s3, n3] = oe(i3), a3 = 100 / s3 * n3;
          if (ae("aspect-ratio: ".concat(s3, "/").concat(n3)) ? t3.style.aspectRatio = "".concat(s3, "/").concat(n3) : t3.style.paddingBottom = "".concat(a3, "%"), this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
            const e4 = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10), i4 = (e4 - a3) / (e4 / 50);
            this.fullscreen.active ? t3.style.paddingBottom = null : this.media.style.transform = "translateY(-".concat(i4, "%)");
          } else
            this.isHTML5 && t3.classList.add(this.config.classNames.videoFixedRatio);
          return { padding: a3, ratio: i3 };
        }
        function he(e3, t3, i3 = 0.05) {
          const s3 = e3 / t3, n3 = ne(Object.keys(le), s3);
          return Math.abs(n3 - s3) <= i3 ? le[n3] : [e3, t3];
        }
        const de = { getSources() {
          if (!this.isHTML5)
            return [];
          return Array.from(this.media.querySelectorAll("source")).filter((e3) => {
            const t3 = e3.getAttribute("type");
            return !!S.empty(t3) || K.mime.call(this, t3);
          });
        }, getQualityOptions() {
          return this.config.quality.forced ? this.config.quality.options : de.getSources.call(this).map((e3) => Number(e3.getAttribute("size"))).filter(Boolean);
        }, setup() {
          if (!this.isHTML5)
            return;
          const e3 = this;
          e3.options.speed = e3.config.speed.options, S.empty(this.config.ratio) || ue.call(e3), Object.defineProperty(e3.media, "quality", { get() {
            const t3 = de.getSources.call(e3).find((t4) => t4.getAttribute("src") === e3.source);
            return t3 && Number(t3.getAttribute("size"));
          }, set(t3) {
            if (e3.quality !== t3) {
              if (e3.config.quality.forced && S.function(e3.config.quality.onChange))
                e3.config.quality.onChange(t3);
              else {
                const i3 = de.getSources.call(e3).find((e4) => Number(e4.getAttribute("size")) === t3);
                if (!i3)
                  return;
                const { currentTime: s3, paused: n3, preload: a3, readyState: l3, playbackRate: r3 } = e3.media;
                e3.media.src = i3.getAttribute("src"), ("none" !== a3 || l3) && (e3.once("loadedmetadata", () => {
                  e3.speed = r3, e3.currentTime = s3, n3 || ie(e3.play());
                }), e3.media.load());
              }
              Z.call(e3, e3.media, "qualitychange", false, { quality: t3 });
            }
          } });
        }, cancelRequests() {
          this.isHTML5 && (O(de.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"));
        } };
        function me(e3, ...t3) {
          return S.empty(e3) ? e3 : e3.toString().replace(/{(\d+)}/g, (e4, i3) => t3[i3].toString());
        }
        const pe = (e3 = "", t3 = "", i3 = "") => e3.replace(new RegExp(t3.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), i3.toString()), ge = (e3 = "") => e3.toString().replace(/\w\S*/g, (e4) => e4.charAt(0).toUpperCase() + e4.slice(1).toLowerCase());
        function fe(e3 = "") {
          let t3 = e3.toString();
          return t3 = function(e4 = "") {
            let t4 = e4.toString();
            return t4 = pe(t4, "-", " "), t4 = pe(t4, "_", " "), t4 = ge(t4), pe(t4, " ", "");
          }(t3), t3.charAt(0).toLowerCase() + t3.slice(1);
        }
        function ye(e3) {
          const t3 = document.createElement("div");
          return t3.appendChild(e3), t3.innerHTML;
        }
        const be = { pip: "PIP", airplay: "AirPlay", html5: "HTML5", vimeo: "Vimeo", youtube: "YouTube" }, ve = { get(e3 = "", t3 = {}) {
          if (S.empty(e3) || S.empty(t3))
            return "";
          let i3 = N(t3.i18n, e3);
          if (S.empty(i3))
            return Object.keys(be).includes(e3) ? be[e3] : "";
          const s3 = { "{seektime}": t3.seekTime, "{title}": t3.title };
          return Object.entries(s3).forEach(([e4, t4]) => {
            i3 = pe(i3, e4, t4);
          }), i3;
        } };
        class we {
          constructor(t3) {
            e2(this, "get", (e3) => {
              if (!we.supported || !this.enabled)
                return null;
              const t4 = window.localStorage.getItem(this.key);
              if (S.empty(t4))
                return null;
              const i3 = JSON.parse(t4);
              return S.string(e3) && e3.length ? i3[e3] : i3;
            }), e2(this, "set", (e3) => {
              if (!we.supported || !this.enabled)
                return;
              if (!S.object(e3))
                return;
              let t4 = this.get();
              S.empty(t4) && (t4 = {}), x(t4, e3);
              try {
                window.localStorage.setItem(this.key, JSON.stringify(t4));
              } catch (e4) {
              }
            }), this.enabled = t3.config.storage.enabled, this.key = t3.config.storage.key;
          }
          static get supported() {
            try {
              if (!("localStorage" in window))
                return false;
              const e3 = "___test";
              return window.localStorage.setItem(e3, e3), window.localStorage.removeItem(e3), true;
            } catch (e3) {
              return false;
            }
          }
        }
        function Te(e3, t3 = "text") {
          return new Promise((i3, s3) => {
            try {
              const s4 = new XMLHttpRequest();
              if (!("withCredentials" in s4))
                return;
              s4.addEventListener("load", () => {
                if ("text" === t3)
                  try {
                    i3(JSON.parse(s4.responseText));
                  } catch (e4) {
                    i3(s4.responseText);
                  }
                else
                  i3(s4.response);
              }), s4.addEventListener("error", () => {
                throw new Error(s4.status);
              }), s4.open("GET", e3, true), s4.responseType = t3, s4.send();
            } catch (e4) {
              s3(e4);
            }
          });
        }
        function ke(e3, t3) {
          if (!S.string(e3))
            return;
          const i3 = "cache", s3 = S.string(t3);
          let n3 = false;
          const a3 = () => null !== document.getElementById(t3), l3 = (e4, t4) => {
            e4.innerHTML = t4, s3 && a3() || document.body.insertAdjacentElement("afterbegin", e4);
          };
          if (!s3 || !a3()) {
            const a4 = we.supported, r3 = document.createElement("div");
            if (r3.setAttribute("hidden", ""), s3 && r3.setAttribute("id", t3), a4) {
              const e4 = window.localStorage.getItem("".concat(i3, "-").concat(t3));
              if (n3 = null !== e4, n3) {
                const t4 = JSON.parse(e4);
                l3(r3, t4.content);
              }
            }
            Te(e3).then((e4) => {
              if (!S.empty(e4)) {
                if (a4)
                  try {
                    window.localStorage.setItem("".concat(i3, "-").concat(t3), JSON.stringify({ content: e4 }));
                  } catch (e5) {
                  }
                l3(r3, e4);
              }
            }).catch(() => {
            });
          }
        }
        const Ce = (e3) => Math.trunc(e3 / 60 / 60 % 60, 10), Ae = (e3) => Math.trunc(e3 / 60 % 60, 10), Se = (e3) => Math.trunc(e3 % 60, 10);
        function Ee(e3 = 0, t3 = false, i3 = false) {
          if (!S.number(e3))
            return Ee(void 0, t3, i3);
          const s3 = (e4) => "0".concat(e4).slice(-2);
          let n3 = Ce(e3);
          const a3 = Ae(e3), l3 = Se(e3);
          return n3 = t3 || n3 > 0 ? "".concat(n3, ":") : "", "".concat(i3 && e3 > 0 ? "-" : "").concat(n3).concat(s3(a3), ":").concat(s3(l3));
        }
        const Pe = { getIconUrl() {
          const e3 = new URL(this.config.iconUrl, window.location), t3 = window.location.host ? window.location.host : window.top.location.host, i3 = e3.host !== t3 || M.isIE && !window.svg4everybody;
          return { url: this.config.iconUrl, cors: i3 };
        }, findElements() {
          try {
            return this.elements.controls = B.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = { play: U.call(this, this.config.selectors.buttons.play), pause: B.call(this, this.config.selectors.buttons.pause), restart: B.call(this, this.config.selectors.buttons.restart), rewind: B.call(this, this.config.selectors.buttons.rewind), fastForward: B.call(this, this.config.selectors.buttons.fastForward), mute: B.call(this, this.config.selectors.buttons.mute), pip: B.call(this, this.config.selectors.buttons.pip), airplay: B.call(this, this.config.selectors.buttons.airplay), settings: B.call(this, this.config.selectors.buttons.settings), captions: B.call(this, this.config.selectors.buttons.captions), fullscreen: B.call(this, this.config.selectors.buttons.fullscreen) }, this.elements.progress = B.call(this, this.config.selectors.progress), this.elements.inputs = { seek: B.call(this, this.config.selectors.inputs.seek), volume: B.call(this, this.config.selectors.inputs.volume) }, this.elements.display = { buffer: B.call(this, this.config.selectors.display.buffer), currentTime: B.call(this, this.config.selectors.display.currentTime), duration: B.call(this, this.config.selectors.display.duration) }, S.element(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(".".concat(this.config.classNames.tooltip))), true;
          } catch (e3) {
            return this.debug.warn("It looks like there is a problem with your custom controls HTML", e3), this.toggleNativeControls(true), false;
          }
        }, createIcon(e3, t3) {
          const i3 = "http://www.w3.org/2000/svg", s3 = Pe.getIconUrl.call(this), n3 = "".concat(s3.cors ? "" : s3.url, "#").concat(this.config.iconPrefix), a3 = document.createElementNS(i3, "svg");
          I(a3, x(t3, { "aria-hidden": "true", focusable: "false" }));
          const l3 = document.createElementNS(i3, "use"), r3 = "".concat(n3, "-").concat(e3);
          return "href" in l3 && l3.setAttributeNS("http://www.w3.org/1999/xlink", "href", r3), l3.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", r3), a3.appendChild(l3), a3;
        }, createLabel(e3, t3 = {}) {
          const i3 = ve.get(e3, this.config);
          return $("span", __spreadProps(__spreadValues({}, t3), { class: [t3.class, this.config.classNames.hidden].filter(Boolean).join(" ") }), i3);
        }, createBadge(e3) {
          if (S.empty(e3))
            return null;
          const t3 = $("span", { class: this.config.classNames.menu.value });
          return t3.appendChild($("span", { class: this.config.classNames.menu.badge }, e3)), t3;
        }, createButton(e3, t3) {
          const i3 = x({}, t3);
          let s3 = fe(e3);
          const n3 = { element: "button", toggle: false, label: null, icon: null, labelPressed: null, iconPressed: null };
          switch (["element", "icon", "label"].forEach((e4) => {
            Object.keys(i3).includes(e4) && (n3[e4] = i3[e4], delete i3[e4]);
          }), "button" !== n3.element || Object.keys(i3).includes("type") || (i3.type = "button"), Object.keys(i3).includes("class") ? i3.class.split(" ").some((e4) => e4 === this.config.classNames.control) || x(i3, { class: "".concat(i3.class, " ").concat(this.config.classNames.control) }) : i3.class = this.config.classNames.control, e3) {
            case "play":
              n3.toggle = true, n3.label = "play", n3.labelPressed = "pause", n3.icon = "play", n3.iconPressed = "pause";
              break;
            case "mute":
              n3.toggle = true, n3.label = "mute", n3.labelPressed = "unmute", n3.icon = "volume", n3.iconPressed = "muted";
              break;
            case "captions":
              n3.toggle = true, n3.label = "enableCaptions", n3.labelPressed = "disableCaptions", n3.icon = "captions-off", n3.iconPressed = "captions-on";
              break;
            case "fullscreen":
              n3.toggle = true, n3.label = "enterFullscreen", n3.labelPressed = "exitFullscreen", n3.icon = "enter-fullscreen", n3.iconPressed = "exit-fullscreen";
              break;
            case "play-large":
              i3.class += " ".concat(this.config.classNames.control, "--overlaid"), s3 = "play", n3.label = "play", n3.icon = "play";
              break;
            default:
              S.empty(n3.label) && (n3.label = s3), S.empty(n3.icon) && (n3.icon = e3);
          }
          const a3 = $(n3.element);
          return n3.toggle ? (a3.appendChild(Pe.createIcon.call(this, n3.iconPressed, { class: "icon--pressed" })), a3.appendChild(Pe.createIcon.call(this, n3.icon, { class: "icon--not-pressed" })), a3.appendChild(Pe.createLabel.call(this, n3.labelPressed, { class: "label--pressed" })), a3.appendChild(Pe.createLabel.call(this, n3.label, { class: "label--not-pressed" }))) : (a3.appendChild(Pe.createIcon.call(this, n3.icon)), a3.appendChild(Pe.createLabel.call(this, n3.label))), x(i3, D(this.config.selectors.buttons[s3], i3)), I(a3, i3), "play" === s3 ? (S.array(this.elements.buttons[s3]) || (this.elements.buttons[s3] = []), this.elements.buttons[s3].push(a3)) : this.elements.buttons[s3] = a3, a3;
        }, createRange(e3, t3) {
          const i3 = $("input", x(D(this.config.selectors.inputs[e3]), { type: "range", min: 0, max: 100, step: 0.01, value: 0, autocomplete: "off", role: "slider", "aria-label": ve.get(e3, this.config), "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": 0 }, t3));
          return this.elements.inputs[e3] = i3, Pe.updateRangeFill.call(this, i3), g.setup(i3), i3;
        }, createProgress(e3, t3) {
          const i3 = $("progress", x(D(this.config.selectors.display[e3]), { min: 0, max: 100, value: 0, role: "progressbar", "aria-hidden": true }, t3));
          if ("volume" !== e3) {
            i3.appendChild($("span", null, "0"));
            const t4 = { played: "played", buffer: "buffered" }[e3], s3 = t4 ? ve.get(t4, this.config) : "";
            i3.innerText = "% ".concat(s3.toLowerCase());
          }
          return this.elements.display[e3] = i3, i3;
        }, createTime(e3, t3) {
          const i3 = D(this.config.selectors.display[e3], t3), s3 = $("div", x(i3, { class: "".concat(i3.class ? i3.class : "", " ").concat(this.config.classNames.display.time, " ").trim(), "aria-label": ve.get(e3, this.config), role: "timer" }), "00:00");
          return this.elements.display[e3] = s3, s3;
        }, bindMenuItemShortcuts(e3, t3) {
          X.call(this, e3, "keydown keyup", (i3) => {
            if (![" ", "ArrowUp", "ArrowDown", "ArrowRight"].includes(i3.key))
              return;
            if (i3.preventDefault(), i3.stopPropagation(), "keydown" === i3.type)
              return;
            const s3 = V(e3, '[role="menuitemradio"]');
            if (!s3 && [" ", "ArrowRight"].includes(i3.key))
              Pe.showMenuPanel.call(this, t3, true);
            else {
              let t4;
              " " !== i3.key && ("ArrowDown" === i3.key || s3 && "ArrowRight" === i3.key ? (t4 = e3.nextElementSibling, S.element(t4) || (t4 = e3.parentNode.firstElementChild)) : (t4 = e3.previousElementSibling, S.element(t4) || (t4 = e3.parentNode.lastElementChild)), W.call(this, t4, true));
            }
          }, false), X.call(this, e3, "keyup", (e4) => {
            "Return" === e4.key && Pe.focusFirstMenuItem.call(this, null, true);
          });
        }, createMenuItem({ value: e3, list: t3, type: i3, title: s3, badge: n3 = null, checked: a3 = false }) {
          const l3 = D(this.config.selectors.inputs[i3]), r3 = $("button", x(l3, { type: "button", role: "menuitemradio", class: "".concat(this.config.classNames.control, " ").concat(l3.class ? l3.class : "").trim(), "aria-checked": a3, value: e3 })), o3 = $("span");
          o3.innerHTML = s3, S.element(n3) && o3.appendChild(n3), r3.appendChild(o3), Object.defineProperty(r3, "checked", { enumerable: true, get: () => "true" === r3.getAttribute("aria-checked"), set(e4) {
            e4 && Array.from(r3.parentNode.children).filter((e5) => V(e5, '[role="menuitemradio"]')).forEach((e5) => e5.setAttribute("aria-checked", "false")), r3.setAttribute("aria-checked", e4 ? "true" : "false");
          } }), this.listeners.bind(r3, "click keyup", (t4) => {
            if (!S.keyboardEvent(t4) || " " === t4.key) {
              switch (t4.preventDefault(), t4.stopPropagation(), r3.checked = true, i3) {
                case "language":
                  this.currentTrack = Number(e3);
                  break;
                case "quality":
                  this.quality = e3;
                  break;
                case "speed":
                  this.speed = parseFloat(e3);
              }
              Pe.showMenuPanel.call(this, "home", S.keyboardEvent(t4));
            }
          }, i3, false), Pe.bindMenuItemShortcuts.call(this, r3, i3), t3.appendChild(r3);
        }, formatTime(e3 = 0, t3 = false) {
          if (!S.number(e3))
            return e3;
          return Ee(e3, Ce(this.duration) > 0, t3);
        }, updateTimeDisplay(e3 = null, t3 = 0, i3 = false) {
          S.element(e3) && S.number(t3) && (e3.innerText = Pe.formatTime(t3, i3));
        }, updateVolume() {
          this.supported.ui && (S.element(this.elements.inputs.volume) && Pe.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), S.element(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume));
        }, setRange(e3, t3 = 0) {
          S.element(e3) && (e3.value = t3, Pe.updateRangeFill.call(this, e3));
        }, updateProgress(e3) {
          if (!this.supported.ui || !S.event(e3))
            return;
          let t3 = 0;
          const i3 = (e4, t4) => {
            const i4 = S.number(t4) ? t4 : 0, s4 = S.element(e4) ? e4 : this.elements.display.buffer;
            if (S.element(s4)) {
              s4.value = i4;
              const e5 = s4.getElementsByTagName("span")[0];
              S.element(e5) && (e5.childNodes[0].nodeValue = i4);
            }
          };
          if (e3)
            switch (e3.type) {
              case "timeupdate":
              case "seeking":
              case "seeked":
                s3 = this.currentTime, n3 = this.duration, t3 = 0 === s3 || 0 === n3 || Number.isNaN(s3) || Number.isNaN(n3) ? 0 : (s3 / n3 * 100).toFixed(2), "timeupdate" === e3.type && Pe.setRange.call(this, this.elements.inputs.seek, t3);
                break;
              case "playing":
              case "progress":
                i3(this.elements.display.buffer, 100 * this.buffered);
            }
          var s3, n3;
        }, updateRangeFill(e3) {
          const t3 = S.event(e3) ? e3.target : e3;
          if (S.element(t3) && "range" === t3.getAttribute("type")) {
            if (V(t3, this.config.selectors.inputs.seek)) {
              t3.setAttribute("aria-valuenow", this.currentTime);
              const e4 = Pe.formatTime(this.currentTime), i3 = Pe.formatTime(this.duration), s3 = ve.get("seekLabel", this.config);
              t3.setAttribute("aria-valuetext", s3.replace("{currentTime}", e4).replace("{duration}", i3));
            } else if (V(t3, this.config.selectors.inputs.volume)) {
              const e4 = 100 * t3.value;
              t3.setAttribute("aria-valuenow", e4), t3.setAttribute("aria-valuetext", "".concat(e4.toFixed(1), "%"));
            } else
              t3.setAttribute("aria-valuenow", t3.value);
            (M.isWebKit || M.isIPadOS) && t3.style.setProperty("--value", t3.value / t3.max * 100 + "%");
          }
        }, updateSeekTooltip(e3) {
          var t3, i3;
          if (!this.config.tooltips.seek || !S.element(this.elements.inputs.seek) || !S.element(this.elements.display.seekTooltip) || 0 === this.duration)
            return;
          const s3 = this.elements.display.seekTooltip, n3 = "".concat(this.config.classNames.tooltip, "--visible"), a3 = (e4) => R(s3, n3, e4);
          if (this.touch)
            return void a3(false);
          let l3 = 0;
          const r3 = this.elements.progress.getBoundingClientRect();
          if (S.event(e3))
            l3 = 100 / r3.width * (e3.pageX - r3.left);
          else {
            if (!F(s3, n3))
              return;
            l3 = parseFloat(s3.style.left, 10);
          }
          l3 < 0 ? l3 = 0 : l3 > 100 && (l3 = 100);
          const o3 = this.duration / 100 * l3;
          s3.innerText = Pe.formatTime(o3);
          const c3 = null === (t3 = this.config.markers) || void 0 === t3 || null === (i3 = t3.points) || void 0 === i3 ? void 0 : i3.find(({ time: e4 }) => e4 === Math.round(o3));
          c3 && s3.insertAdjacentHTML("afterbegin", "".concat(c3.label, "<br>")), s3.style.left = "".concat(l3, "%"), S.event(e3) && ["mouseenter", "mouseleave"].includes(e3.type) && a3("mouseenter" === e3.type);
        }, timeUpdate(e3) {
          const t3 = !S.element(this.elements.display.duration) && this.config.invertTime;
          Pe.updateTimeDisplay.call(this, this.elements.display.currentTime, t3 ? this.duration - this.currentTime : this.currentTime, t3), e3 && "timeupdate" === e3.type && this.media.seeking || Pe.updateProgress.call(this, e3);
        }, durationUpdate() {
          if (!this.supported.ui || !this.config.invertTime && this.currentTime)
            return;
          if (this.duration >= __pow(2, 32))
            return H(this.elements.display.currentTime, true), void H(this.elements.progress, true);
          S.element(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
          const e3 = S.element(this.elements.display.duration);
          !e3 && this.config.displayDuration && this.paused && Pe.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e3 && Pe.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), this.config.markers.enabled && Pe.setMarkers.call(this), Pe.updateSeekTooltip.call(this);
        }, toggleMenuButton(e3, t3) {
          H(this.elements.settings.buttons[e3], !t3);
        }, updateSetting(e3, t3, i3) {
          const s3 = this.elements.settings.panels[e3];
          let n3 = null, a3 = t3;
          if ("captions" === e3)
            n3 = this.currentTrack;
          else {
            if (n3 = S.empty(i3) ? this[e3] : i3, S.empty(n3) && (n3 = this.config[e3].default), !S.empty(this.options[e3]) && !this.options[e3].includes(n3))
              return void this.debug.warn("Unsupported value of '".concat(n3, "' for ").concat(e3));
            if (!this.config[e3].options.includes(n3))
              return void this.debug.warn("Disabled value of '".concat(n3, "' for ").concat(e3));
          }
          if (S.element(a3) || (a3 = s3 && s3.querySelector('[role="menu"]')), !S.element(a3))
            return;
          this.elements.settings.buttons[e3].querySelector(".".concat(this.config.classNames.menu.value)).innerHTML = Pe.getLabel.call(this, e3, n3);
          const l3 = a3 && a3.querySelector('[value="'.concat(n3, '"]'));
          S.element(l3) && (l3.checked = true);
        }, getLabel(e3, t3) {
          switch (e3) {
            case "speed":
              return 1 === t3 ? ve.get("normal", this.config) : "".concat(t3, "&times;");
            case "quality":
              if (S.number(t3)) {
                const e4 = ve.get("qualityLabel.".concat(t3), this.config);
                return e4.length ? e4 : "".concat(t3, "p");
              }
              return ge(t3);
            case "captions":
              return xe.getLabel.call(this);
            default:
              return null;
          }
        }, setQualityMenu(e3) {
          if (!S.element(this.elements.settings.panels.quality))
            return;
          const t3 = "quality", i3 = this.elements.settings.panels.quality.querySelector('[role="menu"]');
          S.array(e3) && (this.options.quality = se(e3).filter((e4) => this.config.quality.options.includes(e4)));
          const s3 = !S.empty(this.options.quality) && this.options.quality.length > 1;
          if (Pe.toggleMenuButton.call(this, t3, s3), j(i3), Pe.checkMenu.call(this), !s3)
            return;
          const n3 = (e4) => {
            const t4 = ve.get("qualityBadge.".concat(e4), this.config);
            return t4.length ? Pe.createBadge.call(this, t4) : null;
          };
          this.options.quality.sort((e4, t4) => {
            const i4 = this.config.quality.options;
            return i4.indexOf(e4) > i4.indexOf(t4) ? 1 : -1;
          }).forEach((e4) => {
            Pe.createMenuItem.call(this, { value: e4, list: i3, type: t3, title: Pe.getLabel.call(this, "quality", e4), badge: n3(e4) });
          }), Pe.updateSetting.call(this, t3, i3);
        }, setCaptionsMenu() {
          if (!S.element(this.elements.settings.panels.captions))
            return;
          const e3 = "captions", t3 = this.elements.settings.panels.captions.querySelector('[role="menu"]'), i3 = xe.getTracks.call(this), s3 = Boolean(i3.length);
          if (Pe.toggleMenuButton.call(this, e3, s3), j(t3), Pe.checkMenu.call(this), !s3)
            return;
          const n3 = i3.map((e4, i4) => ({ value: i4, checked: this.captions.toggled && this.currentTrack === i4, title: xe.getLabel.call(this, e4), badge: e4.language && Pe.createBadge.call(this, e4.language.toUpperCase()), list: t3, type: "language" }));
          n3.unshift({ value: -1, checked: !this.captions.toggled, title: ve.get("disabled", this.config), list: t3, type: "language" }), n3.forEach(Pe.createMenuItem.bind(this)), Pe.updateSetting.call(this, e3, t3);
        }, setSpeedMenu() {
          if (!S.element(this.elements.settings.panels.speed))
            return;
          const e3 = "speed", t3 = this.elements.settings.panels.speed.querySelector('[role="menu"]');
          this.options.speed = this.options.speed.filter((e4) => e4 >= this.minimumSpeed && e4 <= this.maximumSpeed);
          const i3 = !S.empty(this.options.speed) && this.options.speed.length > 1;
          Pe.toggleMenuButton.call(this, e3, i3), j(t3), Pe.checkMenu.call(this), i3 && (this.options.speed.forEach((i4) => {
            Pe.createMenuItem.call(this, { value: i4, list: t3, type: e3, title: Pe.getLabel.call(this, "speed", i4) });
          }), Pe.updateSetting.call(this, e3, t3));
        }, checkMenu() {
          const { buttons: e3 } = this.elements.settings, t3 = !S.empty(e3) && Object.values(e3).some((e4) => !e4.hidden);
          H(this.elements.settings.menu, !t3);
        }, focusFirstMenuItem(e3, t3 = false) {
          if (this.elements.settings.popup.hidden)
            return;
          let i3 = e3;
          S.element(i3) || (i3 = Object.values(this.elements.settings.panels).find((e4) => !e4.hidden));
          const s3 = i3.querySelector('[role^="menuitem"]');
          W.call(this, s3, t3);
        }, toggleMenu(e3) {
          const { popup: t3 } = this.elements.settings, i3 = this.elements.buttons.settings;
          if (!S.element(t3) || !S.element(i3))
            return;
          const { hidden: s3 } = t3;
          let n3 = s3;
          if (S.boolean(e3))
            n3 = e3;
          else if (S.keyboardEvent(e3) && "Escape" === e3.key)
            n3 = false;
          else if (S.event(e3)) {
            const s4 = S.function(e3.composedPath) ? e3.composedPath()[0] : e3.target, a3 = t3.contains(s4);
            if (a3 || !a3 && e3.target !== i3 && n3)
              return;
          }
          i3.setAttribute("aria-expanded", n3), H(t3, !n3), R(this.elements.container, this.config.classNames.menu.open, n3), n3 && S.keyboardEvent(e3) ? Pe.focusFirstMenuItem.call(this, null, true) : n3 || s3 || W.call(this, i3, S.keyboardEvent(e3));
        }, getMenuSize(e3) {
          const t3 = e3.cloneNode(true);
          t3.style.position = "absolute", t3.style.opacity = 0, t3.removeAttribute("hidden"), e3.parentNode.appendChild(t3);
          const i3 = t3.scrollWidth, s3 = t3.scrollHeight;
          return O(t3), { width: i3, height: s3 };
        }, showMenuPanel(e3 = "", t3 = false) {
          const i3 = this.elements.container.querySelector("#plyr-settings-".concat(this.id, "-").concat(e3));
          if (!S.element(i3))
            return;
          const s3 = i3.parentNode, n3 = Array.from(s3.children).find((e4) => !e4.hidden);
          if (K.transitions && !K.reducedMotion) {
            s3.style.width = "".concat(n3.scrollWidth, "px"), s3.style.height = "".concat(n3.scrollHeight, "px");
            const e4 = Pe.getMenuSize.call(this, i3), t4 = (e5) => {
              e5.target === s3 && ["width", "height"].includes(e5.propertyName) && (s3.style.width = "", s3.style.height = "", J.call(this, s3, E, t4));
            };
            X.call(this, s3, E, t4), s3.style.width = "".concat(e4.width, "px"), s3.style.height = "".concat(e4.height, "px");
          }
          H(n3, true), H(i3, false), Pe.focusFirstMenuItem.call(this, i3, t3);
        }, setDownloadUrl() {
          const e3 = this.elements.buttons.download;
          S.element(e3) && e3.setAttribute("href", this.download);
        }, create(e3) {
          const { bindMenuItemShortcuts: t3, createButton: i3, createProgress: s3, createRange: n3, createTime: a3, setQualityMenu: l3, setSpeedMenu: r3, showMenuPanel: o3 } = Pe;
          this.elements.controls = null, S.array(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(i3.call(this, "play-large"));
          const c3 = $("div", D(this.config.selectors.controls.wrapper));
          this.elements.controls = c3;
          const u3 = { class: "plyr__controls__item" };
          return se(S.array(this.config.controls) ? this.config.controls : []).forEach((l4) => {
            if ("restart" === l4 && c3.appendChild(i3.call(this, "restart", u3)), "rewind" === l4 && c3.appendChild(i3.call(this, "rewind", u3)), "play" === l4 && c3.appendChild(i3.call(this, "play", u3)), "fast-forward" === l4 && c3.appendChild(i3.call(this, "fast-forward", u3)), "progress" === l4) {
              const t4 = $("div", { class: "".concat(u3.class, " plyr__progress__container") }), i4 = $("div", D(this.config.selectors.progress));
              if (i4.appendChild(n3.call(this, "seek", { id: "plyr-seek-".concat(e3.id) })), i4.appendChild(s3.call(this, "buffer")), this.config.tooltips.seek) {
                const e4 = $("span", { class: this.config.classNames.tooltip }, "00:00");
                i4.appendChild(e4), this.elements.display.seekTooltip = e4;
              }
              this.elements.progress = i4, t4.appendChild(this.elements.progress), c3.appendChild(t4);
            }
            if ("current-time" === l4 && c3.appendChild(a3.call(this, "currentTime", u3)), "duration" === l4 && c3.appendChild(a3.call(this, "duration", u3)), "mute" === l4 || "volume" === l4) {
              let { volume: t4 } = this.elements;
              if (S.element(t4) && c3.contains(t4) || (t4 = $("div", x({}, u3, { class: "".concat(u3.class, " plyr__volume").trim() })), this.elements.volume = t4, c3.appendChild(t4)), "mute" === l4 && t4.appendChild(i3.call(this, "mute")), "volume" === l4 && !M.isIos && !M.isIPadOS) {
                const i4 = { max: 1, step: 0.05, value: this.config.volume };
                t4.appendChild(n3.call(this, "volume", x(i4, { id: "plyr-volume-".concat(e3.id) })));
              }
            }
            if ("captions" === l4 && c3.appendChild(i3.call(this, "captions", u3)), "settings" === l4 && !S.empty(this.config.settings)) {
              const s4 = $("div", x({}, u3, { class: "".concat(u3.class, " plyr__menu").trim(), hidden: "" }));
              s4.appendChild(i3.call(this, "settings", { "aria-haspopup": true, "aria-controls": "plyr-settings-".concat(e3.id), "aria-expanded": false }));
              const n4 = $("div", { class: "plyr__menu__container", id: "plyr-settings-".concat(e3.id), hidden: "" }), a4 = $("div"), l5 = $("div", { id: "plyr-settings-".concat(e3.id, "-home") }), r4 = $("div", { role: "menu" });
              l5.appendChild(r4), a4.appendChild(l5), this.elements.settings.panels.home = l5, this.config.settings.forEach((i4) => {
                const s5 = $("button", x(D(this.config.selectors.buttons.settings), { type: "button", class: "".concat(this.config.classNames.control, " ").concat(this.config.classNames.control, "--forward"), role: "menuitem", "aria-haspopup": true, hidden: "" }));
                t3.call(this, s5, i4), X.call(this, s5, "click", () => {
                  o3.call(this, i4, false);
                });
                const n5 = $("span", null, ve.get(i4, this.config)), l6 = $("span", { class: this.config.classNames.menu.value });
                l6.innerHTML = e3[i4], n5.appendChild(l6), s5.appendChild(n5), r4.appendChild(s5);
                const c4 = $("div", { id: "plyr-settings-".concat(e3.id, "-").concat(i4), hidden: "" }), u4 = $("button", { type: "button", class: "".concat(this.config.classNames.control, " ").concat(this.config.classNames.control, "--back") });
                u4.appendChild($("span", { "aria-hidden": true }, ve.get(i4, this.config))), u4.appendChild($("span", { class: this.config.classNames.hidden }, ve.get("menuBack", this.config))), X.call(this, c4, "keydown", (e4) => {
                  "ArrowLeft" === e4.key && (e4.preventDefault(), e4.stopPropagation(), o3.call(this, "home", true));
                }, false), X.call(this, u4, "click", () => {
                  o3.call(this, "home", false);
                }), c4.appendChild(u4), c4.appendChild($("div", { role: "menu" })), a4.appendChild(c4), this.elements.settings.buttons[i4] = s5, this.elements.settings.panels[i4] = c4;
              }), n4.appendChild(a4), s4.appendChild(n4), c3.appendChild(s4), this.elements.settings.popup = n4, this.elements.settings.menu = s4;
            }
            if ("pip" === l4 && K.pip && c3.appendChild(i3.call(this, "pip", u3)), "airplay" === l4 && K.airplay && c3.appendChild(i3.call(this, "airplay", u3)), "download" === l4) {
              const e4 = x({}, u3, { element: "a", href: this.download, target: "_blank" });
              this.isHTML5 && (e4.download = "");
              const { download: t4 } = this.config.urls;
              !S.url(t4) && this.isEmbed && x(e4, { icon: "logo-".concat(this.provider), label: this.provider }), c3.appendChild(i3.call(this, "download", e4));
            }
            "fullscreen" === l4 && c3.appendChild(i3.call(this, "fullscreen", u3));
          }), this.isHTML5 && l3.call(this, de.getQualityOptions.call(this)), r3.call(this), c3;
        }, inject() {
          if (this.config.loadSprite) {
            const e4 = Pe.getIconUrl.call(this);
            e4.cors && ke(e4.url, "sprite-plyr");
          }
          this.id = Math.floor(1e4 * Math.random());
          let e3 = null;
          this.elements.controls = null;
          const t3 = { id: this.id, seektime: this.config.seekTime, title: this.config.title };
          let i3 = true;
          S.function(this.config.controls) && (this.config.controls = this.config.controls.call(this, t3)), this.config.controls || (this.config.controls = []), S.element(this.config.controls) || S.string(this.config.controls) ? e3 = this.config.controls : (e3 = Pe.create.call(this, { id: this.id, seektime: this.config.seekTime, speed: this.speed, quality: this.quality, captions: xe.getLabel.call(this) }), i3 = false);
          let s3;
          i3 && S.string(this.config.controls) && (e3 = ((e4) => {
            let i4 = e4;
            return Object.entries(t3).forEach(([e5, t4]) => {
              i4 = pe(i4, "{".concat(e5, "}"), t4);
            }), i4;
          })(e3)), S.string(this.config.selectors.controls.container) && (s3 = document.querySelector(this.config.selectors.controls.container)), S.element(s3) || (s3 = this.elements.container);
          if (s3[S.element(e3) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", e3), S.element(this.elements.controls) || Pe.findElements.call(this), !S.empty(this.elements.buttons)) {
            const e4 = (e5) => {
              const t4 = this.config.classNames.controlPressed;
              e5.setAttribute("aria-pressed", "false"), Object.defineProperty(e5, "pressed", { configurable: true, enumerable: true, get: () => F(e5, t4), set(i4 = false) {
                R(e5, t4, i4), e5.setAttribute("aria-pressed", i4 ? "true" : "false");
              } });
            };
            Object.values(this.elements.buttons).filter(Boolean).forEach((t4) => {
              S.array(t4) || S.nodeList(t4) ? Array.from(t4).filter(Boolean).forEach(e4) : e4(t4);
            });
          }
          if (M.isEdge && P(s3), this.config.tooltips.controls) {
            const { classNames: e4, selectors: t4 } = this.config, i4 = "".concat(t4.controls.wrapper, " ").concat(t4.labels, " .").concat(e4.hidden), s4 = U.call(this, i4);
            Array.from(s4).forEach((e5) => {
              R(e5, this.config.classNames.hidden, false), R(e5, this.config.classNames.tooltip, true);
            });
          }
        }, setMediaMetadata() {
          try {
            "mediaSession" in navigator && (navigator.mediaSession.metadata = new window.MediaMetadata({ title: this.config.mediaMetadata.title, artist: this.config.mediaMetadata.artist, album: this.config.mediaMetadata.album, artwork: this.config.mediaMetadata.artwork }));
          } catch (e3) {
          }
        }, setMarkers() {
          var e3, t3;
          if (!this.duration || this.elements.markers)
            return;
          const i3 = null === (e3 = this.config.markers) || void 0 === e3 || null === (t3 = e3.points) || void 0 === t3 ? void 0 : t3.filter(({ time: e4 }) => e4 > 0 && e4 < this.duration);
          if (null == i3 || !i3.length)
            return;
          const s3 = document.createDocumentFragment(), n3 = document.createDocumentFragment();
          let a3 = null;
          const l3 = "".concat(this.config.classNames.tooltip, "--visible"), r3 = (e4) => R(a3, l3, e4);
          i3.forEach((e4) => {
            const t4 = $("span", { class: this.config.classNames.marker }, ""), i4 = e4.time / this.duration * 100 + "%";
            a3 && (t4.addEventListener("mouseenter", () => {
              e4.label || (a3.style.left = i4, a3.innerHTML = e4.label, r3(true));
            }), t4.addEventListener("mouseleave", () => {
              r3(false);
            })), t4.addEventListener("click", () => {
              this.currentTime = e4.time;
            }), t4.style.left = i4, n3.appendChild(t4);
          }), s3.appendChild(n3), this.config.tooltips.seek || (a3 = $("span", { class: this.config.classNames.tooltip }, ""), s3.appendChild(a3)), this.elements.markers = { points: n3, tip: a3 }, this.elements.progress.appendChild(s3);
        } };
        function Me(e3, t3 = true) {
          let i3 = e3;
          if (t3) {
            const e4 = document.createElement("a");
            e4.href = i3, i3 = e4.href;
          }
          try {
            return new URL(i3);
          } catch (e4) {
            return null;
          }
        }
        function Ne(e3) {
          const t3 = new URLSearchParams();
          return S.object(e3) && Object.entries(e3).forEach(([e4, i3]) => {
            t3.set(e4, i3);
          }), t3;
        }
        const xe = { setup() {
          if (!this.supported.ui)
            return;
          if (!this.isVideo || this.isYouTube || this.isHTML5 && !K.textTracks)
            return void (S.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Pe.setCaptionsMenu.call(this));
          var e3, t3;
          if (S.element(this.elements.captions) || (this.elements.captions = $("div", D(this.config.selectors.captions)), this.elements.captions.setAttribute("dir", "auto"), e3 = this.elements.captions, t3 = this.elements.wrapper, S.element(e3) && S.element(t3) && t3.parentNode.insertBefore(e3, t3.nextSibling)), M.isIE && window.URL) {
            const e4 = this.media.querySelectorAll("track");
            Array.from(e4).forEach((e5) => {
              const t4 = e5.getAttribute("src"), i4 = Me(t4);
              null !== i4 && i4.hostname !== window.location.href.hostname && ["http:", "https:"].includes(i4.protocol) && Te(t4, "blob").then((t5) => {
                e5.setAttribute("src", window.URL.createObjectURL(t5));
              }).catch(() => {
                O(e5);
              });
            });
          }
          const i3 = se((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map((e4) => e4.split("-")[0]));
          let s3 = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
          "auto" === s3 && ([s3] = i3);
          let n3 = this.storage.get("captions");
          if (S.boolean(n3) || ({ active: n3 } = this.config.captions), Object.assign(this.captions, { toggled: false, active: n3, language: s3, languages: i3 }), this.isHTML5) {
            const e4 = this.config.captions.update ? "addtrack removetrack" : "removetrack";
            X.call(this, this.media.textTracks, e4, xe.update.bind(this));
          }
          setTimeout(xe.update.bind(this), 0);
        }, update() {
          const e3 = xe.getTracks.call(this, true), { active: t3, language: i3, meta: s3, currentTrackNode: n3 } = this.captions, a3 = Boolean(e3.find((e4) => e4.language === i3));
          this.isHTML5 && this.isVideo && e3.filter((e4) => !s3.get(e4)).forEach((e4) => {
            this.debug.log("Track added", e4), s3.set(e4, { default: "showing" === e4.mode }), "showing" === e4.mode && (e4.mode = "hidden"), X.call(this, e4, "cuechange", () => xe.updateCues.call(this));
          }), (a3 && this.language !== i3 || !e3.includes(n3)) && (xe.setLanguage.call(this, i3), xe.toggle.call(this, t3 && a3)), this.elements && R(this.elements.container, this.config.classNames.captions.enabled, !S.empty(e3)), S.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && Pe.setCaptionsMenu.call(this);
        }, toggle(e3, t3 = true) {
          if (!this.supported.ui)
            return;
          const { toggled: i3 } = this.captions, s3 = this.config.classNames.captions.active, n3 = S.nullOrUndefined(e3) ? !i3 : e3;
          if (n3 !== i3) {
            if (t3 || (this.captions.active = n3, this.storage.set({ captions: n3 })), !this.language && n3 && !t3) {
              const e4 = xe.getTracks.call(this), t4 = xe.findTrack.call(this, [this.captions.language, ...this.captions.languages], true);
              return this.captions.language = t4.language, void xe.set.call(this, e4.indexOf(t4));
            }
            this.elements.buttons.captions && (this.elements.buttons.captions.pressed = n3), R(this.elements.container, s3, n3), this.captions.toggled = n3, Pe.updateSetting.call(this, "captions"), Z.call(this, this.media, n3 ? "captionsenabled" : "captionsdisabled");
          }
          setTimeout(() => {
            n3 && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden");
          });
        }, set(e3, t3 = true) {
          const i3 = xe.getTracks.call(this);
          if (-1 !== e3)
            if (S.number(e3))
              if (e3 in i3) {
                if (this.captions.currentTrack !== e3) {
                  this.captions.currentTrack = e3;
                  const s3 = i3[e3], { language: n3 } = s3 || {};
                  this.captions.currentTrackNode = s3, Pe.updateSetting.call(this, "captions"), t3 || (this.captions.language = n3, this.storage.set({ language: n3 })), this.isVimeo && this.embed.enableTextTrack(n3), Z.call(this, this.media, "languagechange");
                }
                xe.toggle.call(this, true, t3), this.isHTML5 && this.isVideo && xe.updateCues.call(this);
              } else
                this.debug.warn("Track not found", e3);
            else
              this.debug.warn("Invalid caption argument", e3);
          else
            xe.toggle.call(this, false, t3);
        }, setLanguage(e3, t3 = true) {
          if (!S.string(e3))
            return void this.debug.warn("Invalid language argument", e3);
          const i3 = e3.toLowerCase();
          this.captions.language = i3;
          const s3 = xe.getTracks.call(this), n3 = xe.findTrack.call(this, [i3]);
          xe.set.call(this, s3.indexOf(n3), t3);
        }, getTracks(e3 = false) {
          return Array.from((this.media || {}).textTracks || []).filter((t3) => !this.isHTML5 || e3 || this.captions.meta.has(t3)).filter((e4) => ["captions", "subtitles"].includes(e4.kind));
        }, findTrack(e3, t3 = false) {
          const i3 = xe.getTracks.call(this), s3 = (e4) => Number((this.captions.meta.get(e4) || {}).default), n3 = Array.from(i3).sort((e4, t4) => s3(t4) - s3(e4));
          let a3;
          return e3.every((e4) => (a3 = n3.find((t4) => t4.language === e4), !a3)), a3 || (t3 ? n3[0] : void 0);
        }, getCurrentTrack() {
          return xe.getTracks.call(this)[this.currentTrack];
        }, getLabel(e3) {
          let t3 = e3;
          return !S.track(t3) && K.textTracks && this.captions.toggled && (t3 = xe.getCurrentTrack.call(this)), S.track(t3) ? S.empty(t3.label) ? S.empty(t3.language) ? ve.get("enabled", this.config) : e3.language.toUpperCase() : t3.label : ve.get("disabled", this.config);
        }, updateCues(e3) {
          if (!this.supported.ui)
            return;
          if (!S.element(this.elements.captions))
            return void this.debug.warn("No captions element to render to");
          if (!S.nullOrUndefined(e3) && !Array.isArray(e3))
            return void this.debug.warn("updateCues: Invalid input", e3);
          let t3 = e3;
          if (!t3) {
            const e4 = xe.getCurrentTrack.call(this);
            t3 = Array.from((e4 || {}).activeCues || []).map((e5) => e5.getCueAsHTML()).map(ye);
          }
          const i3 = t3.map((e4) => e4.trim()).join("\n");
          if (i3 !== this.elements.captions.innerHTML) {
            j(this.elements.captions);
            const e4 = $("span", D(this.config.selectors.caption));
            e4.innerHTML = i3, this.elements.captions.appendChild(e4), Z.call(this, this.media, "cuechange");
          }
        } }, Le = { enabled: true, title: "", debug: false, autoplay: false, autopause: true, playsinline: true, seekTime: 10, volume: 1, muted: false, duration: null, displayDuration: true, invertTime: true, toggleInvert: true, ratio: null, clickToPlay: true, hideControls: true, resetOnEnd: false, disableContextMenu: true, loadSprite: true, iconPrefix: "plyr", iconUrl: "https://cdn.plyr.io/3.7.8/plyr.svg", blankVideo: "https://cdn.plyr.io/static/blank.mp4", quality: { default: 576, options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240], forced: false, onChange: null }, loop: { active: false }, speed: { selected: 1, options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4] }, keyboard: { focused: true, global: false }, tooltips: { controls: false, seek: true }, captions: { active: false, language: "auto", update: false }, fullscreen: { enabled: true, fallback: true, iosNative: false }, storage: { enabled: true, key: "plyr" }, controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"], settings: ["captions", "quality", "speed"], i18n: { restart: "Restart", rewind: "Rewind {seektime}s", play: "Play", pause: "Pause", fastForward: "Forward {seektime}s", seek: "Seek", seekLabel: "{currentTime} of {duration}", played: "Played", buffered: "Buffered", currentTime: "Current time", duration: "Duration", volume: "Volume", mute: "Mute", unmute: "Unmute", enableCaptions: "Enable captions", disableCaptions: "Disable captions", download: "Download", enterFullscreen: "Enter fullscreen", exitFullscreen: "Exit fullscreen", frameTitle: "Player for {title}", captions: "Captions", settings: "Settings", pip: "PIP", menuBack: "Go back to previous menu", speed: "Speed", normal: "Normal", quality: "Quality", loop: "Loop", start: "Start", end: "End", all: "All", reset: "Reset", disabled: "Disabled", enabled: "Enabled", advertisement: "Ad", qualityBadge: { 2160: "4K", 1440: "HD", 1080: "HD", 720: "HD", 576: "SD", 480: "SD" } }, urls: { download: null, vimeo: { sdk: "https://player.vimeo.com/api/player.js", iframe: "https://player.vimeo.com/video/{0}?{1}", api: "https://vimeo.com/api/oembed.json?url={0}" }, youtube: { sdk: "https://www.youtube.com/iframe_api", api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}" }, googleIMA: { sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js" } }, listeners: { seek: null, play: null, pause: null, restart: null, rewind: null, fastForward: null, mute: null, volume: null, captions: null, download: null, fullscreen: null, pip: null, airplay: null, speed: null, quality: null, loop: null, language: null }, events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "download", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"], selectors: { editable: "input, textarea, select, [contenteditable]", container: ".plyr", controls: { container: null, wrapper: ".plyr__controls" }, labels: "[data-plyr]", buttons: { play: '[data-plyr="play"]', pause: '[data-plyr="pause"]', restart: '[data-plyr="restart"]', rewind: '[data-plyr="rewind"]', fastForward: '[data-plyr="fast-forward"]', mute: '[data-plyr="mute"]', captions: '[data-plyr="captions"]', download: '[data-plyr="download"]', fullscreen: '[data-plyr="fullscreen"]', pip: '[data-plyr="pip"]', airplay: '[data-plyr="airplay"]', settings: '[data-plyr="settings"]', loop: '[data-plyr="loop"]' }, inputs: { seek: '[data-plyr="seek"]', volume: '[data-plyr="volume"]', speed: '[data-plyr="speed"]', language: '[data-plyr="language"]', quality: '[data-plyr="quality"]' }, display: { currentTime: ".plyr__time--current", duration: ".plyr__time--duration", buffer: ".plyr__progress__buffer", loop: ".plyr__progress__loop", volume: ".plyr__volume--display" }, progress: ".plyr__progress", captions: ".plyr__captions", caption: ".plyr__caption" }, classNames: { type: "plyr--{0}", provider: "plyr--{0}", video: "plyr__video-wrapper", embed: "plyr__video-embed", videoFixedRatio: "plyr__video-wrapper--fixed-ratio", embedContainer: "plyr__video-embed__container", poster: "plyr__poster", posterEnabled: "plyr__poster-enabled", ads: "plyr__ads", control: "plyr__control", controlPressed: "plyr__control--pressed", playing: "plyr--playing", paused: "plyr--paused", stopped: "plyr--stopped", loading: "plyr--loading", hover: "plyr--hover", tooltip: "plyr__tooltip", cues: "plyr__cues", marker: "plyr__progress__marker", hidden: "plyr__sr-only", hideControls: "plyr--hide-controls", isTouch: "plyr--is-touch", uiSupported: "plyr--full-ui", noTransition: "plyr--no-transition", display: { time: "plyr__time" }, menu: { value: "plyr__menu__value", badge: "plyr__badge", open: "plyr--menu-open" }, captions: { enabled: "plyr--captions-enabled", active: "plyr--captions-active" }, fullscreen: { enabled: "plyr--fullscreen-enabled", fallback: "plyr--fullscreen-fallback" }, pip: { supported: "plyr--pip-supported", active: "plyr--pip-active" }, airplay: { supported: "plyr--airplay-supported", active: "plyr--airplay-active" }, previewThumbnails: { thumbContainer: "plyr__preview-thumb", thumbContainerShown: "plyr__preview-thumb--is-shown", imageContainer: "plyr__preview-thumb__image-container", timeContainer: "plyr__preview-thumb__time-container", scrubbingContainer: "plyr__preview-scrubbing", scrubbingContainerShown: "plyr__preview-scrubbing--is-shown" } }, attributes: { embed: { provider: "data-plyr-provider", id: "data-plyr-embed-id", hash: "data-plyr-embed-hash" } }, ads: { enabled: false, publisherId: "", tagUrl: "" }, previewThumbnails: { enabled: false, src: "" }, vimeo: { byline: false, portrait: false, title: false, speed: true, transparent: false, customControls: true, referrerPolicy: null, premium: false }, youtube: { rel: 0, showinfo: 0, iv_load_policy: 3, modestbranding: 1, customControls: true, noCookie: false }, mediaMetadata: { title: "", artist: "", album: "", artwork: [] }, markers: { enabled: false, points: [] } }, Ie = "picture-in-picture", $e = "inline", _e = { html5: "html5", youtube: "youtube", vimeo: "vimeo" }, Oe = "audio", je = "video";
        const qe = () => {
        };
        class De {
          constructor(e3 = false) {
            this.enabled = window.console && e3, this.enabled && this.log("Debugging enabled");
          }
          get log() {
            return this.enabled ? Function.prototype.bind.call(console.log, console) : qe;
          }
          get warn() {
            return this.enabled ? Function.prototype.bind.call(console.warn, console) : qe;
          }
          get error() {
            return this.enabled ? Function.prototype.bind.call(console.error, console) : qe;
          }
        }
        class He {
          constructor(t3) {
            e2(this, "onChange", () => {
              if (!this.supported)
                return;
              const e3 = this.player.elements.buttons.fullscreen;
              S.element(e3) && (e3.pressed = this.active);
              const t4 = this.target === this.player.media ? this.target : this.player.elements.container;
              Z.call(this.player, t4, this.active ? "enterfullscreen" : "exitfullscreen", true);
            }), e2(this, "toggleFallback", (e3 = false) => {
              var _a, _b;
              if (e3 ? this.scrollPosition = { x: (_a = window.scrollX) != null ? _a : 0, y: (_b = window.scrollY) != null ? _b : 0 } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = e3 ? "hidden" : "", R(this.target, this.player.config.classNames.fullscreen.fallback, e3), M.isIos) {
                let t4 = document.head.querySelector('meta[name="viewport"]');
                const i3 = "viewport-fit=cover";
                t4 || (t4 = document.createElement("meta"), t4.setAttribute("name", "viewport"));
                const s3 = S.string(t4.content) && t4.content.includes(i3);
                e3 ? (this.cleanupViewport = !s3, s3 || (t4.content += ",".concat(i3))) : this.cleanupViewport && (t4.content = t4.content.split(",").filter((e4) => e4.trim() !== i3).join(","));
              }
              this.onChange();
            }), e2(this, "trapFocus", (e3) => {
              if (M.isIos || M.isIPadOS || !this.active || "Tab" !== e3.key)
                return;
              const t4 = document.activeElement, i3 = U.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"), [s3] = i3, n3 = i3[i3.length - 1];
              t4 !== n3 || e3.shiftKey ? t4 === s3 && e3.shiftKey && (n3.focus(), e3.preventDefault()) : (s3.focus(), e3.preventDefault());
            }), e2(this, "update", () => {
              if (this.supported) {
                let e3;
                e3 = this.forceFallback ? "Fallback (forced)" : He.nativeSupported ? "Native" : "Fallback", this.player.debug.log("".concat(e3, " fullscreen enabled"));
              } else
                this.player.debug.log("Fullscreen not supported and fallback disabled");
              R(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.supported);
            }), e2(this, "enter", () => {
              this.supported && (M.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !He.nativeSupported || this.forceFallback ? this.toggleFallback(true) : this.prefix ? S.empty(this.prefix) || this.target["".concat(this.prefix, "Request").concat(this.property)]() : this.target.requestFullscreen({ navigationUI: "hide" }));
            }), e2(this, "exit", () => {
              if (this.supported)
                if (M.isIos && this.player.config.fullscreen.iosNative)
                  this.player.isVimeo ? this.player.embed.exitFullscreen() : this.target.webkitEnterFullscreen(), ie(this.player.play());
                else if (!He.nativeSupported || this.forceFallback)
                  this.toggleFallback(false);
                else if (this.prefix) {
                  if (!S.empty(this.prefix)) {
                    const e3 = "moz" === this.prefix ? "Cancel" : "Exit";
                    document["".concat(this.prefix).concat(e3).concat(this.property)]();
                  }
                } else
                  (document.cancelFullScreen || document.exitFullscreen).call(document);
            }), e2(this, "toggle", () => {
              this.active ? this.exit() : this.enter();
            }), this.player = t3, this.prefix = He.prefix, this.property = He.property, this.scrollPosition = { x: 0, y: 0 }, this.forceFallback = "force" === t3.config.fullscreen.fallback, this.player.elements.fullscreen = t3.config.fullscreen.container && function(e3, t4) {
              const { prototype: i3 } = Element;
              return (i3.closest || function() {
                let e4 = this;
                do {
                  if (V.matches(e4, t4))
                    return e4;
                  e4 = e4.parentElement || e4.parentNode;
                } while (null !== e4 && 1 === e4.nodeType);
                return null;
              }).call(e3, t4);
            }(this.player.elements.container, t3.config.fullscreen.container), X.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : "".concat(this.prefix, "fullscreenchange"), () => {
              this.onChange();
            }), X.call(this.player, this.player.elements.container, "dblclick", (e3) => {
              S.element(this.player.elements.controls) && this.player.elements.controls.contains(e3.target) || this.player.listeners.proxy(e3, this.toggle, "fullscreen");
            }), X.call(this, this.player.elements.container, "keydown", (e3) => this.trapFocus(e3)), this.update();
          }
          static get nativeSupported() {
            return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
          }
          get useNative() {
            return He.nativeSupported && !this.forceFallback;
          }
          static get prefix() {
            if (S.function(document.exitFullscreen))
              return "";
            let e3 = "";
            return ["webkit", "moz", "ms"].some((t3) => !(!S.function(document["".concat(t3, "ExitFullscreen")]) && !S.function(document["".concat(t3, "CancelFullScreen")])) && (e3 = t3, true)), e3;
          }
          static get property() {
            return "moz" === this.prefix ? "FullScreen" : "Fullscreen";
          }
          get supported() {
            return [this.player.config.fullscreen.enabled, this.player.isVideo, He.nativeSupported || this.player.config.fullscreen.fallback, !this.player.isYouTube || He.nativeSupported || !M.isIos || this.player.config.playsinline && !this.player.config.fullscreen.iosNative].every(Boolean);
          }
          get active() {
            if (!this.supported)
              return false;
            if (!He.nativeSupported || this.forceFallback)
              return F(this.target, this.player.config.classNames.fullscreen.fallback);
            const e3 = this.prefix ? this.target.getRootNode()["".concat(this.prefix).concat(this.property, "Element")] : this.target.getRootNode().fullscreenElement;
            return e3 && e3.shadowRoot ? e3 === this.target.getRootNode().host : e3 === this.target;
          }
          get target() {
            var _a;
            return M.isIos && this.player.config.fullscreen.iosNative ? this.player.media : (_a = this.player.elements.fullscreen) != null ? _a : this.player.elements.container;
          }
        }
        function Re(e3, t3 = 1) {
          return new Promise((i3, s3) => {
            const n3 = new Image(), a3 = () => {
              delete n3.onload, delete n3.onerror, (n3.naturalWidth >= t3 ? i3 : s3)(n3);
            };
            Object.assign(n3, { onload: a3, onerror: a3, src: e3 });
          });
        }
        const Fe = { addStyleHook() {
          R(this.elements.container, this.config.selectors.container.replace(".", ""), true), R(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);
        }, toggleNativeControls(e3 = false) {
          e3 && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls");
        }, build() {
          if (this.listeners.media(), !this.supported.ui)
            return this.debug.warn("Basic support only for ".concat(this.provider, " ").concat(this.type)), void Fe.toggleNativeControls.call(this, true);
          S.element(this.elements.controls) || (Pe.inject.call(this), this.listeners.controls()), Fe.toggleNativeControls.call(this), this.isHTML5 && xe.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, Pe.updateVolume.call(this), Pe.timeUpdate.call(this), Pe.durationUpdate.call(this), Fe.checkPlaying.call(this), R(this.elements.container, this.config.classNames.pip.supported, K.pip && this.isHTML5 && this.isVideo), R(this.elements.container, this.config.classNames.airplay.supported, K.airplay && this.isHTML5), R(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = true, setTimeout(() => {
            Z.call(this, this.media, "ready");
          }, 0), Fe.setTitle.call(this), this.poster && Fe.setPoster.call(this, this.poster, false).catch(() => {
          }), this.config.duration && Pe.durationUpdate.call(this), this.config.mediaMetadata && Pe.setMediaMetadata.call(this);
        }, setTitle() {
          let e3 = ve.get("play", this.config);
          if (S.string(this.config.title) && !S.empty(this.config.title) && (e3 += ", ".concat(this.config.title)), Array.from(this.elements.buttons.play || []).forEach((t3) => {
            t3.setAttribute("aria-label", e3);
          }), this.isEmbed) {
            const e4 = B.call(this, "iframe");
            if (!S.element(e4))
              return;
            const t3 = S.empty(this.config.title) ? "video" : this.config.title, i3 = ve.get("frameTitle", this.config);
            e4.setAttribute("title", i3.replace("{title}", t3));
          }
        }, togglePoster(e3) {
          R(this.elements.container, this.config.classNames.posterEnabled, e3);
        }, setPoster(e3, t3 = true) {
          return t3 && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e3), this.elements.poster.removeAttribute("hidden"), te.call(this).then(() => Re(e3)).catch((t4) => {
            throw e3 === this.poster && Fe.togglePoster.call(this, false), t4;
          }).then(() => {
            if (e3 !== this.poster)
              throw new Error("setPoster cancelled by later call to setPoster");
          }).then(() => (Object.assign(this.elements.poster.style, { backgroundImage: "url('".concat(e3, "')"), backgroundSize: "" }), Fe.togglePoster.call(this, true), e3)));
        }, checkPlaying(e3) {
          R(this.elements.container, this.config.classNames.playing, this.playing), R(this.elements.container, this.config.classNames.paused, this.paused), R(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach((e4) => {
            Object.assign(e4, { pressed: this.playing }), e4.setAttribute("aria-label", ve.get(this.playing ? "pause" : "play", this.config));
          }), S.event(e3) && "timeupdate" === e3.type || Fe.toggleControls.call(this);
        }, checkLoading(e3) {
          this.loading = ["stalled", "waiting"].includes(e3.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(() => {
            R(this.elements.container, this.config.classNames.loading, this.loading), Fe.toggleControls.call(this);
          }, this.loading ? 250 : 0);
        }, toggleControls(e3) {
          const { controls: t3 } = this.elements;
          if (t3 && this.config.hideControls) {
            const i3 = this.touch && this.lastSeekTime + 2e3 > Date.now();
            this.toggleControls(Boolean(e3 || this.loading || this.paused || t3.pressed || t3.hover || i3));
          }
        }, migrateStyles() {
          Object.values(__spreadValues({}, this.media.style)).filter((e3) => !S.empty(e3) && S.string(e3) && e3.startsWith("--plyr")).forEach((e3) => {
            this.elements.container.style.setProperty(e3, this.media.style.getPropertyValue(e3)), this.media.style.removeProperty(e3);
          }), S.empty(this.media.style) && this.media.removeAttribute("style");
        } };
        class Ve {
          constructor(t3) {
            e2(this, "firstTouch", () => {
              const { player: e3 } = this, { elements: t4 } = e3;
              e3.touch = true, R(t4.container, e3.config.classNames.isTouch, true);
            }), e2(this, "global", (e3 = true) => {
              const { player: t4 } = this;
              t4.config.keyboard.global && Q.call(t4, window, "keydown keyup", this.handleKey, e3, false), Q.call(t4, document.body, "click", this.toggleMenu, e3), G.call(t4, document.body, "touchstart", this.firstTouch);
            }), e2(this, "container", () => {
              const { player: e3 } = this, { config: t4, elements: i3, timers: s3 } = e3;
              !t4.keyboard.global && t4.keyboard.focused && X.call(e3, i3.container, "keydown keyup", this.handleKey, false), X.call(e3, i3.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", (t5) => {
                const { controls: n4 } = i3;
                n4 && "enterfullscreen" === t5.type && (n4.pressed = false, n4.hover = false);
                let a4 = 0;
                ["touchstart", "touchmove", "mousemove"].includes(t5.type) && (Fe.toggleControls.call(e3, true), a4 = e3.touch ? 3e3 : 2e3), clearTimeout(s3.controls), s3.controls = setTimeout(() => Fe.toggleControls.call(e3, false), a4);
              });
              const n3 = () => {
                if (!e3.isVimeo || e3.config.vimeo.premium)
                  return;
                const t5 = i3.wrapper, { active: s4 } = e3.fullscreen, [n4, a4] = ce.call(e3), l3 = ae("aspect-ratio: ".concat(n4, " / ").concat(a4));
                if (!s4)
                  return void (l3 ? (t5.style.width = null, t5.style.height = null) : (t5.style.maxWidth = null, t5.style.margin = null));
                const [r3, o3] = [Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)], c3 = r3 / o3 > n4 / a4;
                l3 ? (t5.style.width = c3 ? "auto" : "100%", t5.style.height = c3 ? "100%" : "auto") : (t5.style.maxWidth = c3 ? o3 / a4 * n4 + "px" : null, t5.style.margin = c3 ? "0 auto" : null);
              }, a3 = () => {
                clearTimeout(s3.resized), s3.resized = setTimeout(n3, 50);
              };
              X.call(e3, i3.container, "enterfullscreen exitfullscreen", (t5) => {
                const { target: s4 } = e3.fullscreen;
                if (s4 !== i3.container)
                  return;
                if (!e3.isEmbed && S.empty(e3.config.ratio))
                  return;
                n3();
                ("enterfullscreen" === t5.type ? X : J).call(e3, window, "resize", a3);
              });
            }), e2(this, "media", () => {
              const { player: e3 } = this, { elements: t4 } = e3;
              if (X.call(e3, e3.media, "timeupdate seeking seeked", (t5) => Pe.timeUpdate.call(e3, t5)), X.call(e3, e3.media, "durationchange loadeddata loadedmetadata", (t5) => Pe.durationUpdate.call(e3, t5)), X.call(e3, e3.media, "ended", () => {
                e3.isHTML5 && e3.isVideo && e3.config.resetOnEnd && (e3.restart(), e3.pause());
              }), X.call(e3, e3.media, "progress playing seeking seeked", (t5) => Pe.updateProgress.call(e3, t5)), X.call(e3, e3.media, "volumechange", (t5) => Pe.updateVolume.call(e3, t5)), X.call(e3, e3.media, "playing play pause ended emptied timeupdate", (t5) => Fe.checkPlaying.call(e3, t5)), X.call(e3, e3.media, "waiting canplay seeked playing", (t5) => Fe.checkLoading.call(e3, t5)), e3.supported.ui && e3.config.clickToPlay && !e3.isAudio) {
                const i4 = B.call(e3, ".".concat(e3.config.classNames.video));
                if (!S.element(i4))
                  return;
                X.call(e3, t4.container, "click", (s3) => {
                  ([t4.container, i4].includes(s3.target) || i4.contains(s3.target)) && (e3.touch && e3.config.hideControls || (e3.ended ? (this.proxy(s3, e3.restart, "restart"), this.proxy(s3, () => {
                    ie(e3.play());
                  }, "play")) : this.proxy(s3, () => {
                    ie(e3.togglePlay());
                  }, "play")));
                });
              }
              e3.supported.ui && e3.config.disableContextMenu && X.call(e3, t4.wrapper, "contextmenu", (e4) => {
                e4.preventDefault();
              }, false), X.call(e3, e3.media, "volumechange", () => {
                e3.storage.set({ volume: e3.volume, muted: e3.muted });
              }), X.call(e3, e3.media, "ratechange", () => {
                Pe.updateSetting.call(e3, "speed"), e3.storage.set({ speed: e3.speed });
              }), X.call(e3, e3.media, "qualitychange", (t5) => {
                Pe.updateSetting.call(e3, "quality", null, t5.detail.quality);
              }), X.call(e3, e3.media, "ready qualitychange", () => {
                Pe.setDownloadUrl.call(e3);
              });
              const i3 = e3.config.events.concat(["keyup", "keydown"]).join(" ");
              X.call(e3, e3.media, i3, (i4) => {
                let { detail: s3 = {} } = i4;
                "error" === i4.type && (s3 = e3.media.error), Z.call(e3, t4.container, i4.type, true, s3);
              });
            }), e2(this, "proxy", (e3, t4, i3) => {
              const { player: s3 } = this, n3 = s3.config.listeners[i3];
              let a3 = true;
              S.function(n3) && (a3 = n3.call(s3, e3)), false !== a3 && S.function(t4) && t4.call(s3, e3);
            }), e2(this, "bind", (e3, t4, i3, s3, n3 = true) => {
              const { player: a3 } = this, l3 = a3.config.listeners[s3], r3 = S.function(l3);
              X.call(a3, e3, t4, (e4) => this.proxy(e4, i3, s3), n3 && !r3);
            }), e2(this, "controls", () => {
              const { player: e3 } = this, { elements: t4 } = e3, i3 = M.isIE ? "change" : "input";
              if (t4.buttons.play && Array.from(t4.buttons.play).forEach((t5) => {
                this.bind(t5, "click", () => {
                  ie(e3.togglePlay());
                }, "play");
              }), this.bind(t4.buttons.restart, "click", e3.restart, "restart"), this.bind(t4.buttons.rewind, "click", () => {
                e3.lastSeekTime = Date.now(), e3.rewind();
              }, "rewind"), this.bind(t4.buttons.fastForward, "click", () => {
                e3.lastSeekTime = Date.now(), e3.forward();
              }, "fastForward"), this.bind(t4.buttons.mute, "click", () => {
                e3.muted = !e3.muted;
              }, "mute"), this.bind(t4.buttons.captions, "click", () => e3.toggleCaptions()), this.bind(t4.buttons.download, "click", () => {
                Z.call(e3, e3.media, "download");
              }, "download"), this.bind(t4.buttons.fullscreen, "click", () => {
                e3.fullscreen.toggle();
              }, "fullscreen"), this.bind(t4.buttons.pip, "click", () => {
                e3.pip = "toggle";
              }, "pip"), this.bind(t4.buttons.airplay, "click", e3.airplay, "airplay"), this.bind(t4.buttons.settings, "click", (t5) => {
                t5.stopPropagation(), t5.preventDefault(), Pe.toggleMenu.call(e3, t5);
              }, null, false), this.bind(t4.buttons.settings, "keyup", (t5) => {
                [" ", "Enter"].includes(t5.key) && ("Enter" !== t5.key ? (t5.preventDefault(), t5.stopPropagation(), Pe.toggleMenu.call(e3, t5)) : Pe.focusFirstMenuItem.call(e3, null, true));
              }, null, false), this.bind(t4.settings.menu, "keydown", (t5) => {
                "Escape" === t5.key && Pe.toggleMenu.call(e3, t5);
              }), this.bind(t4.inputs.seek, "mousedown mousemove", (e4) => {
                const i4 = t4.progress.getBoundingClientRect(), s3 = 100 / i4.width * (e4.pageX - i4.left);
                e4.currentTarget.setAttribute("seek-value", s3);
              }), this.bind(t4.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", (t5) => {
                const i4 = t5.currentTarget, s3 = "play-on-seeked";
                if (S.keyboardEvent(t5) && !["ArrowLeft", "ArrowRight"].includes(t5.key))
                  return;
                e3.lastSeekTime = Date.now();
                const n3 = i4.hasAttribute(s3), a3 = ["mouseup", "touchend", "keyup"].includes(t5.type);
                n3 && a3 ? (i4.removeAttribute(s3), ie(e3.play())) : !a3 && e3.playing && (i4.setAttribute(s3, ""), e3.pause());
              }), M.isIos) {
                const t5 = U.call(e3, 'input[type="range"]');
                Array.from(t5).forEach((e4) => this.bind(e4, i3, (e5) => P(e5.target)));
              }
              this.bind(t4.inputs.seek, i3, (t5) => {
                const i4 = t5.currentTarget;
                let s3 = i4.getAttribute("seek-value");
                S.empty(s3) && (s3 = i4.value), i4.removeAttribute("seek-value"), e3.currentTime = s3 / i4.max * e3.duration;
              }, "seek"), this.bind(t4.progress, "mouseenter mouseleave mousemove", (t5) => Pe.updateSeekTooltip.call(e3, t5)), this.bind(t4.progress, "mousemove touchmove", (t5) => {
                const { previewThumbnails: i4 } = e3;
                i4 && i4.loaded && i4.startMove(t5);
              }), this.bind(t4.progress, "mouseleave touchend click", () => {
                const { previewThumbnails: t5 } = e3;
                t5 && t5.loaded && t5.endMove(false, true);
              }), this.bind(t4.progress, "mousedown touchstart", (t5) => {
                const { previewThumbnails: i4 } = e3;
                i4 && i4.loaded && i4.startScrubbing(t5);
              }), this.bind(t4.progress, "mouseup touchend", (t5) => {
                const { previewThumbnails: i4 } = e3;
                i4 && i4.loaded && i4.endScrubbing(t5);
              }), M.isWebKit && Array.from(U.call(e3, 'input[type="range"]')).forEach((t5) => {
                this.bind(t5, "input", (t6) => Pe.updateRangeFill.call(e3, t6.target));
              }), e3.config.toggleInvert && !S.element(t4.display.duration) && this.bind(t4.display.currentTime, "click", () => {
                0 !== e3.currentTime && (e3.config.invertTime = !e3.config.invertTime, Pe.timeUpdate.call(e3));
              }), this.bind(t4.inputs.volume, i3, (t5) => {
                e3.volume = t5.target.value;
              }, "volume"), this.bind(t4.controls, "mouseenter mouseleave", (i4) => {
                t4.controls.hover = !e3.touch && "mouseenter" === i4.type;
              }), t4.fullscreen && Array.from(t4.fullscreen.children).filter((e4) => !e4.contains(t4.container)).forEach((i4) => {
                this.bind(i4, "mouseenter mouseleave", (i5) => {
                  t4.controls && (t4.controls.hover = !e3.touch && "mouseenter" === i5.type);
                });
              }), this.bind(t4.controls, "mousedown mouseup touchstart touchend touchcancel", (e4) => {
                t4.controls.pressed = ["mousedown", "touchstart"].includes(e4.type);
              }), this.bind(t4.controls, "focusin", () => {
                const { config: i4, timers: s3 } = e3;
                R(t4.controls, i4.classNames.noTransition, true), Fe.toggleControls.call(e3, true), setTimeout(() => {
                  R(t4.controls, i4.classNames.noTransition, false);
                }, 0);
                const n3 = this.touch ? 3e3 : 4e3;
                clearTimeout(s3.controls), s3.controls = setTimeout(() => Fe.toggleControls.call(e3, false), n3);
              }), this.bind(t4.inputs.volume, "wheel", (t5) => {
                const i4 = t5.webkitDirectionInvertedFromDevice, [s3, n3] = [t5.deltaX, -t5.deltaY].map((e4) => i4 ? -e4 : e4), a3 = Math.sign(Math.abs(s3) > Math.abs(n3) ? s3 : n3);
                e3.increaseVolume(a3 / 50);
                const { volume: l3 } = e3.media;
                (1 === a3 && l3 < 1 || -1 === a3 && l3 > 0) && t5.preventDefault();
              }, "volume", false);
            }), this.player = t3, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.firstTouch = this.firstTouch.bind(this);
          }
          handleKey(e3) {
            const { player: t3 } = this, { elements: i3 } = t3, { key: s3, type: n3, altKey: a3, ctrlKey: l3, metaKey: r3, shiftKey: o3 } = e3, c3 = "keydown" === n3, u3 = c3 && s3 === this.lastKey;
            if (a3 || l3 || r3 || o3)
              return;
            if (!s3)
              return;
            if (c3) {
              const n4 = document.activeElement;
              if (S.element(n4)) {
                const { editable: s4 } = t3.config.selectors, { seek: a4 } = i3.inputs;
                if (n4 !== a4 && V(n4, s4))
                  return;
                if (" " === e3.key && V(n4, 'button, [role^="menuitem"]'))
                  return;
              }
              switch ([" ", "ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "c", "f", "k", "l", "m"].includes(s3) && (e3.preventDefault(), e3.stopPropagation()), s3) {
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                  u3 || (h3 = parseInt(s3, 10), t3.currentTime = t3.duration / 10 * h3);
                  break;
                case " ":
                case "k":
                  u3 || ie(t3.togglePlay());
                  break;
                case "ArrowUp":
                  t3.increaseVolume(0.1);
                  break;
                case "ArrowDown":
                  t3.decreaseVolume(0.1);
                  break;
                case "m":
                  u3 || (t3.muted = !t3.muted);
                  break;
                case "ArrowRight":
                  t3.forward();
                  break;
                case "ArrowLeft":
                  t3.rewind();
                  break;
                case "f":
                  t3.fullscreen.toggle();
                  break;
                case "c":
                  u3 || t3.toggleCaptions();
                  break;
                case "l":
                  t3.loop = !t3.loop;
              }
              "Escape" === s3 && !t3.fullscreen.usingNative && t3.fullscreen.active && t3.fullscreen.toggle(), this.lastKey = s3;
            } else
              this.lastKey = null;
            var h3;
          }
          toggleMenu(e3) {
            Pe.toggleMenu.call(this.player, e3);
          }
        }
        "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
        var Ue = function(e3, t3) {
          return e3(t3 = { exports: {} }, t3.exports), t3.exports;
        }(function(e3, t3) {
          e3.exports = function() {
            var e4 = function() {
            }, t4 = {}, i3 = {}, s3 = {};
            function n3(e5, t5) {
              e5 = e5.push ? e5 : [e5];
              var n4, a4, l4, r4 = [], o4 = e5.length, c4 = o4;
              for (n4 = function(e6, i4) {
                i4.length && r4.push(e6), --c4 || t5(r4);
              }; o4--; )
                a4 = e5[o4], (l4 = i3[a4]) ? n4(a4, l4) : (s3[a4] = s3[a4] || []).push(n4);
            }
            function a3(e5, t5) {
              if (e5) {
                var n4 = s3[e5];
                if (i3[e5] = t5, n4)
                  for (; n4.length; )
                    n4[0](e5, t5), n4.splice(0, 1);
              }
            }
            function l3(t5, i4) {
              t5.call && (t5 = { success: t5 }), i4.length ? (t5.error || e4)(i4) : (t5.success || e4)(t5);
            }
            function r3(t5, i4, s4, n4) {
              var a4, l4, o4 = document, c4 = s4.async, u3 = (s4.numRetries || 0) + 1, h3 = s4.before || e4, d3 = t5.replace(/[\?|#].*$/, ""), m2 = t5.replace(/^(css|img)!/, "");
              n4 = n4 || 0, /(^css!|\.css$)/.test(d3) ? ((l4 = o4.createElement("link")).rel = "stylesheet", l4.href = m2, (a4 = "hideFocus" in l4) && l4.relList && (a4 = 0, l4.rel = "preload", l4.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(d3) ? (l4 = o4.createElement("img")).src = m2 : ((l4 = o4.createElement("script")).src = t5, l4.async = void 0 === c4 || c4), l4.onload = l4.onerror = l4.onbeforeload = function(e5) {
                var o5 = e5.type[0];
                if (a4)
                  try {
                    l4.sheet.cssText.length || (o5 = "e");
                  } catch (e6) {
                    18 != e6.code && (o5 = "e");
                  }
                if ("e" == o5) {
                  if ((n4 += 1) < u3)
                    return r3(t5, i4, s4, n4);
                } else if ("preload" == l4.rel && "style" == l4.as)
                  return l4.rel = "stylesheet";
                i4(t5, o5, e5.defaultPrevented);
              }, false !== h3(t5, l4) && o4.head.appendChild(l4);
            }
            function o3(e5, t5, i4) {
              var s4, n4, a4 = (e5 = e5.push ? e5 : [e5]).length, l4 = a4, o4 = [];
              for (s4 = function(e6, i5, s5) {
                if ("e" == i5 && o4.push(e6), "b" == i5) {
                  if (!s5)
                    return;
                  o4.push(e6);
                }
                --a4 || t5(o4);
              }, n4 = 0; n4 < l4; n4++)
                r3(e5[n4], s4, i4);
            }
            function c3(e5, i4, s4) {
              var n4, r4;
              if (i4 && i4.trim && (n4 = i4), r4 = (n4 ? s4 : i4) || {}, n4) {
                if (n4 in t4)
                  throw "LoadJS";
                t4[n4] = true;
              }
              function c4(t5, i5) {
                o3(e5, function(e6) {
                  l3(r4, e6), t5 && l3({ success: t5, error: i5 }, e6), a3(n4, e6);
                }, r4);
              }
              if (r4.returnPromise)
                return new Promise(c4);
              c4();
            }
            return c3.ready = function(e5, t5) {
              return n3(e5, function(e6) {
                l3(t5, e6);
              }), c3;
            }, c3.done = function(e5) {
              a3(e5, []);
            }, c3.reset = function() {
              t4 = {}, i3 = {}, s3 = {};
            }, c3.isDefined = function(e5) {
              return e5 in t4;
            }, c3;
          }();
        });
        function Be(e3) {
          return new Promise((t3, i3) => {
            Ue(e3, { success: t3, error: i3 });
          });
        }
        function We(e3) {
          e3 && !this.embed.hasPlayed && (this.embed.hasPlayed = true), this.media.paused === e3 && (this.media.paused = !e3, Z.call(this, this.media, e3 ? "play" : "pause"));
        }
        const ze = { setup() {
          const e3 = this;
          R(e3.elements.wrapper, e3.config.classNames.embed, true), e3.options.speed = e3.config.speed.options, ue.call(e3), S.object(window.Vimeo) ? ze.ready.call(e3) : Be(e3.config.urls.vimeo.sdk).then(() => {
            ze.ready.call(e3);
          }).catch((t3) => {
            e3.debug.warn("Vimeo SDK (player.js) failed to load", t3);
          });
        }, ready() {
          const e3 = this, t3 = e3.config.vimeo, _a = t3, { premium: i3, referrerPolicy: s3 } = _a, n3 = __objRest(_a, ["premium", "referrerPolicy"]);
          let a3 = e3.media.getAttribute("src"), l3 = "";
          S.empty(a3) ? (a3 = e3.media.getAttribute(e3.config.attributes.embed.id), l3 = e3.media.getAttribute(e3.config.attributes.embed.hash)) : l3 = function(e4) {
            const t4 = e4.match(/^.*(vimeo.com\/|video\/)(\d+)(\?.*&*h=|\/)+([\d,a-f]+)/);
            return t4 && 5 === t4.length ? t4[4] : null;
          }(a3);
          const r3 = l3 ? { h: l3 } : {};
          i3 && Object.assign(n3, { controls: false, sidedock: false });
          const o3 = Ne(__spreadValues(__spreadValues({ loop: e3.config.loop.active, autoplay: e3.autoplay, muted: e3.muted, gesture: "media", playsinline: e3.config.playsinline }, r3), n3)), c3 = (u3 = a3, S.empty(u3) ? null : S.number(Number(u3)) ? u3 : u3.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : u3);
          var u3;
          const h3 = $("iframe"), d3 = me(e3.config.urls.vimeo.iframe, c3, o3);
          if (h3.setAttribute("src", d3), h3.setAttribute("allowfullscreen", ""), h3.setAttribute("allow", ["autoplay", "fullscreen", "picture-in-picture", "encrypted-media", "accelerometer", "gyroscope"].join("; ")), S.empty(s3) || h3.setAttribute("referrerPolicy", s3), i3 || !t3.customControls)
            h3.setAttribute("data-poster", e3.poster), e3.media = q(h3, e3.media);
          else {
            const t4 = $("div", { class: e3.config.classNames.embedContainer, "data-poster": e3.poster });
            t4.appendChild(h3), e3.media = q(t4, e3.media);
          }
          t3.customControls || Te(me(e3.config.urls.vimeo.api, d3)).then((t4) => {
            !S.empty(t4) && t4.thumbnail_url && Fe.setPoster.call(e3, t4.thumbnail_url).catch(() => {
            });
          }), e3.embed = new window.Vimeo.Player(h3, { autopause: e3.config.autopause, muted: e3.muted }), e3.media.paused = true, e3.media.currentTime = 0, e3.supported.ui && e3.embed.disableTextTrack(), e3.media.play = () => (We.call(e3, true), e3.embed.play()), e3.media.pause = () => (We.call(e3, false), e3.embed.pause()), e3.media.stop = () => {
            e3.pause(), e3.currentTime = 0;
          };
          let { currentTime: m2 } = e3.media;
          Object.defineProperty(e3.media, "currentTime", { get: () => m2, set(t4) {
            const { embed: i4, media: s4, paused: n4, volume: a4 } = e3, l4 = n4 && !i4.hasPlayed;
            s4.seeking = true, Z.call(e3, s4, "seeking"), Promise.resolve(l4 && i4.setVolume(0)).then(() => i4.setCurrentTime(t4)).then(() => l4 && i4.pause()).then(() => l4 && i4.setVolume(a4)).catch(() => {
            });
          } });
          let p3 = e3.config.speed.selected;
          Object.defineProperty(e3.media, "playbackRate", { get: () => p3, set(t4) {
            e3.embed.setPlaybackRate(t4).then(() => {
              p3 = t4, Z.call(e3, e3.media, "ratechange");
            }).catch(() => {
              e3.options.speed = [1];
            });
          } });
          let { volume: g2 } = e3.config;
          Object.defineProperty(e3.media, "volume", { get: () => g2, set(t4) {
            e3.embed.setVolume(t4).then(() => {
              g2 = t4, Z.call(e3, e3.media, "volumechange");
            });
          } });
          let { muted: f2 } = e3.config;
          Object.defineProperty(e3.media, "muted", { get: () => f2, set(t4) {
            const i4 = !!S.boolean(t4) && t4;
            e3.embed.setMuted(!!i4 || e3.config.muted).then(() => {
              f2 = i4, Z.call(e3, e3.media, "volumechange");
            });
          } });
          let y2, { loop: b2 } = e3.config;
          Object.defineProperty(e3.media, "loop", { get: () => b2, set(t4) {
            const i4 = S.boolean(t4) ? t4 : e3.config.loop.active;
            e3.embed.setLoop(i4).then(() => {
              b2 = i4;
            });
          } }), e3.embed.getVideoUrl().then((t4) => {
            y2 = t4, Pe.setDownloadUrl.call(e3);
          }).catch((e4) => {
            this.debug.warn(e4);
          }), Object.defineProperty(e3.media, "currentSrc", { get: () => y2 }), Object.defineProperty(e3.media, "ended", { get: () => e3.currentTime === e3.duration }), Promise.all([e3.embed.getVideoWidth(), e3.embed.getVideoHeight()]).then((t4) => {
            const [i4, s4] = t4;
            e3.embed.ratio = he(i4, s4), ue.call(this);
          }), e3.embed.setAutopause(e3.config.autopause).then((t4) => {
            e3.config.autopause = t4;
          }), e3.embed.getVideoTitle().then((t4) => {
            e3.config.title = t4, Fe.setTitle.call(this);
          }), e3.embed.getCurrentTime().then((t4) => {
            m2 = t4, Z.call(e3, e3.media, "timeupdate");
          }), e3.embed.getDuration().then((t4) => {
            e3.media.duration = t4, Z.call(e3, e3.media, "durationchange");
          }), e3.embed.getTextTracks().then((t4) => {
            e3.media.textTracks = t4, xe.setup.call(e3);
          }), e3.embed.on("cuechange", ({ cues: t4 = [] }) => {
            const i4 = t4.map((e4) => function(e5) {
              const t5 = document.createDocumentFragment(), i5 = document.createElement("div");
              return t5.appendChild(i5), i5.innerHTML = e5, t5.firstChild.innerText;
            }(e4.text));
            xe.updateCues.call(e3, i4);
          }), e3.embed.on("loaded", () => {
            if (e3.embed.getPaused().then((t4) => {
              We.call(e3, !t4), t4 || Z.call(e3, e3.media, "playing");
            }), S.element(e3.embed.element) && e3.supported.ui) {
              e3.embed.element.setAttribute("tabindex", -1);
            }
          }), e3.embed.on("bufferstart", () => {
            Z.call(e3, e3.media, "waiting");
          }), e3.embed.on("bufferend", () => {
            Z.call(e3, e3.media, "playing");
          }), e3.embed.on("play", () => {
            We.call(e3, true), Z.call(e3, e3.media, "playing");
          }), e3.embed.on("pause", () => {
            We.call(e3, false);
          }), e3.embed.on("timeupdate", (t4) => {
            e3.media.seeking = false, m2 = t4.seconds, Z.call(e3, e3.media, "timeupdate");
          }), e3.embed.on("progress", (t4) => {
            e3.media.buffered = t4.percent, Z.call(e3, e3.media, "progress"), 1 === parseInt(t4.percent, 10) && Z.call(e3, e3.media, "canplaythrough"), e3.embed.getDuration().then((t5) => {
              t5 !== e3.media.duration && (e3.media.duration = t5, Z.call(e3, e3.media, "durationchange"));
            });
          }), e3.embed.on("seeked", () => {
            e3.media.seeking = false, Z.call(e3, e3.media, "seeked");
          }), e3.embed.on("ended", () => {
            e3.media.paused = true, Z.call(e3, e3.media, "ended");
          }), e3.embed.on("error", (t4) => {
            e3.media.error = t4, Z.call(e3, e3.media, "error");
          }), t3.customControls && setTimeout(() => Fe.build.call(e3), 0);
        } };
        function Ke(e3) {
          e3 && !this.embed.hasPlayed && (this.embed.hasPlayed = true), this.media.paused === e3 && (this.media.paused = !e3, Z.call(this, this.media, e3 ? "play" : "pause"));
        }
        function Ye(e3) {
          return e3.noCookie ? "https://www.youtube-nocookie.com" : "http:" === window.location.protocol ? "http://www.youtube.com" : void 0;
        }
        const Qe = { setup() {
          if (R(this.elements.wrapper, this.config.classNames.embed, true), S.object(window.YT) && S.function(window.YT.Player))
            Qe.ready.call(this);
          else {
            const e3 = window.onYouTubeIframeAPIReady;
            window.onYouTubeIframeAPIReady = () => {
              S.function(e3) && e3(), Qe.ready.call(this);
            }, Be(this.config.urls.youtube.sdk).catch((e4) => {
              this.debug.warn("YouTube API failed to load", e4);
            });
          }
        }, getTitle(e3) {
          Te(me(this.config.urls.youtube.api, e3)).then((e4) => {
            if (S.object(e4)) {
              const { title: t3, height: i3, width: s3 } = e4;
              this.config.title = t3, Fe.setTitle.call(this), this.embed.ratio = he(s3, i3);
            }
            ue.call(this);
          }).catch(() => {
            ue.call(this);
          });
        }, ready() {
          const e3 = this, t3 = e3.config.youtube, i3 = e3.media && e3.media.getAttribute("id");
          if (!S.empty(i3) && i3.startsWith("youtube-"))
            return;
          let s3 = e3.media.getAttribute("src");
          S.empty(s3) && (s3 = e3.media.getAttribute(this.config.attributes.embed.id));
          const n3 = (a3 = s3, S.empty(a3) ? null : a3.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : a3);
          var a3;
          const l3 = $("div", { id: "".concat(e3.provider, "-").concat(Math.floor(1e4 * Math.random())), "data-poster": t3.customControls ? e3.poster : void 0 });
          if (e3.media = q(l3, e3.media), t3.customControls) {
            const t4 = (e4) => "https://i.ytimg.com/vi/".concat(n3, "/").concat(e4, "default.jpg");
            Re(t4("maxres"), 121).catch(() => Re(t4("sd"), 121)).catch(() => Re(t4("hq"))).then((t5) => Fe.setPoster.call(e3, t5.src)).then((t5) => {
              t5.includes("maxres") || (e3.elements.poster.style.backgroundSize = "cover");
            }).catch(() => {
            });
          }
          e3.embed = new window.YT.Player(e3.media, { videoId: n3, host: Ye(t3), playerVars: x({}, { autoplay: e3.config.autoplay ? 1 : 0, hl: e3.config.hl, controls: e3.supported.ui && t3.customControls ? 0 : 1, disablekb: 1, playsinline: e3.config.playsinline && !e3.config.fullscreen.iosNative ? 1 : 0, cc_load_policy: e3.captions.active ? 1 : 0, cc_lang_pref: e3.config.captions.language, widget_referrer: window ? window.location.href : null }, t3), events: { onError(t4) {
            if (!e3.media.error) {
              const i4 = t4.data, s4 = { 2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.", 5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.", 100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.", 101: "The owner of the requested video does not allow it to be played in embedded players.", 150: "The owner of the requested video does not allow it to be played in embedded players." }[i4] || "An unknown error occurred";
              e3.media.error = { code: i4, message: s4 }, Z.call(e3, e3.media, "error");
            }
          }, onPlaybackRateChange(t4) {
            const i4 = t4.target;
            e3.media.playbackRate = i4.getPlaybackRate(), Z.call(e3, e3.media, "ratechange");
          }, onReady(i4) {
            if (S.function(e3.media.play))
              return;
            const s4 = i4.target;
            Qe.getTitle.call(e3, n3), e3.media.play = () => {
              Ke.call(e3, true), s4.playVideo();
            }, e3.media.pause = () => {
              Ke.call(e3, false), s4.pauseVideo();
            }, e3.media.stop = () => {
              s4.stopVideo();
            }, e3.media.duration = s4.getDuration(), e3.media.paused = true, e3.media.currentTime = 0, Object.defineProperty(e3.media, "currentTime", { get: () => Number(s4.getCurrentTime()), set(t4) {
              e3.paused && !e3.embed.hasPlayed && e3.embed.mute(), e3.media.seeking = true, Z.call(e3, e3.media, "seeking"), s4.seekTo(t4);
            } }), Object.defineProperty(e3.media, "playbackRate", { get: () => s4.getPlaybackRate(), set(e4) {
              s4.setPlaybackRate(e4);
            } });
            let { volume: a4 } = e3.config;
            Object.defineProperty(e3.media, "volume", { get: () => a4, set(t4) {
              a4 = t4, s4.setVolume(100 * a4), Z.call(e3, e3.media, "volumechange");
            } });
            let { muted: l4 } = e3.config;
            Object.defineProperty(e3.media, "muted", { get: () => l4, set(t4) {
              const i5 = S.boolean(t4) ? t4 : l4;
              l4 = i5, s4[i5 ? "mute" : "unMute"](), s4.setVolume(100 * a4), Z.call(e3, e3.media, "volumechange");
            } }), Object.defineProperty(e3.media, "currentSrc", { get: () => s4.getVideoUrl() }), Object.defineProperty(e3.media, "ended", { get: () => e3.currentTime === e3.duration });
            const r3 = s4.getAvailablePlaybackRates();
            e3.options.speed = r3.filter((t4) => e3.config.speed.options.includes(t4)), e3.supported.ui && t3.customControls && e3.media.setAttribute("tabindex", -1), Z.call(e3, e3.media, "timeupdate"), Z.call(e3, e3.media, "durationchange"), clearInterval(e3.timers.buffering), e3.timers.buffering = setInterval(() => {
              e3.media.buffered = s4.getVideoLoadedFraction(), (null === e3.media.lastBuffered || e3.media.lastBuffered < e3.media.buffered) && Z.call(e3, e3.media, "progress"), e3.media.lastBuffered = e3.media.buffered, 1 === e3.media.buffered && (clearInterval(e3.timers.buffering), Z.call(e3, e3.media, "canplaythrough"));
            }, 200), t3.customControls && setTimeout(() => Fe.build.call(e3), 50);
          }, onStateChange(i4) {
            const s4 = i4.target;
            clearInterval(e3.timers.playing);
            switch (e3.media.seeking && [1, 2].includes(i4.data) && (e3.media.seeking = false, Z.call(e3, e3.media, "seeked")), i4.data) {
              case -1:
                Z.call(e3, e3.media, "timeupdate"), e3.media.buffered = s4.getVideoLoadedFraction(), Z.call(e3, e3.media, "progress");
                break;
              case 0:
                Ke.call(e3, false), e3.media.loop ? (s4.stopVideo(), s4.playVideo()) : Z.call(e3, e3.media, "ended");
                break;
              case 1:
                t3.customControls && !e3.config.autoplay && e3.media.paused && !e3.embed.hasPlayed ? e3.media.pause() : (Ke.call(e3, true), Z.call(e3, e3.media, "playing"), e3.timers.playing = setInterval(() => {
                  Z.call(e3, e3.media, "timeupdate");
                }, 50), e3.media.duration !== s4.getDuration() && (e3.media.duration = s4.getDuration(), Z.call(e3, e3.media, "durationchange")));
                break;
              case 2:
                e3.muted || e3.embed.unMute(), Ke.call(e3, false);
                break;
              case 3:
                Z.call(e3, e3.media, "waiting");
            }
            Z.call(e3, e3.elements.container, "statechange", false, { code: i4.data });
          } } });
        } }, Xe = { setup() {
          this.media ? (R(this.elements.container, this.config.classNames.type.replace("{0}", this.type), true), R(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), true), this.isEmbed && R(this.elements.container, this.config.classNames.type.replace("{0}", "video"), true), this.isVideo && (this.elements.wrapper = $("div", { class: this.config.classNames.video }), L(this.media, this.elements.wrapper), this.elements.poster = $("div", { class: this.config.classNames.poster }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? de.setup.call(this) : this.isYouTube ? Qe.setup.call(this) : this.isVimeo && ze.setup.call(this)) : this.debug.warn("No media element found!");
        } };
        class Je {
          constructor(t3) {
            e2(this, "load", () => {
              this.enabled && (S.object(window.google) && S.object(window.google.ima) ? this.ready() : Be(this.player.config.urls.googleIMA.sdk).then(() => {
                this.ready();
              }).catch(() => {
                this.trigger("error", new Error("Google IMA SDK failed to load"));
              }));
            }), e2(this, "ready", () => {
              var e3;
              this.enabled || ((e3 = this).manager && e3.manager.destroy(), e3.elements.displayContainer && e3.elements.displayContainer.destroy(), e3.elements.container.remove()), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then(() => {
                this.clearSafetyTimer("onAdsManagerLoaded()");
              }), this.listeners(), this.setupIMA();
            }), e2(this, "setupIMA", () => {
              this.elements.container = $("div", { class: this.player.config.classNames.ads }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (e3) => this.onAdsManagerLoaded(e3), false), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (e3) => this.onAdError(e3), false), this.requestAds();
            }), e2(this, "requestAds", () => {
              const { container: e3 } = this.player.elements;
              try {
                const t4 = new google.ima.AdsRequest();
                t4.adTagUrl = this.tagUrl, t4.linearAdSlotWidth = e3.offsetWidth, t4.linearAdSlotHeight = e3.offsetHeight, t4.nonLinearAdSlotWidth = e3.offsetWidth, t4.nonLinearAdSlotHeight = e3.offsetHeight, t4.forceNonLinearFullSlot = false, t4.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(t4);
              } catch (e4) {
                this.onAdError(e4);
              }
            }), e2(this, "pollCountdown", (e3 = false) => {
              if (!e3)
                return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
              this.countdownTimer = setInterval(() => {
                const e4 = Ee(Math.max(this.manager.getRemainingTime(), 0)), t4 = "".concat(ve.get("advertisement", this.player.config), " - ").concat(e4);
                this.elements.container.setAttribute("data-badge-text", t4);
              }, 100);
            }), e2(this, "onAdsManagerLoaded", (e3) => {
              if (!this.enabled)
                return;
              const t4 = new google.ima.AdsRenderingSettings();
              t4.restoreCustomPlaybackStateOnAdBreakComplete = true, t4.enablePreloading = true, this.manager = e3.getAdsManager(this.player, t4), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (e4) => this.onAdError(e4)), Object.keys(google.ima.AdEvent.Type).forEach((e4) => {
                this.manager.addEventListener(google.ima.AdEvent.Type[e4], (e5) => this.onAdEvent(e5));
              }), this.trigger("loaded");
            }), e2(this, "addCuePoints", () => {
              S.empty(this.cuePoints) || this.cuePoints.forEach((e3) => {
                if (0 !== e3 && -1 !== e3 && e3 < this.player.duration) {
                  const t4 = this.player.elements.progress;
                  if (S.element(t4)) {
                    const i3 = 100 / this.player.duration * e3, s3 = $("span", { class: this.player.config.classNames.cues });
                    s3.style.left = "".concat(i3.toString(), "%"), t4.appendChild(s3);
                  }
                }
              });
            }), e2(this, "onAdEvent", (e3) => {
              const { container: t4 } = this.player.elements, i3 = e3.getAd(), s3 = e3.getAdData();
              switch (((e4) => {
                Z.call(this.player, this.player.media, "ads".concat(e4.replace(/_/g, "").toLowerCase()));
              })(e3.type), e3.type) {
                case google.ima.AdEvent.Type.LOADED:
                  this.trigger("loaded"), this.pollCountdown(true), i3.isLinear() || (i3.width = t4.offsetWidth, i3.height = t4.offsetHeight);
                  break;
                case google.ima.AdEvent.Type.STARTED:
                  this.manager.setVolume(this.player.volume);
                  break;
                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                  this.player.ended ? this.loadAds() : this.loader.contentComplete();
                  break;
                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                  this.pauseContent();
                  break;
                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                  this.pollCountdown(), this.resumeContent();
                  break;
                case google.ima.AdEvent.Type.LOG:
                  s3.adError && this.player.debug.warn("Non-fatal ad error: ".concat(s3.adError.getMessage()));
              }
            }), e2(this, "onAdError", (e3) => {
              this.cancel(), this.player.debug.warn("Ads error", e3);
            }), e2(this, "listeners", () => {
              const { container: e3 } = this.player.elements;
              let t4;
              this.player.on("canplay", () => {
                this.addCuePoints();
              }), this.player.on("ended", () => {
                this.loader.contentComplete();
              }), this.player.on("timeupdate", () => {
                t4 = this.player.currentTime;
              }), this.player.on("seeked", () => {
                const e4 = this.player.currentTime;
                S.empty(this.cuePoints) || this.cuePoints.forEach((i3, s3) => {
                  t4 < i3 && i3 < e4 && (this.manager.discardAdBreak(), this.cuePoints.splice(s3, 1));
                });
              }), window.addEventListener("resize", () => {
                this.manager && this.manager.resize(e3.offsetWidth, e3.offsetHeight, google.ima.ViewMode.NORMAL);
              });
            }), e2(this, "play", () => {
              const { container: e3 } = this.player.elements;
              this.managerPromise || this.resumeContent(), this.managerPromise.then(() => {
                this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();
                try {
                  this.initialized || (this.manager.init(e3.offsetWidth, e3.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = true;
                } catch (e4) {
                  this.onAdError(e4);
                }
              }).catch(() => {
              });
            }), e2(this, "resumeContent", () => {
              this.elements.container.style.zIndex = "", this.playing = false, ie(this.player.media.play());
            }), e2(this, "pauseContent", () => {
              this.elements.container.style.zIndex = 3, this.playing = true, this.player.media.pause();
            }), e2(this, "cancel", () => {
              this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds();
            }), e2(this, "loadAds", () => {
              this.managerPromise.then(() => {
                this.manager && this.manager.destroy(), this.managerPromise = new Promise((e3) => {
                  this.on("loaded", e3), this.player.debug.log(this.manager);
                }), this.initialized = false, this.requestAds();
              }).catch(() => {
              });
            }), e2(this, "trigger", (e3, ...t4) => {
              const i3 = this.events[e3];
              S.array(i3) && i3.forEach((e4) => {
                S.function(e4) && e4.apply(this, t4);
              });
            }), e2(this, "on", (e3, t4) => (S.array(this.events[e3]) || (this.events[e3] = []), this.events[e3].push(t4), this)), e2(this, "startSafetyTimer", (e3, t4) => {
              this.player.debug.log("Safety timer invoked from: ".concat(t4)), this.safetyTimer = setTimeout(() => {
                this.cancel(), this.clearSafetyTimer("startSafetyTimer()");
              }, e3);
            }), e2(this, "clearSafetyTimer", (e3) => {
              S.nullOrUndefined(this.safetyTimer) || (this.player.debug.log("Safety timer cleared from: ".concat(e3)), clearTimeout(this.safetyTimer), this.safetyTimer = null);
            }), this.player = t3, this.config = t3.config.ads, this.playing = false, this.initialized = false, this.elements = { container: null, displayContainer: null }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise((e3, t4) => {
              this.on("loaded", e3), this.on("error", t4);
            }), this.load();
          }
          get enabled() {
            const { config: e3 } = this;
            return this.player.isHTML5 && this.player.isVideo && e3.enabled && (!S.empty(e3.publisherId) || S.url(e3.tagUrl));
          }
          get tagUrl() {
            const { config: e3 } = this;
            if (S.url(e3.tagUrl))
              return e3.tagUrl;
            return "https://go.aniview.com/api/adserver6/vast/?".concat(Ne({ AV_PUBLISHERID: "58c25bb0073ef448b1087ad6", AV_CHANNELID: "5a0458dc28a06145e4519d21", AV_URL: window.location.hostname, cb: Date.now(), AV_WIDTH: 640, AV_HEIGHT: 480, AV_CDIM2: e3.publisherId }));
          }
        }
        function Ge(e3 = 0, t3 = 0, i3 = 255) {
          return Math.min(Math.max(e3, t3), i3);
        }
        const Ze = (e3) => {
          const t3 = [];
          return e3.split(/\r\n\r\n|\n\n|\r\r/).forEach((e4) => {
            const i3 = {};
            e4.split(/\r\n|\n|\r/).forEach((e5) => {
              if (S.number(i3.startTime)) {
                if (!S.empty(e5.trim()) && S.empty(i3.text)) {
                  const t4 = e5.trim().split("#xywh=");
                  [i3.text] = t4, t4[1] && ([i3.x, i3.y, i3.w, i3.h] = t4[1].split(","));
                }
              } else {
                const t4 = e5.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);
                t4 && (i3.startTime = 60 * Number(t4[1] || 0) * 60 + 60 * Number(t4[2]) + Number(t4[3]) + Number("0.".concat(t4[4])), i3.endTime = 60 * Number(t4[6] || 0) * 60 + 60 * Number(t4[7]) + Number(t4[8]) + Number("0.".concat(t4[9])));
              }
            }), i3.text && t3.push(i3);
          }), t3;
        }, et = (e3, t3) => {
          const i3 = {};
          return e3 > t3.width / t3.height ? (i3.width = t3.width, i3.height = 1 / e3 * t3.width) : (i3.height = t3.height, i3.width = e3 * t3.height), i3;
        };
        class tt {
          constructor(t3) {
            e2(this, "load", () => {
              this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then(() => {
                this.enabled && (this.render(), this.determineContainerAutoSizing(), this.listeners(), this.loaded = true);
              });
            }), e2(this, "getThumbnails", () => new Promise((e3) => {
              const { src: t4 } = this.player.config.previewThumbnails;
              if (S.empty(t4))
                throw new Error("Missing previewThumbnails.src config attribute");
              const i3 = () => {
                this.thumbnails.sort((e4, t5) => e4.height - t5.height), this.player.debug.log("Preview thumbnails", this.thumbnails), e3();
              };
              if (S.function(t4))
                t4((e4) => {
                  this.thumbnails = e4, i3();
                });
              else {
                const e4 = (S.string(t4) ? [t4] : t4).map((e5) => this.getThumbnail(e5));
                Promise.all(e4).then(i3);
              }
            })), e2(this, "getThumbnail", (e3) => new Promise((t4) => {
              Te(e3).then((i3) => {
                const s3 = { frames: Ze(i3), height: null, urlPrefix: "" };
                s3.frames[0].text.startsWith("/") || s3.frames[0].text.startsWith("http://") || s3.frames[0].text.startsWith("https://") || (s3.urlPrefix = e3.substring(0, e3.lastIndexOf("/") + 1));
                const n3 = new Image();
                n3.onload = () => {
                  s3.height = n3.naturalHeight, s3.width = n3.naturalWidth, this.thumbnails.push(s3), t4();
                }, n3.src = s3.urlPrefix + s3.frames[0].text;
              });
            })), e2(this, "startMove", (e3) => {
              if (this.loaded && S.event(e3) && ["touchmove", "mousemove"].includes(e3.type) && this.player.media.duration) {
                if ("touchmove" === e3.type)
                  this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
                else {
                  var t4, i3;
                  const s3 = this.player.elements.progress.getBoundingClientRect(), n3 = 100 / s3.width * (e3.pageX - s3.left);
                  this.seekTime = this.player.media.duration * (n3 / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = e3.pageX, this.elements.thumb.time.innerText = Ee(this.seekTime);
                  const a3 = null === (t4 = this.player.config.markers) || void 0 === t4 || null === (i3 = t4.points) || void 0 === i3 ? void 0 : i3.find(({ time: e4 }) => e4 === Math.round(this.seekTime));
                  a3 && this.elements.thumb.time.insertAdjacentHTML("afterbegin", "".concat(a3.label, "<br>"));
                }
                this.showImageAtCurrentTime();
              }
            }), e2(this, "endMove", () => {
              this.toggleThumbContainer(false, true);
            }), e2(this, "startScrubbing", (e3) => {
              (S.nullOrUndefined(e3.button) || false === e3.button || 0 === e3.button) && (this.mouseDown = true, this.player.media.duration && (this.toggleScrubbingContainer(true), this.toggleThumbContainer(false, true), this.showImageAtCurrentTime()));
            }), e2(this, "endScrubbing", () => {
              this.mouseDown = false, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(false) : G.call(this.player, this.player.media, "timeupdate", () => {
                this.mouseDown || this.toggleScrubbingContainer(false);
              });
            }), e2(this, "listeners", () => {
              this.player.on("play", () => {
                this.toggleThumbContainer(false, true);
              }), this.player.on("seeked", () => {
                this.toggleThumbContainer(false);
              }), this.player.on("timeupdate", () => {
                this.lastTime = this.player.media.currentTime;
              });
            }), e2(this, "render", () => {
              this.elements.thumb.container = $("div", { class: this.player.config.classNames.previewThumbnails.thumbContainer }), this.elements.thumb.imageContainer = $("div", { class: this.player.config.classNames.previewThumbnails.imageContainer }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
              const e3 = $("div", { class: this.player.config.classNames.previewThumbnails.timeContainer });
              this.elements.thumb.time = $("span", {}, "00:00"), e3.appendChild(this.elements.thumb.time), this.elements.thumb.imageContainer.appendChild(e3), S.element(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = $("div", { class: this.player.config.classNames.previewThumbnails.scrubbingContainer }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);
            }), e2(this, "destroy", () => {
              this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove();
            }), e2(this, "showImageAtCurrentTime", () => {
              this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
              const e3 = this.thumbnails[0].frames.findIndex((e4) => this.seekTime >= e4.startTime && this.seekTime <= e4.endTime), t4 = e3 >= 0;
              let i3 = 0;
              this.mouseDown || this.toggleThumbContainer(t4), t4 && (this.thumbnails.forEach((t5, s3) => {
                this.loadedImages.includes(t5.frames[e3].text) && (i3 = s3);
              }), e3 !== this.showingThumb && (this.showingThumb = e3, this.loadImage(i3)));
            }), e2(this, "loadImage", (e3 = 0) => {
              const t4 = this.showingThumb, i3 = this.thumbnails[e3], { urlPrefix: s3 } = i3, n3 = i3.frames[t4], a3 = i3.frames[t4].text, l3 = s3 + a3;
              if (this.currentImageElement && this.currentImageElement.dataset.filename === a3)
                this.showImage(this.currentImageElement, n3, e3, t4, a3, false), this.currentImageElement.dataset.index = t4, this.removeOldImages(this.currentImageElement);
              else {
                this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);
                const i4 = new Image();
                i4.src = l3, i4.dataset.index = t4, i4.dataset.filename = a3, this.showingThumbFilename = a3, this.player.debug.log("Loading image: ".concat(l3)), i4.onload = () => this.showImage(i4, n3, e3, t4, a3, true), this.loadingImage = i4, this.removeOldImages(i4);
              }
            }), e2(this, "showImage", (e3, t4, i3, s3, n3, a3 = true) => {
              this.player.debug.log("Showing thumb: ".concat(n3, ". num: ").concat(s3, ". qual: ").concat(i3, ". newimg: ").concat(a3)), this.setImageSizeAndOffset(e3, t4), a3 && (this.currentImageContainer.appendChild(e3), this.currentImageElement = e3, this.loadedImages.includes(n3) || this.loadedImages.push(n3)), this.preloadNearby(s3, true).then(this.preloadNearby(s3, false)).then(this.getHigherQuality(i3, e3, t4, n3));
            }), e2(this, "removeOldImages", (e3) => {
              Array.from(this.currentImageContainer.children).forEach((t4) => {
                if ("img" !== t4.tagName.toLowerCase())
                  return;
                const i3 = this.usingSprites ? 500 : 1e3;
                if (t4.dataset.index !== e3.dataset.index && !t4.dataset.deleting) {
                  t4.dataset.deleting = true;
                  const { currentImageContainer: e4 } = this;
                  setTimeout(() => {
                    e4.removeChild(t4), this.player.debug.log("Removing thumb: ".concat(t4.dataset.filename));
                  }, i3);
                }
              });
            }), e2(this, "preloadNearby", (e3, t4 = true) => new Promise((i3) => {
              setTimeout(() => {
                const s3 = this.thumbnails[0].frames[e3].text;
                if (this.showingThumbFilename === s3) {
                  let n3;
                  n3 = t4 ? this.thumbnails[0].frames.slice(e3) : this.thumbnails[0].frames.slice(0, e3).reverse();
                  let a3 = false;
                  n3.forEach((e4) => {
                    const t5 = e4.text;
                    if (t5 !== s3 && !this.loadedImages.includes(t5)) {
                      a3 = true, this.player.debug.log("Preloading thumb filename: ".concat(t5));
                      const { urlPrefix: e5 } = this.thumbnails[0], s4 = e5 + t5, n4 = new Image();
                      n4.src = s4, n4.onload = () => {
                        this.player.debug.log("Preloaded thumb filename: ".concat(t5)), this.loadedImages.includes(t5) || this.loadedImages.push(t5), i3();
                      };
                    }
                  }), a3 || i3();
                }
              }, 300);
            })), e2(this, "getHigherQuality", (e3, t4, i3, s3) => {
              if (e3 < this.thumbnails.length - 1) {
                let n3 = t4.naturalHeight;
                this.usingSprites && (n3 = i3.h), n3 < this.thumbContainerHeight && setTimeout(() => {
                  this.showingThumbFilename === s3 && (this.player.debug.log("Showing higher quality thumb for: ".concat(s3)), this.loadImage(e3 + 1));
                }, 300);
              }
            }), e2(this, "toggleThumbContainer", (e3 = false, t4 = false) => {
              const i3 = this.player.config.classNames.previewThumbnails.thumbContainerShown;
              this.elements.thumb.container.classList.toggle(i3, e3), !e3 && t4 && (this.showingThumb = null, this.showingThumbFilename = null);
            }), e2(this, "toggleScrubbingContainer", (e3 = false) => {
              const t4 = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
              this.elements.scrubbing.container.classList.toggle(t4, e3), e3 || (this.showingThumb = null, this.showingThumbFilename = null);
            }), e2(this, "determineContainerAutoSizing", () => {
              (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) && (this.sizeSpecifiedInCSS = true);
            }), e2(this, "setThumbContainerSizeAndPos", () => {
              const { imageContainer: e3 } = this.elements.thumb;
              if (this.sizeSpecifiedInCSS) {
                if (e3.clientHeight > 20 && e3.clientWidth < 20) {
                  const t4 = Math.floor(e3.clientHeight * this.thumbAspectRatio);
                  e3.style.width = "".concat(t4, "px");
                } else if (e3.clientHeight < 20 && e3.clientWidth > 20) {
                  const t4 = Math.floor(e3.clientWidth / this.thumbAspectRatio);
                  e3.style.height = "".concat(t4, "px");
                }
              } else {
                const t4 = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
                e3.style.height = "".concat(this.thumbContainerHeight, "px"), e3.style.width = "".concat(t4, "px");
              }
              this.setThumbContainerPos();
            }), e2(this, "setThumbContainerPos", () => {
              const e3 = this.player.elements.progress.getBoundingClientRect(), t4 = this.player.elements.container.getBoundingClientRect(), { container: i3 } = this.elements.thumb, s3 = t4.left - e3.left + 10, n3 = t4.right - e3.left - i3.clientWidth - 10, a3 = this.mousePosX - e3.left - i3.clientWidth / 2, l3 = Ge(a3, s3, n3);
              i3.style.left = "".concat(l3, "px"), i3.style.setProperty("--preview-arrow-offset", a3 - l3 + "px");
            }), e2(this, "setScrubbingContainerSize", () => {
              const { width: e3, height: t4 } = et(this.thumbAspectRatio, { width: this.player.media.clientWidth, height: this.player.media.clientHeight });
              this.elements.scrubbing.container.style.width = "".concat(e3, "px"), this.elements.scrubbing.container.style.height = "".concat(t4, "px");
            }), e2(this, "setImageSizeAndOffset", (e3, t4) => {
              if (!this.usingSprites)
                return;
              const i3 = this.thumbContainerHeight / t4.h;
              e3.style.height = e3.naturalHeight * i3 + "px", e3.style.width = e3.naturalWidth * i3 + "px", e3.style.left = "-".concat(t4.x * i3, "px"), e3.style.top = "-".concat(t4.y * i3, "px");
            }), this.player = t3, this.thumbnails = [], this.loaded = false, this.lastMouseMoveTime = Date.now(), this.mouseDown = false, this.loadedImages = [], this.elements = { thumb: {}, scrubbing: {} }, this.load();
          }
          get enabled() {
            return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;
          }
          get currentImageContainer() {
            return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer;
          }
          get usingSprites() {
            return Object.keys(this.thumbnails[0].frames[0]).includes("w");
          }
          get thumbAspectRatio() {
            return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height;
          }
          get thumbContainerHeight() {
            if (this.mouseDown) {
              const { height: e3 } = et(this.thumbAspectRatio, { width: this.player.media.clientWidth, height: this.player.media.clientHeight });
              return e3;
            }
            return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);
          }
          get currentImageElement() {
            return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement;
          }
          set currentImageElement(e3) {
            this.mouseDown ? this.currentScrubbingImageElement = e3 : this.currentThumbnailImageElement = e3;
          }
        }
        const it = { insertElements(e3, t3) {
          S.string(t3) ? _(e3, this.media, { src: t3 }) : S.array(t3) && t3.forEach((t4) => {
            _(e3, this.media, t4);
          });
        }, change(e3) {
          N(e3, "sources.length") ? (de.cancelRequests.call(this), this.destroy.call(this, () => {
            this.options.quality = [], O(this.media), this.media = null, S.element(this.elements.container) && this.elements.container.removeAttribute("class");
            const { sources: t3, type: i3 } = e3, [{ provider: s3 = _e.html5, src: n3 }] = t3, a3 = "html5" === s3 ? i3 : "div", l3 = "html5" === s3 ? {} : { src: n3 };
            Object.assign(this, { provider: s3, type: i3, supported: K.check(i3, s3, this.config.playsinline), media: $(a3, l3) }), this.elements.container.appendChild(this.media), S.boolean(e3.autoplay) && (this.config.autoplay = e3.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute("crossorigin", ""), this.config.autoplay && this.media.setAttribute("autoplay", ""), S.empty(e3.poster) || (this.poster = e3.poster), this.config.loop.active && this.media.setAttribute("loop", ""), this.config.muted && this.media.setAttribute("muted", ""), this.config.playsinline && this.media.setAttribute("playsinline", "")), Fe.addStyleHook.call(this), this.isHTML5 && it.insertElements.call(this, "source", t3), this.config.title = e3.title, Xe.setup.call(this), this.isHTML5 && Object.keys(e3).includes("tracks") && it.insertElements.call(this, "track", e3.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && Fe.build.call(this), this.isHTML5 && this.media.load(), S.empty(e3.previewThumbnails) || (Object.assign(this.config.previewThumbnails, e3.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new tt(this))), this.fullscreen.update();
          }, true)) : this.debug.warn("Invalid source format");
        } };
        class st {
          constructor(t3, i3) {
            if (e2(this, "play", () => S.function(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then(() => this.ads.play()).catch(() => ie(this.media.play())), this.media.play()) : null), e2(this, "pause", () => this.playing && S.function(this.media.pause) ? this.media.pause() : null), e2(this, "togglePlay", (e3) => (S.boolean(e3) ? e3 : !this.playing) ? this.play() : this.pause()), e2(this, "stop", () => {
              this.isHTML5 ? (this.pause(), this.restart()) : S.function(this.media.stop) && this.media.stop();
            }), e2(this, "restart", () => {
              this.currentTime = 0;
            }), e2(this, "rewind", (e3) => {
              this.currentTime -= S.number(e3) ? e3 : this.config.seekTime;
            }), e2(this, "forward", (e3) => {
              this.currentTime += S.number(e3) ? e3 : this.config.seekTime;
            }), e2(this, "increaseVolume", (e3) => {
              const t4 = this.media.muted ? 0 : this.volume;
              this.volume = t4 + (S.number(e3) ? e3 : 0);
            }), e2(this, "decreaseVolume", (e3) => {
              this.increaseVolume(-e3);
            }), e2(this, "airplay", () => {
              K.airplay && this.media.webkitShowPlaybackTargetPicker();
            }), e2(this, "toggleControls", (e3) => {
              if (this.supported.ui && !this.isAudio) {
                const t4 = F(this.elements.container, this.config.classNames.hideControls), i4 = void 0 === e3 ? void 0 : !e3, s4 = R(this.elements.container, this.config.classNames.hideControls, i4);
                if (s4 && S.array(this.config.controls) && this.config.controls.includes("settings") && !S.empty(this.config.settings) && Pe.toggleMenu.call(this, false), s4 !== t4) {
                  const e4 = s4 ? "controlshidden" : "controlsshown";
                  Z.call(this, this.media, e4);
                }
                return !s4;
              }
              return false;
            }), e2(this, "on", (e3, t4) => {
              X.call(this, this.elements.container, e3, t4);
            }), e2(this, "once", (e3, t4) => {
              G.call(this, this.elements.container, e3, t4);
            }), e2(this, "off", (e3, t4) => {
              J(this.elements.container, e3, t4);
            }), e2(this, "destroy", (e3, t4 = false) => {
              if (!this.ready)
                return;
              const i4 = () => {
                document.body.style.overflow = "", this.embed = null, t4 ? (Object.keys(this.elements).length && (O(this.elements.buttons.play), O(this.elements.captions), O(this.elements.controls), O(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), S.function(e3) && e3()) : (ee.call(this), de.cancelRequests.call(this), q(this.elements.original, this.elements.container), Z.call(this, this.elements.original, "destroyed", true), S.function(e3) && e3.call(this.elements.original), this.ready = false, setTimeout(() => {
                  this.elements = null, this.media = null;
                }, 200));
              };
              this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (Fe.toggleNativeControls.call(this, true), i4()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && S.function(this.embed.destroy) && this.embed.destroy(), i4()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(i4), setTimeout(i4, 200));
            }), e2(this, "supports", (e3) => K.mime.call(this, e3)), this.timers = {}, this.ready = false, this.loading = false, this.failed = false, this.touch = K.touch, this.media = t3, S.string(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || S.nodeList(this.media) || S.array(this.media)) && (this.media = this.media[0]), this.config = x({}, Le, st.defaults, i3 || {}, (() => {
              try {
                return JSON.parse(this.media.getAttribute("data-plyr-config"));
              } catch (e3) {
                return {};
              }
            })()), this.elements = { container: null, fullscreen: null, captions: null, buttons: {}, display: {}, progress: {}, inputs: {}, settings: { popup: null, menu: null, panels: {}, buttons: {} } }, this.captions = { active: null, currentTrack: -1, meta: /* @__PURE__ */ new WeakMap() }, this.fullscreen = { active: false }, this.options = { speed: [], quality: [] }, this.debug = new De(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", K), S.nullOrUndefined(this.media) || !S.element(this.media))
              return void this.debug.error("Setup failed: no suitable element passed");
            if (this.media.plyr)
              return void this.debug.warn("Target already setup");
            if (!this.config.enabled)
              return void this.debug.error("Setup failed: disabled by config");
            if (!K.check().api)
              return void this.debug.error("Setup failed: no support");
            const s3 = this.media.cloneNode(true);
            s3.autoplay = false, this.elements.original = s3;
            const n3 = this.media.tagName.toLowerCase();
            let a3 = null, l3 = null;
            switch (n3) {
              case "div":
                if (a3 = this.media.querySelector("iframe"), S.element(a3)) {
                  if (l3 = Me(a3.getAttribute("src")), this.provider = function(e3) {
                    return /^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e3) ? _e.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e3) ? _e.vimeo : null;
                  }(l3.toString()), this.elements.container = this.media, this.media = a3, this.elements.container.className = "", l3.search.length) {
                    const e3 = ["1", "true"];
                    e3.includes(l3.searchParams.get("autoplay")) && (this.config.autoplay = true), e3.includes(l3.searchParams.get("loop")) && (this.config.loop.active = true), this.isYouTube ? (this.config.playsinline = e3.includes(l3.searchParams.get("playsinline")), this.config.youtube.hl = l3.searchParams.get("hl")) : this.config.playsinline = true;
                  }
                } else
                  this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
                if (S.empty(this.provider) || !Object.values(_e).includes(this.provider))
                  return void this.debug.error("Setup failed: Invalid provider");
                this.type = je;
                break;
              case "video":
              case "audio":
                this.type = n3, this.provider = _e.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = true), this.media.hasAttribute("autoplay") && (this.config.autoplay = true), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = true), this.media.hasAttribute("muted") && (this.config.muted = true), this.media.hasAttribute("loop") && (this.config.loop.active = true);
                break;
              default:
                return void this.debug.error("Setup failed: unsupported type");
            }
            this.supported = K.check(this.type, this.provider), this.supported.api ? (this.eventListeners = [], this.listeners = new Ve(this), this.storage = new we(this), this.media.plyr = this, S.element(this.elements.container) || (this.elements.container = $("div"), L(this.media, this.elements.container)), Fe.migrateStyles.call(this), Fe.addStyleHook.call(this), Xe.setup.call(this), this.config.debug && X.call(this, this.elements.container, this.config.events.join(" "), (e3) => {
              this.debug.log("event: ".concat(e3.type));
            }), this.fullscreen = new He(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && Fe.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new Je(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", () => ie(this.play())), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new tt(this))) : this.debug.error("Setup failed: no support");
          }
          get isHTML5() {
            return this.provider === _e.html5;
          }
          get isEmbed() {
            return this.isYouTube || this.isVimeo;
          }
          get isYouTube() {
            return this.provider === _e.youtube;
          }
          get isVimeo() {
            return this.provider === _e.vimeo;
          }
          get isVideo() {
            return this.type === je;
          }
          get isAudio() {
            return this.type === Oe;
          }
          get playing() {
            return Boolean(this.ready && !this.paused && !this.ended);
          }
          get paused() {
            return Boolean(this.media.paused);
          }
          get stopped() {
            return Boolean(this.paused && 0 === this.currentTime);
          }
          get ended() {
            return Boolean(this.media.ended);
          }
          set currentTime(e3) {
            if (!this.duration)
              return;
            const t3 = S.number(e3) && e3 > 0;
            this.media.currentTime = t3 ? Math.min(e3, this.duration) : 0, this.debug.log("Seeking to ".concat(this.currentTime, " seconds"));
          }
          get currentTime() {
            return Number(this.media.currentTime);
          }
          get buffered() {
            const { buffered: e3 } = this.media;
            return S.number(e3) ? e3 : e3 && e3.length && this.duration > 0 ? e3.end(0) / this.duration : 0;
          }
          get seeking() {
            return Boolean(this.media.seeking);
          }
          get duration() {
            const e3 = parseFloat(this.config.duration), t3 = (this.media || {}).duration, i3 = S.number(t3) && t3 !== 1 / 0 ? t3 : 0;
            return e3 || i3;
          }
          set volume(e3) {
            let t3 = e3;
            S.string(t3) && (t3 = Number(t3)), S.number(t3) || (t3 = this.storage.get("volume")), S.number(t3) || ({ volume: t3 } = this.config), t3 > 1 && (t3 = 1), t3 < 0 && (t3 = 0), this.config.volume = t3, this.media.volume = t3, !S.empty(e3) && this.muted && t3 > 0 && (this.muted = false);
          }
          get volume() {
            return Number(this.media.volume);
          }
          set muted(e3) {
            let t3 = e3;
            S.boolean(t3) || (t3 = this.storage.get("muted")), S.boolean(t3) || (t3 = this.config.muted), this.config.muted = t3, this.media.muted = t3;
          }
          get muted() {
            return Boolean(this.media.muted);
          }
          get hasAudio() {
            return !this.isHTML5 || (!!this.isAudio || (Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length)));
          }
          set speed(e3) {
            let t3 = null;
            S.number(e3) && (t3 = e3), S.number(t3) || (t3 = this.storage.get("speed")), S.number(t3) || (t3 = this.config.speed.selected);
            const { minimumSpeed: i3, maximumSpeed: s3 } = this;
            t3 = Ge(t3, i3, s3), this.config.speed.selected = t3, setTimeout(() => {
              this.media && (this.media.playbackRate = t3);
            }, 0);
          }
          get speed() {
            return Number(this.media.playbackRate);
          }
          get minimumSpeed() {
            return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? 0.5 : 0.0625;
          }
          get maximumSpeed() {
            return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16;
          }
          set quality(e3) {
            const t3 = this.config.quality, i3 = this.options.quality;
            if (!i3.length)
              return;
            let s3 = [!S.empty(e3) && Number(e3), this.storage.get("quality"), t3.selected, t3.default].find(S.number), n3 = true;
            if (!i3.includes(s3)) {
              const e4 = ne(i3, s3);
              this.debug.warn("Unsupported quality option: ".concat(s3, ", using ").concat(e4, " instead")), s3 = e4, n3 = false;
            }
            t3.selected = s3, this.media.quality = s3, n3 && this.storage.set({ quality: s3 });
          }
          get quality() {
            return this.media.quality;
          }
          set loop(e3) {
            const t3 = S.boolean(e3) ? e3 : this.config.loop.active;
            this.config.loop.active = t3, this.media.loop = t3;
          }
          get loop() {
            return Boolean(this.media.loop);
          }
          set source(e3) {
            it.change.call(this, e3);
          }
          get source() {
            return this.media.currentSrc;
          }
          get download() {
            const { download: e3 } = this.config.urls;
            return S.url(e3) ? e3 : this.source;
          }
          set download(e3) {
            S.url(e3) && (this.config.urls.download = e3, Pe.setDownloadUrl.call(this));
          }
          set poster(e3) {
            this.isVideo ? Fe.setPoster.call(this, e3, false).catch(() => {
            }) : this.debug.warn("Poster can only be set for video");
          }
          get poster() {
            return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null;
          }
          get ratio() {
            if (!this.isVideo)
              return null;
            const e3 = oe(ce.call(this));
            return S.array(e3) ? e3.join(":") : e3;
          }
          set ratio(e3) {
            this.isVideo ? S.string(e3) && re(e3) ? (this.config.ratio = oe(e3), ue.call(this)) : this.debug.error("Invalid aspect ratio specified (".concat(e3, ")")) : this.debug.warn("Aspect ratio can only be set for video");
          }
          set autoplay(e3) {
            this.config.autoplay = S.boolean(e3) ? e3 : this.config.autoplay;
          }
          get autoplay() {
            return Boolean(this.config.autoplay);
          }
          toggleCaptions(e3) {
            xe.toggle.call(this, e3, false);
          }
          set currentTrack(e3) {
            xe.set.call(this, e3, false), xe.setup.call(this);
          }
          get currentTrack() {
            const { toggled: e3, currentTrack: t3 } = this.captions;
            return e3 ? t3 : -1;
          }
          set language(e3) {
            xe.setLanguage.call(this, e3, false);
          }
          get language() {
            return (xe.getCurrentTrack.call(this) || {}).language;
          }
          set pip(e3) {
            if (!K.pip)
              return;
            const t3 = S.boolean(e3) ? e3 : !this.pip;
            S.function(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(t3 ? Ie : $e), S.function(this.media.requestPictureInPicture) && (!this.pip && t3 ? this.media.requestPictureInPicture() : this.pip && !t3 && document.exitPictureInPicture());
          }
          get pip() {
            return K.pip ? S.empty(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === Ie : null;
          }
          setPreviewThumbnails(e3) {
            this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, e3), this.config.previewThumbnails.enabled && (this.previewThumbnails = new tt(this));
          }
          static supported(e3, t3) {
            return K.check(e3, t3);
          }
          static loadSprite(e3, t3) {
            return ke(e3, t3);
          }
          static setup(e3, t3 = {}) {
            let i3 = null;
            return S.string(e3) ? i3 = Array.from(document.querySelectorAll(e3)) : S.nodeList(e3) ? i3 = Array.from(e3) : S.array(e3) && (i3 = e3.filter(S.element)), S.empty(i3) ? null : i3.map((e4) => new st(e4, t3));
          }
        }
        var nt;
        return st.defaults = (nt = Le, JSON.parse(JSON.stringify(nt))), st;
      });
    }
  });

  // node_modules/photoswipe/dist/photoswipe.esm.js
  var photoswipe_esm_exports = {};
  __export(photoswipe_esm_exports, {
    default: () => PhotoSwipe
  });
  function createElement(className, tagName, appendToEl) {
    const el = document.createElement(tagName);
    if (className) {
      el.className = className;
    }
    if (appendToEl) {
      appendToEl.appendChild(el);
    }
    return el;
  }
  function equalizePoints(p1, p2) {
    p1.x = p2.x;
    p1.y = p2.y;
    if (p2.id !== void 0) {
      p1.id = p2.id;
    }
    return p1;
  }
  function roundPoint(p2) {
    p2.x = Math.round(p2.x);
    p2.y = Math.round(p2.y);
  }
  function getDistanceBetween(p1, p2) {
    const x = Math.abs(p1.x - p2.x);
    const y = Math.abs(p1.y - p2.y);
    return Math.sqrt(x * x + y * y);
  }
  function pointsEqual(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }
  function toTransformString(x, y, scale) {
    let propValue = "translate3d(".concat(x, "px,").concat(y || 0, "px,0)");
    if (scale !== void 0) {
      propValue += " scale3d(".concat(scale, ",").concat(scale, ",1)");
    }
    return propValue;
  }
  function setTransform(el, x, y, scale) {
    el.style.transform = toTransformString(x, y, scale);
  }
  function setTransitionStyle(el, prop, duration, ease) {
    el.style.transition = prop ? "".concat(prop, " ").concat(duration, "ms ").concat(ease || defaultCSSEasing) : "none";
  }
  function setWidthHeight(el, w, h2) {
    el.style.width = typeof w === "number" ? "".concat(w, "px") : w;
    el.style.height = typeof h2 === "number" ? "".concat(h2, "px") : h2;
  }
  function removeTransitionStyle(el) {
    setTransitionStyle(el);
  }
  function decodeImage(img) {
    if ("decode" in img) {
      return img.decode().catch(() => {
      });
    }
    if (img.complete) {
      return Promise.resolve(img);
    }
    return new Promise((resolve, reject) => {
      img.onload = () => resolve(img);
      img.onerror = reject;
    });
  }
  function specialKeyUsed(e2) {
    return "button" in e2 && e2.button === 1 || e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey;
  }
  function getElementsFromOption(option, legacySelector, parent = document) {
    let elements = [];
    if (option instanceof Element) {
      elements = [option];
    } else if (option instanceof NodeList || Array.isArray(option)) {
      elements = Array.from(option);
    } else {
      const selector = typeof option === "string" ? option : legacySelector;
      if (selector) {
        elements = Array.from(parent.querySelectorAll(selector));
      }
    }
    return elements;
  }
  function isSafari() {
    return !!(navigator.vendor && navigator.vendor.match(/apple/i));
  }
  function getViewportSize(options, pswp) {
    if (options.getViewportSizeFn) {
      const newViewportSize = options.getViewportSizeFn(options, pswp);
      if (newViewportSize) {
        return newViewportSize;
      }
    }
    return {
      x: document.documentElement.clientWidth,
      // TODO: height on mobile is very incosistent due to toolbar
      // find a way to improve this
      //
      // document.documentElement.clientHeight - doesn't seem to work well
      y: window.innerHeight
    };
  }
  function parsePaddingOption(prop, options, viewportSize, itemData, index) {
    let paddingValue = 0;
    if (options.paddingFn) {
      paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];
    } else if (options.padding) {
      paddingValue = options.padding[prop];
    } else {
      const legacyPropName = "padding" + prop[0].toUpperCase() + prop.slice(1);
      if (options[legacyPropName]) {
        paddingValue = options[legacyPropName];
      }
    }
    return Number(paddingValue) || 0;
  }
  function getPanAreaSize(options, viewportSize, itemData, index) {
    return {
      x: viewportSize.x - parsePaddingOption("left", options, viewportSize, itemData, index) - parsePaddingOption("right", options, viewportSize, itemData, index),
      y: viewportSize.y - parsePaddingOption("top", options, viewportSize, itemData, index) - parsePaddingOption("bottom", options, viewportSize, itemData, index)
    };
  }
  function project(initialVelocity, decelerationRate) {
    return initialVelocity * decelerationRate / (1 - decelerationRate);
  }
  function getZoomPointsCenter(p2, p1, p22) {
    p2.x = (p1.x + p22.x) / 2;
    p2.y = (p1.y + p22.y) / 2;
    return p2;
  }
  function didTapOnMainContent(event) {
    return !!/** @type {HTMLElement} */
    event.target.closest(".pswp__container");
  }
  function addElementHTML(htmlData) {
    if (typeof htmlData === "string") {
      return htmlData;
    }
    if (!htmlData || !htmlData.isCustomSVG) {
      return "";
    }
    const svgData = htmlData;
    let out = '<svg aria-hidden="true" class="pswp__icn" viewBox="0 0 %d %d" width="%d" height="%d">';
    out = out.split("%d").join(
      /** @type {string} */
      svgData.size || 32
    );
    if (svgData.outlineID) {
      out += '<use class="pswp__icn-shadow" xlink:href="#' + svgData.outlineID + '"/>';
    }
    out += svgData.inner;
    out += "</svg>";
    return out;
  }
  function initArrowButton(element, pswp, isNextButton) {
    element.classList.add("pswp__button--arrow");
    element.setAttribute("aria-controls", "pswp__items");
    pswp.on("change", () => {
      if (!pswp.options.loop) {
        if (isNextButton) {
          element.disabled = !(pswp.currIndex < pswp.getNumItems() - 1);
        } else {
          element.disabled = !(pswp.currIndex > 0);
        }
      }
    });
  }
  function setZoomedIn(el, isZoomedIn) {
    el.classList.toggle("pswp--zoomed-in", isZoomedIn);
  }
  function getBoundsByElement(el) {
    const thumbAreaRect = el.getBoundingClientRect();
    return {
      x: thumbAreaRect.left,
      y: thumbAreaRect.top,
      w: thumbAreaRect.width
    };
  }
  function getCroppedBoundsByElement(el, imageWidth, imageHeight) {
    const thumbAreaRect = el.getBoundingClientRect();
    const hRatio = thumbAreaRect.width / imageWidth;
    const vRatio = thumbAreaRect.height / imageHeight;
    const fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;
    const offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;
    const offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;
    const bounds = {
      x: thumbAreaRect.left + offsetX,
      y: thumbAreaRect.top + offsetY,
      w: imageWidth * fillZoomLevel
    };
    bounds.innerRect = {
      w: thumbAreaRect.width,
      h: thumbAreaRect.height,
      x: offsetX,
      y: offsetY
    };
    return bounds;
  }
  function getThumbBounds(index, itemData, instance) {
    const event = instance.dispatch("thumbBounds", {
      index,
      itemData,
      instance
    });
    if (event.thumbBounds) {
      return event.thumbBounds;
    }
    const {
      element
    } = itemData;
    let thumbBounds;
    let thumbnail;
    if (element && instance.options.thumbSelector !== false) {
      const thumbSelector = instance.options.thumbSelector || "img";
      thumbnail = element.matches(thumbSelector) ? element : (
        /** @type {HTMLElement | null} */
        element.querySelector(thumbSelector)
      );
    }
    thumbnail = instance.applyFilters("thumbEl", thumbnail, itemData, index);
    if (thumbnail) {
      if (!itemData.thumbCropped) {
        thumbBounds = getBoundsByElement(thumbnail);
      } else {
        thumbBounds = getCroppedBoundsByElement(thumbnail, itemData.width || itemData.w || 0, itemData.height || itemData.h || 0);
      }
    }
    return instance.applyFilters("thumbBounds", thumbBounds, itemData, index);
  }
  function lazyLoadData(itemData, instance, index) {
    const content = instance.createContentFromData(itemData, index);
    let zoomLevel;
    const {
      options
    } = instance;
    if (options) {
      zoomLevel = new ZoomLevel(options, itemData, -1);
      let viewportSize;
      if (instance.pswp) {
        viewportSize = instance.pswp.viewportSize;
      } else {
        viewportSize = getViewportSize(options, instance);
      }
      const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);
      zoomLevel.update(content.width, content.height, panAreaSize);
    }
    content.lazyLoad();
    if (zoomLevel) {
      content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial));
    }
    return content;
  }
  function lazyLoadSlide(index, instance) {
    const itemData = instance.getItemData(index);
    if (instance.dispatch("lazyLoadSlide", {
      index,
      itemData
    }).defaultPrevented) {
      return;
    }
    return lazyLoadData(itemData, instance, index);
  }
  var defaultCSSEasing, LOAD_STATE, supportsPassive, DOMEvents, PanBounds, MAX_IMAGE_WIDTH, ZoomLevel, Slide, PAN_END_FRICTION, VERTICAL_DRAG_FRICTION, MIN_RATIO_TO_CLOSE, MIN_NEXT_SLIDE_SPEED, DragHandler, UPPER_ZOOM_FRICTION, LOWER_ZOOM_FRICTION, ZoomHandler, TapHandler, AXIS_SWIPE_HYSTERISIS, DOUBLE_TAP_DELAY, MIN_TAP_DISTANCE, Gestures, MAIN_SCROLL_END_FRICTION, MainScroll, KeyboardKeyCodesMap, getKeyboardEventKey, Keyboard, DEFAULT_EASING, CSSAnimation, DEFAULT_NATURAL_FREQUENCY, DEFAULT_DAMPING_RATIO, SpringEaser, SpringAnimation, Animations, ScrollWheel, UIElement, arrowPrev, arrowNext, closeButton, zoomButton, loadingIndicator, counterIndicator, UI, PhotoSwipeEvent, Eventable, Placeholder, Content, MIN_SLIDES_TO_CACHE, ContentLoader, PhotoSwipeBase, MIN_OPACITY, Opener, defaultOptions, PhotoSwipe;
  var init_photoswipe_esm = __esm({
    "node_modules/photoswipe/dist/photoswipe.esm.js"() {
      defaultCSSEasing = "cubic-bezier(.4,0,.22,1)";
      LOAD_STATE = {
        IDLE: "idle",
        LOADING: "loading",
        LOADED: "loaded",
        ERROR: "error"
      };
      supportsPassive = false;
      try {
        window.addEventListener("test", null, Object.defineProperty({}, "passive", {
          get: () => {
            supportsPassive = true;
          }
        }));
      } catch (e2) {
      }
      DOMEvents = class {
        constructor() {
          this._pool = [];
        }
        /**
         * Adds event listeners
         *
         * @param {PoolItem['target']} target
         * @param {PoolItem['type']} type Can be multiple, separated by space.
         * @param {PoolItem['listener']} listener
         * @param {PoolItem['passive']} [passive]
         */
        add(target, type, listener, passive) {
          this._toggleListener(target, type, listener, passive);
        }
        /**
         * Removes event listeners
         *
         * @param {PoolItem['target']} target
         * @param {PoolItem['type']} type
         * @param {PoolItem['listener']} listener
         * @param {PoolItem['passive']} [passive]
         */
        remove(target, type, listener, passive) {
          this._toggleListener(target, type, listener, passive, true);
        }
        /**
         * Removes all bound events
         */
        removeAll() {
          this._pool.forEach((poolItem) => {
            this._toggleListener(poolItem.target, poolItem.type, poolItem.listener, poolItem.passive, true, true);
          });
          this._pool = [];
        }
        /**
         * Adds or removes event
         *
         * @private
         * @param {PoolItem['target']} target
         * @param {PoolItem['type']} type
         * @param {PoolItem['listener']} listener
         * @param {PoolItem['passive']} [passive]
         * @param {boolean} [unbind] Whether the event should be added or removed
         * @param {boolean} [skipPool] Whether events pool should be skipped
         */
        _toggleListener(target, type, listener, passive, unbind, skipPool) {
          if (!target) {
            return;
          }
          const methodName = unbind ? "removeEventListener" : "addEventListener";
          const types = type.split(" ");
          types.forEach((eType) => {
            if (eType) {
              if (!skipPool) {
                if (unbind) {
                  this._pool = this._pool.filter((poolItem) => {
                    return poolItem.type !== eType || poolItem.listener !== listener || poolItem.target !== target;
                  });
                } else {
                  this._pool.push({
                    target,
                    type: eType,
                    listener,
                    passive
                  });
                }
              }
              const eventOptions = supportsPassive ? {
                passive: passive || false
              } : false;
              target[methodName](eType, listener, eventOptions);
            }
          });
        }
      };
      PanBounds = class {
        /**
         * @param {Slide} slide
         */
        constructor(slide) {
          this.slide = slide;
          this.currZoomLevel = 1;
          this.center = /** @type {Point} */
          {
            x: 0,
            y: 0
          };
          this.max = /** @type {Point} */
          {
            x: 0,
            y: 0
          };
          this.min = /** @type {Point} */
          {
            x: 0,
            y: 0
          };
        }
        /**
         * _getItemBounds
         *
         * @param {number} currZoomLevel
         */
        update(currZoomLevel) {
          this.currZoomLevel = currZoomLevel;
          if (!this.slide.width) {
            this.reset();
          } else {
            this._updateAxis("x");
            this._updateAxis("y");
            this.slide.pswp.dispatch("calcBounds", {
              slide: this.slide
            });
          }
        }
        /**
         * _calculateItemBoundsForAxis
         *
         * @param {Axis} axis
         */
        _updateAxis(axis) {
          const {
            pswp
          } = this.slide;
          const elSize = this.slide[axis === "x" ? "width" : "height"] * this.currZoomLevel;
          const paddingProp = axis === "x" ? "left" : "top";
          const padding = parsePaddingOption(paddingProp, pswp.options, pswp.viewportSize, this.slide.data, this.slide.index);
          const panAreaSize = this.slide.panAreaSize[axis];
          this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding;
          this.max[axis] = elSize > panAreaSize ? Math.round(panAreaSize - elSize) + padding : this.center[axis];
          this.min[axis] = elSize > panAreaSize ? padding : this.center[axis];
        }
        // _getZeroBounds
        reset() {
          this.center.x = 0;
          this.center.y = 0;
          this.max.x = 0;
          this.max.y = 0;
          this.min.x = 0;
          this.min.y = 0;
        }
        /**
         * Correct pan position if it's beyond the bounds
         *
         * @param {Axis} axis x or y
         * @param {number} panOffset
         * @returns {number}
         */
        correctPan(axis, panOffset) {
          return clamp(panOffset, this.max[axis], this.min[axis]);
        }
      };
      MAX_IMAGE_WIDTH = 4e3;
      ZoomLevel = class {
        /**
         * @param {PhotoSwipeOptions} options PhotoSwipe options
         * @param {SlideData} itemData Slide data
         * @param {number} index Slide index
         * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet
         */
        constructor(options, itemData, index, pswp) {
          this.pswp = pswp;
          this.options = options;
          this.itemData = itemData;
          this.index = index;
          this.panAreaSize = null;
          this.elementSize = null;
          this.fit = 1;
          this.fill = 1;
          this.vFill = 1;
          this.initial = 1;
          this.secondary = 1;
          this.max = 1;
          this.min = 1;
        }
        /**
         * Calculate initial, secondary and maximum zoom level for the specified slide.
         *
         * It should be called when either image or viewport size changes.
         *
         * @param {number} maxWidth
         * @param {number} maxHeight
         * @param {Point} panAreaSize
         */
        update(maxWidth, maxHeight, panAreaSize) {
          const elementSize = {
            x: maxWidth,
            y: maxHeight
          };
          this.elementSize = elementSize;
          this.panAreaSize = panAreaSize;
          const hRatio = panAreaSize.x / elementSize.x;
          const vRatio = panAreaSize.y / elementSize.y;
          this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);
          this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio);
          this.vFill = Math.min(1, vRatio);
          this.initial = this._getInitial();
          this.secondary = this._getSecondary();
          this.max = Math.max(this.initial, this.secondary, this._getMax());
          this.min = Math.min(this.fit, this.initial, this.secondary);
          if (this.pswp) {
            this.pswp.dispatch("zoomLevelsUpdate", {
              zoomLevels: this,
              slideData: this.itemData
            });
          }
        }
        /**
         * Parses user-defined zoom option.
         *
         * @private
         * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)
         * @returns { number | undefined }
         */
        _parseZoomLevelOption(optionPrefix) {
          const optionName = (
            /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */
            optionPrefix + "ZoomLevel"
          );
          const optionValue = this.options[optionName];
          if (!optionValue) {
            return;
          }
          if (typeof optionValue === "function") {
            return optionValue(this);
          }
          if (optionValue === "fill") {
            return this.fill;
          }
          if (optionValue === "fit") {
            return this.fit;
          }
          return Number(optionValue);
        }
        /**
         * Get zoom level to which image will be zoomed after double-tap gesture,
         * or when user clicks on zoom icon,
         * or mouse-click on image itself.
         * If you return 1 image will be zoomed to its original size.
         *
         * @private
         * @return {number}
         */
        _getSecondary() {
          let currZoomLevel = this._parseZoomLevelOption("secondary");
          if (currZoomLevel) {
            return currZoomLevel;
          }
          currZoomLevel = Math.min(1, this.fit * 3);
          if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {
            currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;
          }
          return currZoomLevel;
        }
        /**
         * Get initial image zoom level.
         *
         * @private
         * @return {number}
         */
        _getInitial() {
          return this._parseZoomLevelOption("initial") || this.fit;
        }
        /**
         * Maximum zoom level when user zooms
         * via zoom/pinch gesture,
         * via cmd/ctrl-wheel or via trackpad.
         *
         * @private
         * @return {number}
         */
        _getMax() {
          return this._parseZoomLevelOption("max") || Math.max(1, this.fit * 4);
        }
      };
      Slide = class {
        /**
         * @param {SlideData} data
         * @param {number} index
         * @param {PhotoSwipe} pswp
         */
        constructor(data, index, pswp) {
          this.data = data;
          this.index = index;
          this.pswp = pswp;
          this.isActive = index === pswp.currIndex;
          this.currentResolution = 0;
          this.panAreaSize = {
            x: 0,
            y: 0
          };
          this.pan = {
            x: 0,
            y: 0
          };
          this.isFirstSlide = this.isActive && !pswp.opener.isOpen;
          this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);
          this.pswp.dispatch("gettingData", {
            slide: this,
            data: this.data,
            index
          });
          this.content = this.pswp.contentLoader.getContentBySlide(this);
          this.container = createElement("pswp__zoom-wrap", "div");
          this.holderElement = null;
          this.currZoomLevel = 1;
          this.width = this.content.width;
          this.height = this.content.height;
          this.heavyAppended = false;
          this.bounds = new PanBounds(this);
          this.prevDisplayedWidth = -1;
          this.prevDisplayedHeight = -1;
          this.pswp.dispatch("slideInit", {
            slide: this
          });
        }
        /**
         * If this slide is active/current/visible
         *
         * @param {boolean} isActive
         */
        setIsActive(isActive) {
          if (isActive && !this.isActive) {
            this.activate();
          } else if (!isActive && this.isActive) {
            this.deactivate();
          }
        }
        /**
         * Appends slide content to DOM
         *
         * @param {HTMLElement} holderElement
         */
        append(holderElement) {
          this.holderElement = holderElement;
          this.container.style.transformOrigin = "0 0";
          if (!this.data) {
            return;
          }
          this.calculateSize();
          this.load();
          this.updateContentSize();
          this.appendHeavy();
          this.holderElement.appendChild(this.container);
          this.zoomAndPanToInitial();
          this.pswp.dispatch("firstZoomPan", {
            slide: this
          });
          this.applyCurrentZoomPan();
          this.pswp.dispatch("afterSetContent", {
            slide: this
          });
          if (this.isActive) {
            this.activate();
          }
        }
        load() {
          this.content.load(false);
          this.pswp.dispatch("slideLoad", {
            slide: this
          });
        }
        /**
         * Append "heavy" DOM elements
         *
         * This may depend on a type of slide,
         * but generally these are large images.
         */
        appendHeavy() {
          const {
            pswp
          } = this;
          const appendHeavyNearby = true;
          if (this.heavyAppended || !pswp.opener.isOpen || pswp.mainScroll.isShifted() || !this.isActive && !appendHeavyNearby) {
            return;
          }
          if (this.pswp.dispatch("appendHeavy", {
            slide: this
          }).defaultPrevented) {
            return;
          }
          this.heavyAppended = true;
          this.content.append();
          this.pswp.dispatch("appendHeavyContent", {
            slide: this
          });
        }
        /**
         * Triggered when this slide is active (selected).
         *
         * If it's part of opening/closing transition -
         * activate() will trigger after the transition is ended.
         */
        activate() {
          this.isActive = true;
          this.appendHeavy();
          this.content.activate();
          this.pswp.dispatch("slideActivate", {
            slide: this
          });
        }
        /**
         * Triggered when this slide becomes inactive.
         *
         * Slide can become inactive only after it was active.
         */
        deactivate() {
          this.isActive = false;
          this.content.deactivate();
          if (this.currZoomLevel !== this.zoomLevels.initial) {
            this.calculateSize();
          }
          this.currentResolution = 0;
          this.zoomAndPanToInitial();
          this.applyCurrentZoomPan();
          this.updateContentSize();
          this.pswp.dispatch("slideDeactivate", {
            slide: this
          });
        }
        /**
         * The slide should destroy itself, it will never be used again.
         * (unbind all events and destroy internal components)
         */
        destroy() {
          this.content.hasSlide = false;
          this.content.remove();
          this.container.remove();
          this.pswp.dispatch("slideDestroy", {
            slide: this
          });
        }
        resize() {
          if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {
            this.calculateSize();
            this.currentResolution = 0;
            this.zoomAndPanToInitial();
            this.applyCurrentZoomPan();
            this.updateContentSize();
          } else {
            this.calculateSize();
            this.bounds.update(this.currZoomLevel);
            this.panTo(this.pan.x, this.pan.y);
          }
        }
        /**
         * Apply size to current slide content,
         * based on the current resolution and scale.
         *
         * @param {boolean} [force] if size should be updated even if dimensions weren't changed
         */
        updateContentSize(force) {
          const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;
          if (!scaleMultiplier) {
            return;
          }
          const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;
          const height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;
          if (!this.sizeChanged(width, height) && !force) {
            return;
          }
          this.content.setDisplayedSize(width, height);
        }
        /**
         * @param {number} width
         * @param {number} height
         */
        sizeChanged(width, height) {
          if (width !== this.prevDisplayedWidth || height !== this.prevDisplayedHeight) {
            this.prevDisplayedWidth = width;
            this.prevDisplayedHeight = height;
            return true;
          }
          return false;
        }
        /** @returns {HTMLImageElement | HTMLDivElement | null | undefined} */
        getPlaceholderElement() {
          var _this$content$placeho;
          return (_this$content$placeho = this.content.placeholder) === null || _this$content$placeho === void 0 ? void 0 : _this$content$placeho.element;
        }
        /**
         * Zoom current slide image to...
         *
         * @param {number} destZoomLevel Destination zoom level.
         * @param {Point} [centerPoint]
         * Transform origin center point, or false if viewport center should be used.
         * @param {number | false} [transitionDuration] Transition duration, may be set to 0.
         * @param {boolean} [ignoreBounds] Minimum and maximum zoom levels will be ignored.
         */
        zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {
          const {
            pswp
          } = this;
          if (!this.isZoomable() || pswp.mainScroll.isShifted()) {
            return;
          }
          pswp.dispatch("beforeZoomTo", {
            destZoomLevel,
            centerPoint,
            transitionDuration
          });
          pswp.animations.stopAllPan();
          const prevZoomLevel = this.currZoomLevel;
          if (!ignoreBounds) {
            destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);
          }
          this.setZoomLevel(destZoomLevel);
          this.pan.x = this.calculateZoomToPanOffset("x", centerPoint, prevZoomLevel);
          this.pan.y = this.calculateZoomToPanOffset("y", centerPoint, prevZoomLevel);
          roundPoint(this.pan);
          const finishTransition = () => {
            this._setResolution(destZoomLevel);
            this.applyCurrentZoomPan();
          };
          if (!transitionDuration) {
            finishTransition();
          } else {
            pswp.animations.startTransition({
              isPan: true,
              name: "zoomTo",
              target: this.container,
              transform: this.getCurrentTransform(),
              onComplete: finishTransition,
              duration: transitionDuration,
              easing: pswp.options.easing
            });
          }
        }
        /**
         * @param {Point} [centerPoint]
         */
        toggleZoom(centerPoint) {
          this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, centerPoint, this.pswp.options.zoomAnimationDuration);
        }
        /**
         * Updates zoom level property and recalculates new pan bounds,
         * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)
         *
         * @param {number} currZoomLevel
         */
        setZoomLevel(currZoomLevel) {
          this.currZoomLevel = currZoomLevel;
          this.bounds.update(this.currZoomLevel);
        }
        /**
         * Get pan position after zoom at a given `point`.
         *
         * Always call setZoomLevel(newZoomLevel) beforehand to recalculate
         * pan bounds according to the new zoom level.
         *
         * @param {'x' | 'y'} axis
         * @param {Point} [point]
         * point based on which zoom is performed, usually refers to the current mouse position,
         * if false - viewport center will be used.
         * @param {number} [prevZoomLevel] Zoom level before new zoom was applied.
         * @returns {number}
         */
        calculateZoomToPanOffset(axis, point, prevZoomLevel) {
          const totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];
          if (totalPanDistance === 0) {
            return this.bounds.center[axis];
          }
          if (!point) {
            point = this.pswp.getViewportCenterPoint();
          }
          if (!prevZoomLevel) {
            prevZoomLevel = this.zoomLevels.initial;
          }
          const zoomFactor = this.currZoomLevel / prevZoomLevel;
          return this.bounds.correctPan(axis, (this.pan[axis] - point[axis]) * zoomFactor + point[axis]);
        }
        /**
         * Apply pan and keep it within bounds.
         *
         * @param {number} panX
         * @param {number} panY
         */
        panTo(panX, panY) {
          this.pan.x = this.bounds.correctPan("x", panX);
          this.pan.y = this.bounds.correctPan("y", panY);
          this.applyCurrentZoomPan();
        }
        /**
         * If the slide in the current state can be panned by the user
         * @returns {boolean}
         */
        isPannable() {
          return Boolean(this.width) && this.currZoomLevel > this.zoomLevels.fit;
        }
        /**
         * If the slide can be zoomed
         * @returns {boolean}
         */
        isZoomable() {
          return Boolean(this.width) && this.content.isZoomable();
        }
        /**
         * Apply transform and scale based on
         * the current pan position (this.pan) and zoom level (this.currZoomLevel)
         */
        applyCurrentZoomPan() {
          this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);
          if (this === this.pswp.currSlide) {
            this.pswp.dispatch("zoomPanUpdate", {
              slide: this
            });
          }
        }
        zoomAndPanToInitial() {
          this.currZoomLevel = this.zoomLevels.initial;
          this.bounds.update(this.currZoomLevel);
          equalizePoints(this.pan, this.bounds.center);
          this.pswp.dispatch("initialZoomPan", {
            slide: this
          });
        }
        /**
         * Set translate and scale based on current resolution
         *
         * @param {number} x
         * @param {number} y
         * @param {number} zoom
         * @private
         */
        _applyZoomTransform(x, y, zoom) {
          zoom /= this.currentResolution || this.zoomLevels.initial;
          setTransform(this.container, x, y, zoom);
        }
        calculateSize() {
          const {
            pswp
          } = this;
          equalizePoints(this.panAreaSize, getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index));
          this.zoomLevels.update(this.width, this.height, this.panAreaSize);
          pswp.dispatch("calcSlideSize", {
            slide: this
          });
        }
        /** @returns {string} */
        getCurrentTransform() {
          const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);
          return toTransformString(this.pan.x, this.pan.y, scale);
        }
        /**
         * Set resolution and re-render the image.
         *
         * For example, if the real image size is 2000x1500,
         * and resolution is 0.5 - it will be rendered as 1000x750.
         *
         * Image with zoom level 2 and resolution 0.5 is
         * the same as image with zoom level 1 and resolution 1.
         *
         * Used to optimize animations and make
         * sure that browser renders image in the highest quality.
         * Also used by responsive images to load the correct one.
         *
         * @param {number} newResolution
         */
        _setResolution(newResolution) {
          if (newResolution === this.currentResolution) {
            return;
          }
          this.currentResolution = newResolution;
          this.updateContentSize();
          this.pswp.dispatch("resolutionChanged");
        }
      };
      PAN_END_FRICTION = 0.35;
      VERTICAL_DRAG_FRICTION = 0.6;
      MIN_RATIO_TO_CLOSE = 0.4;
      MIN_NEXT_SLIDE_SPEED = 0.5;
      DragHandler = class {
        /**
         * @param {Gestures} gestures
         */
        constructor(gestures) {
          this.gestures = gestures;
          this.pswp = gestures.pswp;
          this.startPan = {
            x: 0,
            y: 0
          };
        }
        start() {
          if (this.pswp.currSlide) {
            equalizePoints(this.startPan, this.pswp.currSlide.pan);
          }
          this.pswp.animations.stopAll();
        }
        change() {
          const {
            p1,
            prevP1,
            dragAxis
          } = this.gestures;
          const {
            currSlide
          } = this.pswp;
          if (dragAxis === "y" && this.pswp.options.closeOnVerticalDrag && currSlide && currSlide.currZoomLevel <= currSlide.zoomLevels.fit && !this.gestures.isMultitouch) {
            const panY = currSlide.pan.y + (p1.y - prevP1.y);
            if (!this.pswp.dispatch("verticalDrag", {
              panY
            }).defaultPrevented) {
              this._setPanWithFriction("y", panY, VERTICAL_DRAG_FRICTION);
              const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));
              this.pswp.applyBgOpacity(bgOpacity);
              currSlide.applyCurrentZoomPan();
            }
          } else {
            const mainScrollChanged = this._panOrMoveMainScroll("x");
            if (!mainScrollChanged) {
              this._panOrMoveMainScroll("y");
              if (currSlide) {
                roundPoint(currSlide.pan);
                currSlide.applyCurrentZoomPan();
              }
            }
          }
        }
        end() {
          const {
            velocity
          } = this.gestures;
          const {
            mainScroll,
            currSlide
          } = this.pswp;
          let indexDiff = 0;
          this.pswp.animations.stopAll();
          if (mainScroll.isShifted()) {
            const mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX();
            const currentSlideVisibilityRatio = mainScrollShiftDiff / this.pswp.viewportSize.x;
            if (velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0 || velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5) {
              indexDiff = 1;
              velocity.x = Math.min(velocity.x, 0);
            } else if (velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0 || velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5) {
              indexDiff = -1;
              velocity.x = Math.max(velocity.x, 0);
            }
            mainScroll.moveIndexBy(indexDiff, true, velocity.x);
          }
          if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.max || this.gestures.isMultitouch) {
            this.gestures.zoomLevels.correctZoomPan(true);
          } else {
            this._finishPanGestureForAxis("x");
            this._finishPanGestureForAxis("y");
          }
        }
        /**
         * @private
         * @param {'x' | 'y'} axis
         */
        _finishPanGestureForAxis(axis) {
          const {
            velocity
          } = this.gestures;
          const {
            currSlide
          } = this.pswp;
          if (!currSlide) {
            return;
          }
          const {
            pan,
            bounds
          } = currSlide;
          const panPos = pan[axis];
          const restoreBgOpacity = this.pswp.bgOpacity < 1 && axis === "y";
          const decelerationRate = 0.995;
          const projectedPosition = panPos + project(velocity[axis], decelerationRate);
          if (restoreBgOpacity) {
            const vDragRatio = this._getVerticalDragRatio(panPos);
            const projectedVDragRatio = this._getVerticalDragRatio(projectedPosition);
            if (vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE || vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE) {
              this.pswp.close();
              return;
            }
          }
          const correctedPanPosition = bounds.correctPan(axis, projectedPosition);
          if (panPos === correctedPanPosition) {
            return;
          }
          const dampingRatio = correctedPanPosition === projectedPosition ? 1 : 0.82;
          const initialBgOpacity = this.pswp.bgOpacity;
          const totalPanDist = correctedPanPosition - panPos;
          this.pswp.animations.startSpring({
            name: "panGesture" + axis,
            isPan: true,
            start: panPos,
            end: correctedPanPosition,
            velocity: velocity[axis],
            dampingRatio,
            onUpdate: (pos) => {
              if (restoreBgOpacity && this.pswp.bgOpacity < 1) {
                const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist;
                this.pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio, 0, 1));
              }
              pan[axis] = Math.floor(pos);
              currSlide.applyCurrentZoomPan();
            }
          });
        }
        /**
         * Update position of the main scroll,
         * or/and update pan position of the current slide.
         *
         * Should return true if it changes (or can change) main scroll.
         *
         * @private
         * @param {'x' | 'y'} axis
         * @returns {boolean}
         */
        _panOrMoveMainScroll(axis) {
          const {
            p1,
            dragAxis,
            prevP1,
            isMultitouch
          } = this.gestures;
          const {
            currSlide,
            mainScroll
          } = this.pswp;
          const delta = p1[axis] - prevP1[axis];
          const newMainScrollX = mainScroll.x + delta;
          if (!delta || !currSlide) {
            return false;
          }
          if (axis === "x" && !currSlide.isPannable() && !isMultitouch) {
            mainScroll.moveTo(newMainScrollX, true);
            return true;
          }
          const {
            bounds
          } = currSlide;
          const newPan = currSlide.pan[axis] + delta;
          if (this.pswp.options.allowPanToNext && dragAxis === "x" && axis === "x" && !isMultitouch) {
            const currSlideMainScrollX = mainScroll.getCurrSlideX();
            const mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;
            const isLeftToRight = delta > 0;
            const isRightToLeft = !isLeftToRight;
            if (newPan > bounds.min[axis] && isLeftToRight) {
              const wasAtMinPanPosition = bounds.min[axis] <= this.startPan[axis];
              if (wasAtMinPanPosition) {
                mainScroll.moveTo(newMainScrollX, true);
                return true;
              } else {
                this._setPanWithFriction(axis, newPan);
              }
            } else if (newPan < bounds.max[axis] && isRightToLeft) {
              const wasAtMaxPanPosition = this.startPan[axis] <= bounds.max[axis];
              if (wasAtMaxPanPosition) {
                mainScroll.moveTo(newMainScrollX, true);
                return true;
              } else {
                this._setPanWithFriction(axis, newPan);
              }
            } else {
              if (mainScrollShiftDiff !== 0) {
                if (mainScrollShiftDiff > 0) {
                  mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);
                  return true;
                } else if (mainScrollShiftDiff < 0) {
                  mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);
                  return true;
                }
              } else {
                this._setPanWithFriction(axis, newPan);
              }
            }
          } else {
            if (axis === "y") {
              if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {
                this._setPanWithFriction(axis, newPan);
              }
            } else {
              this._setPanWithFriction(axis, newPan);
            }
          }
          return false;
        }
        // If we move above - the ratio is negative
        // If we move below the ratio is positive
        /**
         * Relation between pan Y position and third of viewport height.
         *
         * When we are at initial position (center bounds) - the ratio is 0,
         * if position is shifted upwards - the ratio is negative,
         * if position is shifted downwards - the ratio is positive.
         *
         * @private
         * @param {number} panY The current pan Y position.
         * @returns {number}
         */
        _getVerticalDragRatio(panY) {
          var _this$pswp$currSlide$, _this$pswp$currSlide;
          return (panY - ((_this$pswp$currSlide$ = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.bounds.center.y) !== null && _this$pswp$currSlide$ !== void 0 ? _this$pswp$currSlide$ : 0)) / (this.pswp.viewportSize.y / 3);
        }
        /**
         * Set pan position of the current slide.
         * Apply friction if the position is beyond the pan bounds,
         * or if custom friction is defined.
         *
         * @private
         * @param {'x' | 'y'} axis
         * @param {number} potentialPan
         * @param {number} [customFriction] (0.1 - 1)
         */
        _setPanWithFriction(axis, potentialPan, customFriction) {
          const {
            currSlide
          } = this.pswp;
          if (!currSlide) {
            return;
          }
          const {
            pan,
            bounds
          } = currSlide;
          const correctedPan = bounds.correctPan(axis, potentialPan);
          if (correctedPan !== potentialPan || customFriction) {
            const delta = Math.round(potentialPan - pan[axis]);
            pan[axis] += delta * (customFriction || PAN_END_FRICTION);
          } else {
            pan[axis] = potentialPan;
          }
        }
      };
      UPPER_ZOOM_FRICTION = 0.05;
      LOWER_ZOOM_FRICTION = 0.15;
      ZoomHandler = class {
        /**
         * @param {Gestures} gestures
         */
        constructor(gestures) {
          this.gestures = gestures;
          this._startPan = {
            x: 0,
            y: 0
          };
          this._startZoomPoint = {
            x: 0,
            y: 0
          };
          this._zoomPoint = {
            x: 0,
            y: 0
          };
          this._wasOverFitZoomLevel = false;
          this._startZoomLevel = 1;
        }
        start() {
          const {
            currSlide
          } = this.gestures.pswp;
          if (currSlide) {
            this._startZoomLevel = currSlide.currZoomLevel;
            equalizePoints(this._startPan, currSlide.pan);
          }
          this.gestures.pswp.animations.stopAllPan();
          this._wasOverFitZoomLevel = false;
        }
        change() {
          const {
            p1,
            startP1,
            p2,
            startP2,
            pswp
          } = this.gestures;
          const {
            currSlide
          } = pswp;
          if (!currSlide) {
            return;
          }
          const minZoomLevel = currSlide.zoomLevels.min;
          const maxZoomLevel = currSlide.zoomLevels.max;
          if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {
            return;
          }
          getZoomPointsCenter(this._startZoomPoint, startP1, startP2);
          getZoomPointsCenter(this._zoomPoint, p1, p2);
          let currZoomLevel = 1 / getDistanceBetween(startP1, startP2) * getDistanceBetween(p1, p2) * this._startZoomLevel;
          if (currZoomLevel > currSlide.zoomLevels.initial + currSlide.zoomLevels.initial / 15) {
            this._wasOverFitZoomLevel = true;
          }
          if (currZoomLevel < minZoomLevel) {
            if (pswp.options.pinchToClose && !this._wasOverFitZoomLevel && this._startZoomLevel <= currSlide.zoomLevels.initial) {
              const bgOpacity = 1 - (minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2);
              if (!pswp.dispatch("pinchClose", {
                bgOpacity
              }).defaultPrevented) {
                pswp.applyBgOpacity(bgOpacity);
              }
            } else {
              currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;
            }
          } else if (currZoomLevel > maxZoomLevel) {
            currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;
          }
          currSlide.pan.x = this._calculatePanForZoomLevel("x", currZoomLevel);
          currSlide.pan.y = this._calculatePanForZoomLevel("y", currZoomLevel);
          currSlide.setZoomLevel(currZoomLevel);
          currSlide.applyCurrentZoomPan();
        }
        end() {
          const {
            pswp
          } = this.gestures;
          const {
            currSlide
          } = pswp;
          if ((!currSlide || currSlide.currZoomLevel < currSlide.zoomLevels.initial) && !this._wasOverFitZoomLevel && pswp.options.pinchToClose) {
            pswp.close();
          } else {
            this.correctZoomPan();
          }
        }
        /**
         * @private
         * @param {'x' | 'y'} axis
         * @param {number} currZoomLevel
         * @returns {number}
         */
        _calculatePanForZoomLevel(axis, currZoomLevel) {
          const zoomFactor = currZoomLevel / this._startZoomLevel;
          return this._zoomPoint[axis] - (this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor;
        }
        /**
         * Correct currZoomLevel and pan if they are
         * beyond minimum or maximum values.
         * With animation.
         *
         * @param {boolean} [ignoreGesture]
         * Wether gesture coordinates should be ignored when calculating destination pan position.
         */
        correctZoomPan(ignoreGesture) {
          const {
            pswp
          } = this.gestures;
          const {
            currSlide
          } = pswp;
          if (!(currSlide !== null && currSlide !== void 0 && currSlide.isZoomable())) {
            return;
          }
          if (this._zoomPoint.x === 0) {
            ignoreGesture = true;
          }
          const prevZoomLevel = currSlide.currZoomLevel;
          let destinationZoomLevel;
          let currZoomLevelNeedsChange = true;
          if (prevZoomLevel < currSlide.zoomLevels.initial) {
            destinationZoomLevel = currSlide.zoomLevels.initial;
          } else if (prevZoomLevel > currSlide.zoomLevels.max) {
            destinationZoomLevel = currSlide.zoomLevels.max;
          } else {
            currZoomLevelNeedsChange = false;
            destinationZoomLevel = prevZoomLevel;
          }
          const initialBgOpacity = pswp.bgOpacity;
          const restoreBgOpacity = pswp.bgOpacity < 1;
          const initialPan = equalizePoints({
            x: 0,
            y: 0
          }, currSlide.pan);
          let destinationPan = equalizePoints({
            x: 0,
            y: 0
          }, initialPan);
          if (ignoreGesture) {
            this._zoomPoint.x = 0;
            this._zoomPoint.y = 0;
            this._startZoomPoint.x = 0;
            this._startZoomPoint.y = 0;
            this._startZoomLevel = prevZoomLevel;
            equalizePoints(this._startPan, initialPan);
          }
          if (currZoomLevelNeedsChange) {
            destinationPan = {
              x: this._calculatePanForZoomLevel("x", destinationZoomLevel),
              y: this._calculatePanForZoomLevel("y", destinationZoomLevel)
            };
          }
          currSlide.setZoomLevel(destinationZoomLevel);
          destinationPan = {
            x: currSlide.bounds.correctPan("x", destinationPan.x),
            y: currSlide.bounds.correctPan("y", destinationPan.y)
          };
          currSlide.setZoomLevel(prevZoomLevel);
          const panNeedsChange = !pointsEqual(destinationPan, initialPan);
          if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {
            currSlide._setResolution(destinationZoomLevel);
            currSlide.applyCurrentZoomPan();
            return;
          }
          pswp.animations.stopAllPan();
          pswp.animations.startSpring({
            isPan: true,
            start: 0,
            end: 1e3,
            velocity: 0,
            dampingRatio: 1,
            naturalFrequency: 40,
            onUpdate: (now) => {
              now /= 1e3;
              if (panNeedsChange || currZoomLevelNeedsChange) {
                if (panNeedsChange) {
                  currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;
                  currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;
                }
                if (currZoomLevelNeedsChange) {
                  const newZoomLevel = prevZoomLevel + (destinationZoomLevel - prevZoomLevel) * now;
                  currSlide.setZoomLevel(newZoomLevel);
                }
                currSlide.applyCurrentZoomPan();
              }
              if (restoreBgOpacity && pswp.bgOpacity < 1) {
                pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1));
              }
            },
            onComplete: () => {
              currSlide._setResolution(destinationZoomLevel);
              currSlide.applyCurrentZoomPan();
            }
          });
        }
      };
      TapHandler = class {
        /**
         * @param {Gestures} gestures
         */
        constructor(gestures) {
          this.gestures = gestures;
        }
        /**
         * @param {Point} point
         * @param {PointerEvent} originalEvent
         */
        click(point, originalEvent) {
          const targetClassList = (
            /** @type {HTMLElement} */
            originalEvent.target.classList
          );
          const isImageClick = targetClassList.contains("pswp__img");
          const isBackgroundClick = targetClassList.contains("pswp__item") || targetClassList.contains("pswp__zoom-wrap");
          if (isImageClick) {
            this._doClickOrTapAction("imageClick", point, originalEvent);
          } else if (isBackgroundClick) {
            this._doClickOrTapAction("bgClick", point, originalEvent);
          }
        }
        /**
         * @param {Point} point
         * @param {PointerEvent} originalEvent
         */
        tap(point, originalEvent) {
          if (didTapOnMainContent(originalEvent)) {
            this._doClickOrTapAction("tap", point, originalEvent);
          }
        }
        /**
         * @param {Point} point
         * @param {PointerEvent} originalEvent
         */
        doubleTap(point, originalEvent) {
          if (didTapOnMainContent(originalEvent)) {
            this._doClickOrTapAction("doubleTap", point, originalEvent);
          }
        }
        /**
         * @private
         * @param {Actions} actionName
         * @param {Point} point
         * @param {PointerEvent} originalEvent
         */
        _doClickOrTapAction(actionName, point, originalEvent) {
          var _this$gestures$pswp$e;
          const {
            pswp
          } = this.gestures;
          const {
            currSlide
          } = pswp;
          const actionFullName = (
            /** @type {AddPostfix<Actions, 'Action'>} */
            actionName + "Action"
          );
          const optionValue = pswp.options[actionFullName];
          if (pswp.dispatch(actionFullName, {
            point,
            originalEvent
          }).defaultPrevented) {
            return;
          }
          if (typeof optionValue === "function") {
            optionValue.call(pswp, point, originalEvent);
            return;
          }
          switch (optionValue) {
            case "close":
            case "next":
              pswp[optionValue]();
              break;
            case "zoom":
              currSlide === null || currSlide === void 0 || currSlide.toggleZoom(point);
              break;
            case "zoom-or-close":
              if (currSlide !== null && currSlide !== void 0 && currSlide.isZoomable() && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {
                currSlide.toggleZoom(point);
              } else if (pswp.options.clickToCloseNonZoomable) {
                pswp.close();
              }
              break;
            case "toggle-controls":
              (_this$gestures$pswp$e = this.gestures.pswp.element) === null || _this$gestures$pswp$e === void 0 || _this$gestures$pswp$e.classList.toggle("pswp--ui-visible");
              break;
          }
        }
      };
      AXIS_SWIPE_HYSTERISIS = 10;
      DOUBLE_TAP_DELAY = 300;
      MIN_TAP_DISTANCE = 25;
      Gestures = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          this.dragAxis = null;
          this.p1 = {
            x: 0,
            y: 0
          };
          this.p2 = {
            x: 0,
            y: 0
          };
          this.prevP1 = {
            x: 0,
            y: 0
          };
          this.prevP2 = {
            x: 0,
            y: 0
          };
          this.startP1 = {
            x: 0,
            y: 0
          };
          this.startP2 = {
            x: 0,
            y: 0
          };
          this.velocity = {
            x: 0,
            y: 0
          };
          this._lastStartP1 = {
            x: 0,
            y: 0
          };
          this._intervalP1 = {
            x: 0,
            y: 0
          };
          this._numActivePoints = 0;
          this._ongoingPointers = [];
          this._touchEventEnabled = "ontouchstart" in window;
          this._pointerEventEnabled = !!window.PointerEvent;
          this.supportsTouch = this._touchEventEnabled || this._pointerEventEnabled && navigator.maxTouchPoints > 1;
          this._numActivePoints = 0;
          this._intervalTime = 0;
          this._velocityCalculated = false;
          this.isMultitouch = false;
          this.isDragging = false;
          this.isZooming = false;
          this.raf = null;
          this._tapTimer = null;
          if (!this.supportsTouch) {
            pswp.options.allowPanToNext = false;
          }
          this.drag = new DragHandler(this);
          this.zoomLevels = new ZoomHandler(this);
          this.tapHandler = new TapHandler(this);
          pswp.on("bindEvents", () => {
            pswp.events.add(
              pswp.scrollWrap,
              "click",
              /** @type EventListener */
              this._onClick.bind(this)
            );
            if (this._pointerEventEnabled) {
              this._bindEvents("pointer", "down", "up", "cancel");
            } else if (this._touchEventEnabled) {
              this._bindEvents("touch", "start", "end", "cancel");
              if (pswp.scrollWrap) {
                pswp.scrollWrap.ontouchmove = () => {
                };
                pswp.scrollWrap.ontouchend = () => {
                };
              }
            } else {
              this._bindEvents("mouse", "down", "up");
            }
          });
        }
        /**
         * @private
         * @param {'mouse' | 'touch' | 'pointer'} pref
         * @param {'down' | 'start'} down
         * @param {'up' | 'end'} up
         * @param {'cancel'} [cancel]
         */
        _bindEvents(pref, down, up, cancel) {
          const {
            pswp
          } = this;
          const {
            events
          } = pswp;
          const cancelEvent = cancel ? pref + cancel : "";
          events.add(
            pswp.scrollWrap,
            pref + down,
            /** @type EventListener */
            this.onPointerDown.bind(this)
          );
          events.add(
            window,
            pref + "move",
            /** @type EventListener */
            this.onPointerMove.bind(this)
          );
          events.add(
            window,
            pref + up,
            /** @type EventListener */
            this.onPointerUp.bind(this)
          );
          if (cancelEvent) {
            events.add(
              pswp.scrollWrap,
              cancelEvent,
              /** @type EventListener */
              this.onPointerUp.bind(this)
            );
          }
        }
        /**
         * @param {PointerEvent} e
         */
        onPointerDown(e2) {
          const isMousePointer = e2.type === "mousedown" || e2.pointerType === "mouse";
          if (isMousePointer && e2.button > 0) {
            return;
          }
          const {
            pswp
          } = this;
          if (!pswp.opener.isOpen) {
            e2.preventDefault();
            return;
          }
          if (pswp.dispatch("pointerDown", {
            originalEvent: e2
          }).defaultPrevented) {
            return;
          }
          if (isMousePointer) {
            pswp.mouseDetected();
            this._preventPointerEventBehaviour(e2, "down");
          }
          pswp.animations.stopAll();
          this._updatePoints(e2, "down");
          if (this._numActivePoints === 1) {
            this.dragAxis = null;
            equalizePoints(this.startP1, this.p1);
          }
          if (this._numActivePoints > 1) {
            this._clearTapTimer();
            this.isMultitouch = true;
          } else {
            this.isMultitouch = false;
          }
        }
        /**
         * @param {PointerEvent} e
         */
        onPointerMove(e2) {
          this._preventPointerEventBehaviour(e2, "move");
          if (!this._numActivePoints) {
            return;
          }
          this._updatePoints(e2, "move");
          if (this.pswp.dispatch("pointerMove", {
            originalEvent: e2
          }).defaultPrevented) {
            return;
          }
          if (this._numActivePoints === 1 && !this.isDragging) {
            if (!this.dragAxis) {
              this._calculateDragDirection();
            }
            if (this.dragAxis && !this.isDragging) {
              if (this.isZooming) {
                this.isZooming = false;
                this.zoomLevels.end();
              }
              this.isDragging = true;
              this._clearTapTimer();
              this._updateStartPoints();
              this._intervalTime = Date.now();
              this._velocityCalculated = false;
              equalizePoints(this._intervalP1, this.p1);
              this.velocity.x = 0;
              this.velocity.y = 0;
              this.drag.start();
              this._rafStopLoop();
              this._rafRenderLoop();
            }
          } else if (this._numActivePoints > 1 && !this.isZooming) {
            this._finishDrag();
            this.isZooming = true;
            this._updateStartPoints();
            this.zoomLevels.start();
            this._rafStopLoop();
            this._rafRenderLoop();
          }
        }
        /**
         * @private
         */
        _finishDrag() {
          if (this.isDragging) {
            this.isDragging = false;
            if (!this._velocityCalculated) {
              this._updateVelocity(true);
            }
            this.drag.end();
            this.dragAxis = null;
          }
        }
        /**
         * @param {PointerEvent} e
         */
        onPointerUp(e2) {
          if (!this._numActivePoints) {
            return;
          }
          this._updatePoints(e2, "up");
          if (this.pswp.dispatch("pointerUp", {
            originalEvent: e2
          }).defaultPrevented) {
            return;
          }
          if (this._numActivePoints === 0) {
            this._rafStopLoop();
            if (this.isDragging) {
              this._finishDrag();
            } else if (!this.isZooming && !this.isMultitouch) {
              this._finishTap(e2);
            }
          }
          if (this._numActivePoints < 2 && this.isZooming) {
            this.isZooming = false;
            this.zoomLevels.end();
            if (this._numActivePoints === 1) {
              this.dragAxis = null;
              this._updateStartPoints();
            }
          }
        }
        /**
         * @private
         */
        _rafRenderLoop() {
          if (this.isDragging || this.isZooming) {
            this._updateVelocity();
            if (this.isDragging) {
              if (!pointsEqual(this.p1, this.prevP1)) {
                this.drag.change();
              }
            } else {
              if (!pointsEqual(this.p1, this.prevP1) || !pointsEqual(this.p2, this.prevP2)) {
                this.zoomLevels.change();
              }
            }
            this._updatePrevPoints();
            this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));
          }
        }
        /**
         * Update velocity at 50ms interval
         *
         * @private
         * @param {boolean} [force]
         */
        _updateVelocity(force) {
          const time = Date.now();
          const duration = time - this._intervalTime;
          if (duration < 50 && !force) {
            return;
          }
          this.velocity.x = this._getVelocity("x", duration);
          this.velocity.y = this._getVelocity("y", duration);
          this._intervalTime = time;
          equalizePoints(this._intervalP1, this.p1);
          this._velocityCalculated = true;
        }
        /**
         * @private
         * @param {PointerEvent} e
         */
        _finishTap(e2) {
          const {
            mainScroll
          } = this.pswp;
          if (mainScroll.isShifted()) {
            mainScroll.moveIndexBy(0, true);
            return;
          }
          if (e2.type.indexOf("cancel") > 0) {
            return;
          }
          if (e2.type === "mouseup" || e2.pointerType === "mouse") {
            this.tapHandler.click(this.startP1, e2);
            return;
          }
          const tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0;
          if (this._tapTimer) {
            this._clearTapTimer();
            if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {
              this.tapHandler.doubleTap(this.startP1, e2);
            }
          } else {
            equalizePoints(this._lastStartP1, this.startP1);
            this._tapTimer = setTimeout(() => {
              this.tapHandler.tap(this.startP1, e2);
              this._clearTapTimer();
            }, tapDelay);
          }
        }
        /**
         * @private
         */
        _clearTapTimer() {
          if (this._tapTimer) {
            clearTimeout(this._tapTimer);
            this._tapTimer = null;
          }
        }
        /**
         * Get velocity for axis
         *
         * @private
         * @param {'x' | 'y'} axis
         * @param {number} duration
         * @returns {number}
         */
        _getVelocity(axis, duration) {
          const displacement = this.p1[axis] - this._intervalP1[axis];
          if (Math.abs(displacement) > 1 && duration > 5) {
            return displacement / duration;
          }
          return 0;
        }
        /**
         * @private
         */
        _rafStopLoop() {
          if (this.raf) {
            cancelAnimationFrame(this.raf);
            this.raf = null;
          }
        }
        /**
         * @private
         * @param {PointerEvent} e
         * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
         */
        _preventPointerEventBehaviour(e2, pointerType) {
          const preventPointerEvent = this.pswp.applyFilters("preventPointerEvent", true, e2, pointerType);
          if (preventPointerEvent) {
            e2.preventDefault();
          }
        }
        /**
         * Parses and normalizes points from the touch, mouse or pointer event.
         * Updates p1 and p2.
         *
         * @private
         * @param {PointerEvent | TouchEvent} e
         * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type
         */
        _updatePoints(e2, pointerType) {
          if (this._pointerEventEnabled) {
            const pointerEvent = (
              /** @type {PointerEvent} */
              e2
            );
            const pointerIndex = this._ongoingPointers.findIndex((ongoingPointer) => {
              return ongoingPointer.id === pointerEvent.pointerId;
            });
            if (pointerType === "up" && pointerIndex > -1) {
              this._ongoingPointers.splice(pointerIndex, 1);
            } else if (pointerType === "down" && pointerIndex === -1) {
              this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, {
                x: 0,
                y: 0
              }));
            } else if (pointerIndex > -1) {
              this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);
            }
            this._numActivePoints = this._ongoingPointers.length;
            if (this._numActivePoints > 0) {
              equalizePoints(this.p1, this._ongoingPointers[0]);
            }
            if (this._numActivePoints > 1) {
              equalizePoints(this.p2, this._ongoingPointers[1]);
            }
          } else {
            const touchEvent = (
              /** @type {TouchEvent} */
              e2
            );
            this._numActivePoints = 0;
            if (touchEvent.type.indexOf("touch") > -1) {
              if (touchEvent.touches && touchEvent.touches.length > 0) {
                this._convertEventPosToPoint(touchEvent.touches[0], this.p1);
                this._numActivePoints++;
                if (touchEvent.touches.length > 1) {
                  this._convertEventPosToPoint(touchEvent.touches[1], this.p2);
                  this._numActivePoints++;
                }
              }
            } else {
              this._convertEventPosToPoint(
                /** @type {PointerEvent} */
                e2,
                this.p1
              );
              if (pointerType === "up") {
                this._numActivePoints = 0;
              } else {
                this._numActivePoints++;
              }
            }
          }
        }
        /** update points that were used during previous rAF tick
         * @private
         */
        _updatePrevPoints() {
          equalizePoints(this.prevP1, this.p1);
          equalizePoints(this.prevP2, this.p2);
        }
        /** update points at the start of gesture
         * @private
         */
        _updateStartPoints() {
          equalizePoints(this.startP1, this.p1);
          equalizePoints(this.startP2, this.p2);
          this._updatePrevPoints();
        }
        /** @private */
        _calculateDragDirection() {
          if (this.pswp.mainScroll.isShifted()) {
            this.dragAxis = "x";
          } else {
            const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);
            if (diff !== 0) {
              const axisToCheck = diff > 0 ? "x" : "y";
              if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {
                this.dragAxis = axisToCheck;
              }
            }
          }
        }
        /**
         * Converts touch, pointer or mouse event
         * to PhotoSwipe point.
         *
         * @private
         * @param {Touch | PointerEvent} e
         * @param {Point} p
         * @returns {Point}
         */
        _convertEventPosToPoint(e2, p2) {
          p2.x = e2.pageX - this.pswp.offset.x;
          p2.y = e2.pageY - this.pswp.offset.y;
          if ("pointerId" in e2) {
            p2.id = e2.pointerId;
          } else if (e2.identifier !== void 0) {
            p2.id = e2.identifier;
          }
          return p2;
        }
        /**
         * @private
         * @param {PointerEvent} e
         */
        _onClick(e2) {
          if (this.pswp.mainScroll.isShifted()) {
            e2.preventDefault();
            e2.stopPropagation();
          }
        }
      };
      MAIN_SCROLL_END_FRICTION = 0.35;
      MainScroll = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          this.x = 0;
          this.slideWidth = 0;
          this._currPositionIndex = 0;
          this._prevPositionIndex = 0;
          this._containerShiftIndex = -1;
          this.itemHolders = [];
        }
        /**
         * Position the scroller and slide containers
         * according to viewport size.
         *
         * @param {boolean} [resizeSlides] Whether slides content should resized
         */
        resize(resizeSlides) {
          const {
            pswp
          } = this;
          const newSlideWidth = Math.round(pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing);
          const slideWidthChanged = newSlideWidth !== this.slideWidth;
          if (slideWidthChanged) {
            this.slideWidth = newSlideWidth;
            this.moveTo(this.getCurrSlideX());
          }
          this.itemHolders.forEach((itemHolder, index) => {
            if (slideWidthChanged) {
              setTransform(itemHolder.el, (index + this._containerShiftIndex) * this.slideWidth);
            }
            if (resizeSlides && itemHolder.slide) {
              itemHolder.slide.resize();
            }
          });
        }
        /**
         * Reset X position of the main scroller to zero
         */
        resetPosition() {
          this._currPositionIndex = 0;
          this._prevPositionIndex = 0;
          this.slideWidth = 0;
          this._containerShiftIndex = -1;
        }
        /**
         * Create and append array of three items
         * that hold data about slides in DOM
         */
        appendHolders() {
          this.itemHolders = [];
          for (let i2 = 0; i2 < 3; i2++) {
            const el = createElement("pswp__item", "div", this.pswp.container);
            el.setAttribute("role", "group");
            el.setAttribute("aria-roledescription", "slide");
            el.setAttribute("aria-hidden", "true");
            el.style.display = i2 === 1 ? "block" : "none";
            this.itemHolders.push({
              el
              //index: -1
            });
          }
        }
        /**
         * Whether the main scroll can be horizontally swiped to the next or previous slide.
         * @returns {boolean}
         */
        canBeSwiped() {
          return this.pswp.getNumItems() > 1;
        }
        /**
         * Move main scroll by X amount of slides.
         * For example:
         *   `-1` will move to the previous slide,
         *    `0` will reset the scroll position of the current slide,
         *    `3` will move three slides forward
         *
         * If loop option is enabled - index will be automatically looped too,
         * (for example `-1` will move to the last slide of the gallery).
         *
         * @param {number} diff
         * @param {boolean} [animate]
         * @param {number} [velocityX]
         * @returns {boolean} whether index was changed or not
         */
        moveIndexBy(diff, animate, velocityX) {
          const {
            pswp
          } = this;
          let newIndex = pswp.potentialIndex + diff;
          const numSlides = pswp.getNumItems();
          if (pswp.canLoop()) {
            newIndex = pswp.getLoopedIndex(newIndex);
            const distance = (diff + numSlides) % numSlides;
            if (distance <= numSlides / 2) {
              diff = distance;
            } else {
              diff = distance - numSlides;
            }
          } else {
            if (newIndex < 0) {
              newIndex = 0;
            } else if (newIndex >= numSlides) {
              newIndex = numSlides - 1;
            }
            diff = newIndex - pswp.potentialIndex;
          }
          pswp.potentialIndex = newIndex;
          this._currPositionIndex -= diff;
          pswp.animations.stopMainScroll();
          const destinationX = this.getCurrSlideX();
          if (!animate) {
            this.moveTo(destinationX);
            this.updateCurrItem();
          } else {
            pswp.animations.startSpring({
              isMainScroll: true,
              start: this.x,
              end: destinationX,
              velocity: velocityX || 0,
              naturalFrequency: 30,
              dampingRatio: 1,
              //0.7,
              onUpdate: (x) => {
                this.moveTo(x);
              },
              onComplete: () => {
                this.updateCurrItem();
                pswp.appendHeavy();
              }
            });
            let currDiff = pswp.potentialIndex - pswp.currIndex;
            if (pswp.canLoop()) {
              const currDistance = (currDiff + numSlides) % numSlides;
              if (currDistance <= numSlides / 2) {
                currDiff = currDistance;
              } else {
                currDiff = currDistance - numSlides;
              }
            }
            if (Math.abs(currDiff) > 1) {
              this.updateCurrItem();
            }
          }
          return Boolean(diff);
        }
        /**
         * X position of the main scroll for the current slide
         * (ignores position during dragging)
         * @returns {number}
         */
        getCurrSlideX() {
          return this.slideWidth * this._currPositionIndex;
        }
        /**
         * Whether scroll position is shifted.
         * For example, it will return true if the scroll is being dragged or animated.
         * @returns {boolean}
         */
        isShifted() {
          return this.x !== this.getCurrSlideX();
        }
        /**
         * Update slides X positions and set their content
         */
        updateCurrItem() {
          var _this$itemHolders$;
          const {
            pswp
          } = this;
          const positionDifference = this._prevPositionIndex - this._currPositionIndex;
          if (!positionDifference) {
            return;
          }
          this._prevPositionIndex = this._currPositionIndex;
          pswp.currIndex = pswp.potentialIndex;
          let diffAbs = Math.abs(positionDifference);
          let tempHolder;
          if (diffAbs >= 3) {
            this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);
            diffAbs = 3;
            this.itemHolders.forEach((itemHolder) => {
              var _itemHolder$slide;
              (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.destroy();
              itemHolder.slide = void 0;
            });
          }
          for (let i2 = 0; i2 < diffAbs; i2++) {
            if (positionDifference > 0) {
              tempHolder = this.itemHolders.shift();
              if (tempHolder) {
                this.itemHolders[2] = tempHolder;
                this._containerShiftIndex++;
                setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);
                pswp.setContent(tempHolder, pswp.currIndex - diffAbs + i2 + 2);
              }
            } else {
              tempHolder = this.itemHolders.pop();
              if (tempHolder) {
                this.itemHolders.unshift(tempHolder);
                this._containerShiftIndex--;
                setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);
                pswp.setContent(tempHolder, pswp.currIndex + diffAbs - i2 - 2);
              }
            }
          }
          if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {
            this.resetPosition();
            this.resize();
          }
          pswp.animations.stopAllPan();
          this.itemHolders.forEach((itemHolder, i2) => {
            if (itemHolder.slide) {
              itemHolder.slide.setIsActive(i2 === 1);
            }
          });
          pswp.currSlide = (_this$itemHolders$ = this.itemHolders[1]) === null || _this$itemHolders$ === void 0 ? void 0 : _this$itemHolders$.slide;
          pswp.contentLoader.updateLazy(positionDifference);
          if (pswp.currSlide) {
            pswp.currSlide.applyCurrentZoomPan();
          }
          pswp.dispatch("change");
        }
        /**
         * Move the X position of the main scroll container
         *
         * @param {number} x
         * @param {boolean} [dragging]
         */
        moveTo(x, dragging) {
          if (!this.pswp.canLoop() && dragging) {
            let newSlideIndexOffset = (this.slideWidth * this._currPositionIndex - x) / this.slideWidth;
            newSlideIndexOffset += this.pswp.currIndex;
            const delta = Math.round(x - this.x);
            if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0) {
              x = this.x + delta * MAIN_SCROLL_END_FRICTION;
            }
          }
          this.x = x;
          if (this.pswp.container) {
            setTransform(this.pswp.container, x);
          }
          this.pswp.dispatch("moveMainScroll", {
            x,
            dragging: dragging !== null && dragging !== void 0 ? dragging : false
          });
        }
      };
      KeyboardKeyCodesMap = {
        Escape: 27,
        z: 90,
        ArrowLeft: 37,
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        Tab: 9
      };
      getKeyboardEventKey = (key, isKeySupported) => {
        return isKeySupported ? key : KeyboardKeyCodesMap[key];
      };
      Keyboard = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          this._wasFocused = false;
          pswp.on("bindEvents", () => {
            if (pswp.options.trapFocus) {
              if (!pswp.options.initialPointerPos) {
                this._focusRoot();
              }
              pswp.events.add(
                document,
                "focusin",
                /** @type EventListener */
                this._onFocusIn.bind(this)
              );
            }
            pswp.events.add(
              document,
              "keydown",
              /** @type EventListener */
              this._onKeyDown.bind(this)
            );
          });
          const lastActiveElement = (
            /** @type {HTMLElement} */
            document.activeElement
          );
          pswp.on("destroy", () => {
            if (pswp.options.returnFocus && lastActiveElement && this._wasFocused) {
              lastActiveElement.focus();
            }
          });
        }
        /** @private */
        _focusRoot() {
          if (!this._wasFocused && this.pswp.element) {
            this.pswp.element.focus();
            this._wasFocused = true;
          }
        }
        /**
         * @private
         * @param {KeyboardEvent} e
         */
        _onKeyDown(e2) {
          const {
            pswp
          } = this;
          if (pswp.dispatch("keydown", {
            originalEvent: e2
          }).defaultPrevented) {
            return;
          }
          if (specialKeyUsed(e2)) {
            return;
          }
          let keydownAction;
          let axis;
          let isForward = false;
          const isKeySupported = "key" in e2;
          switch (isKeySupported ? e2.key : e2.keyCode) {
            case getKeyboardEventKey("Escape", isKeySupported):
              if (pswp.options.escKey) {
                keydownAction = "close";
              }
              break;
            case getKeyboardEventKey("z", isKeySupported):
              keydownAction = "toggleZoom";
              break;
            case getKeyboardEventKey("ArrowLeft", isKeySupported):
              axis = "x";
              break;
            case getKeyboardEventKey("ArrowUp", isKeySupported):
              axis = "y";
              break;
            case getKeyboardEventKey("ArrowRight", isKeySupported):
              axis = "x";
              isForward = true;
              break;
            case getKeyboardEventKey("ArrowDown", isKeySupported):
              isForward = true;
              axis = "y";
              break;
            case getKeyboardEventKey("Tab", isKeySupported):
              this._focusRoot();
              break;
          }
          if (axis) {
            e2.preventDefault();
            const {
              currSlide
            } = pswp;
            if (pswp.options.arrowKeys && axis === "x" && pswp.getNumItems() > 1) {
              keydownAction = isForward ? "next" : "prev";
            } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {
              currSlide.pan[axis] += isForward ? -80 : 80;
              currSlide.panTo(currSlide.pan.x, currSlide.pan.y);
            }
          }
          if (keydownAction) {
            e2.preventDefault();
            pswp[keydownAction]();
          }
        }
        /**
         * Trap focus inside photoswipe
         *
         * @private
         * @param {FocusEvent} e
         */
        _onFocusIn(e2) {
          const {
            template
          } = this.pswp;
          if (template && document !== e2.target && template !== e2.target && !template.contains(
            /** @type {Node} */
            e2.target
          )) {
            template.focus();
          }
        }
      };
      DEFAULT_EASING = "cubic-bezier(.4,0,.22,1)";
      CSSAnimation = class {
        /**
         * onComplete can be unpredictable, be careful about current state
         *
         * @param {CssAnimationProps} props
         */
        constructor(props) {
          var _props$prop;
          this.props = props;
          const {
            target,
            onComplete,
            transform,
            onFinish = () => {
            },
            duration = 333,
            easing = DEFAULT_EASING
          } = props;
          this.onFinish = onFinish;
          const prop = transform ? "transform" : "opacity";
          const propValue = (_props$prop = props[prop]) !== null && _props$prop !== void 0 ? _props$prop : "";
          this._target = target;
          this._onComplete = onComplete;
          this._finished = false;
          this._onTransitionEnd = this._onTransitionEnd.bind(this);
          this._helperTimeout = setTimeout(() => {
            setTransitionStyle(target, prop, duration, easing);
            this._helperTimeout = setTimeout(() => {
              target.addEventListener("transitionend", this._onTransitionEnd, false);
              target.addEventListener("transitioncancel", this._onTransitionEnd, false);
              this._helperTimeout = setTimeout(() => {
                this._finalizeAnimation();
              }, duration + 500);
              target.style[prop] = propValue;
            }, 30);
          }, 0);
        }
        /**
         * @private
         * @param {TransitionEvent} e
         */
        _onTransitionEnd(e2) {
          if (e2.target === this._target) {
            this._finalizeAnimation();
          }
        }
        /**
         * @private
         */
        _finalizeAnimation() {
          if (!this._finished) {
            this._finished = true;
            this.onFinish();
            if (this._onComplete) {
              this._onComplete();
            }
          }
        }
        // Destroy is called automatically onFinish
        destroy() {
          if (this._helperTimeout) {
            clearTimeout(this._helperTimeout);
          }
          removeTransitionStyle(this._target);
          this._target.removeEventListener("transitionend", this._onTransitionEnd, false);
          this._target.removeEventListener("transitioncancel", this._onTransitionEnd, false);
          if (!this._finished) {
            this._finalizeAnimation();
          }
        }
      };
      DEFAULT_NATURAL_FREQUENCY = 12;
      DEFAULT_DAMPING_RATIO = 0.75;
      SpringEaser = class {
        /**
         * @param {number} initialVelocity Initial velocity, px per ms.
         *
         * @param {number} [dampingRatio]
         * Determines how bouncy animation will be.
         * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.
         * "overshoot" refers to part of animation that
         * goes beyond the final value.
         *
         * @param {number} [naturalFrequency]
         * Determines how fast animation will slow down.
         * The higher value - the stiffer the transition will be,
         * and the faster it will slow down.
         * Recommended value from 10 to 50
         */
        constructor(initialVelocity, dampingRatio, naturalFrequency) {
          this.velocity = initialVelocity * 1e3;
          this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO;
          this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;
          this._dampedFrequency = this._naturalFrequency;
          if (this._dampingRatio < 1) {
            this._dampedFrequency *= Math.sqrt(1 - this._dampingRatio * this._dampingRatio);
          }
        }
        /**
         * @param {number} deltaPosition Difference between current and end position of the animation
         * @param {number} deltaTime Frame duration in milliseconds
         *
         * @returns {number} Displacement, relative to the end position.
         */
        easeFrame(deltaPosition, deltaTime) {
          let displacement = 0;
          let coeff;
          deltaTime /= 1e3;
          const naturalDumpingPow = __pow(Math.E, -this._dampingRatio * this._naturalFrequency * deltaTime);
          if (this._dampingRatio === 1) {
            coeff = this.velocity + this._naturalFrequency * deltaPosition;
            displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;
            this.velocity = displacement * -this._naturalFrequency + coeff * naturalDumpingPow;
          } else if (this._dampingRatio < 1) {
            coeff = 1 / this._dampedFrequency * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);
            const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);
            const dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);
            displacement = naturalDumpingPow * (deltaPosition * dumpedFCos + coeff * dumpedFSin);
            this.velocity = displacement * -this._naturalFrequency * this._dampingRatio + naturalDumpingPow * (-this._dampedFrequency * deltaPosition * dumpedFSin + this._dampedFrequency * coeff * dumpedFCos);
          }
          return displacement;
        }
      };
      SpringAnimation = class {
        /**
         * @param {SpringAnimationProps} props
         */
        constructor(props) {
          this.props = props;
          this._raf = 0;
          const {
            start,
            end,
            velocity,
            onUpdate,
            onComplete,
            onFinish = () => {
            },
            dampingRatio,
            naturalFrequency
          } = props;
          this.onFinish = onFinish;
          const easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);
          let prevTime = Date.now();
          let deltaPosition = start - end;
          const animationLoop = () => {
            if (this._raf) {
              deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime);
              if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {
                onUpdate(end);
                if (onComplete) {
                  onComplete();
                }
                this.onFinish();
              } else {
                prevTime = Date.now();
                onUpdate(deltaPosition + end);
                this._raf = requestAnimationFrame(animationLoop);
              }
            }
          };
          this._raf = requestAnimationFrame(animationLoop);
        }
        // Destroy is called automatically onFinish
        destroy() {
          if (this._raf >= 0) {
            cancelAnimationFrame(this._raf);
          }
          this._raf = 0;
        }
      };
      Animations = class {
        constructor() {
          this.activeAnimations = [];
        }
        /**
         * @param {SpringAnimationProps} props
         */
        startSpring(props) {
          this._start(props, true);
        }
        /**
         * @param {CssAnimationProps} props
         */
        startTransition(props) {
          this._start(props);
        }
        /**
         * @private
         * @param {AnimationProps} props
         * @param {boolean} [isSpring]
         * @returns {Animation}
         */
        _start(props, isSpring) {
          const animation = isSpring ? new SpringAnimation(
            /** @type SpringAnimationProps */
            props
          ) : new CSSAnimation(
            /** @type CssAnimationProps */
            props
          );
          this.activeAnimations.push(animation);
          animation.onFinish = () => this.stop(animation);
          return animation;
        }
        /**
         * @param {Animation} animation
         */
        stop(animation) {
          animation.destroy();
          const index = this.activeAnimations.indexOf(animation);
          if (index > -1) {
            this.activeAnimations.splice(index, 1);
          }
        }
        stopAll() {
          this.activeAnimations.forEach((animation) => {
            animation.destroy();
          });
          this.activeAnimations = [];
        }
        /**
         * Stop all pan or zoom transitions
         */
        stopAllPan() {
          this.activeAnimations = this.activeAnimations.filter((animation) => {
            if (animation.props.isPan) {
              animation.destroy();
              return false;
            }
            return true;
          });
        }
        stopMainScroll() {
          this.activeAnimations = this.activeAnimations.filter((animation) => {
            if (animation.props.isMainScroll) {
              animation.destroy();
              return false;
            }
            return true;
          });
        }
        /**
         * Returns true if main scroll transition is running
         */
        // isMainScrollRunning() {
        //   return this.activeAnimations.some((animation) => {
        //     return animation.props.isMainScroll;
        //   });
        // }
        /**
         * Returns true if any pan or zoom transition is running
         */
        isPanRunning() {
          return this.activeAnimations.some((animation) => {
            return animation.props.isPan;
          });
        }
      };
      ScrollWheel = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          pswp.events.add(
            pswp.element,
            "wheel",
            /** @type EventListener */
            this._onWheel.bind(this)
          );
        }
        /**
         * @private
         * @param {WheelEvent} e
         */
        _onWheel(e2) {
          e2.preventDefault();
          const {
            currSlide
          } = this.pswp;
          let {
            deltaX,
            deltaY
          } = e2;
          if (!currSlide) {
            return;
          }
          if (this.pswp.dispatch("wheel", {
            originalEvent: e2
          }).defaultPrevented) {
            return;
          }
          if (e2.ctrlKey || this.pswp.options.wheelToZoom) {
            if (currSlide.isZoomable()) {
              let zoomFactor = -deltaY;
              if (e2.deltaMode === 1) {
                zoomFactor *= 0.05;
              } else {
                zoomFactor *= e2.deltaMode ? 1 : 2e-3;
              }
              zoomFactor = __pow(2, zoomFactor);
              const destZoomLevel = currSlide.currZoomLevel * zoomFactor;
              currSlide.zoomTo(destZoomLevel, {
                x: e2.clientX,
                y: e2.clientY
              });
            }
          } else {
            if (currSlide.isPannable()) {
              if (e2.deltaMode === 1) {
                deltaX *= 18;
                deltaY *= 18;
              }
              currSlide.panTo(currSlide.pan.x - deltaX, currSlide.pan.y - deltaY);
            }
          }
        }
      };
      UIElement = class {
        /**
         * @param {PhotoSwipe} pswp
         * @param {UIElementData} data
         */
        constructor(pswp, data) {
          var _container;
          const name = data.name || data.className;
          let elementHTML = data.html;
          if (pswp.options[name] === false) {
            return;
          }
          if (typeof pswp.options[name + "SVG"] === "string") {
            elementHTML = pswp.options[name + "SVG"];
          }
          pswp.dispatch("uiElementCreate", {
            data
          });
          let className = "";
          if (data.isButton) {
            className += "pswp__button ";
            className += data.className || "pswp__button--".concat(data.name);
          } else {
            className += data.className || "pswp__".concat(data.name);
          }
          let tagName = data.isButton ? data.tagName || "button" : data.tagName || "div";
          tagName = /** @type {keyof HTMLElementTagNameMap} */
          tagName.toLowerCase();
          const element = createElement(className, tagName);
          if (data.isButton) {
            if (tagName === "button") {
              element.type = "button";
            }
            let {
              title
            } = data;
            const {
              ariaLabel
            } = data;
            if (typeof pswp.options[name + "Title"] === "string") {
              title = pswp.options[name + "Title"];
            }
            if (title) {
              element.title = title;
            }
            const ariaText = ariaLabel || title;
            if (ariaText) {
              element.setAttribute("aria-label", ariaText);
            }
          }
          element.innerHTML = addElementHTML(elementHTML);
          if (data.onInit) {
            data.onInit(element, pswp);
          }
          if (data.onClick) {
            element.onclick = (e2) => {
              if (typeof data.onClick === "string") {
                pswp[data.onClick]();
              } else if (typeof data.onClick === "function") {
                data.onClick(e2, element, pswp);
              }
            };
          }
          const appendTo = data.appendTo || "bar";
          let container = pswp.element;
          if (appendTo === "bar") {
            if (!pswp.topBar) {
              pswp.topBar = createElement("pswp__top-bar pswp__hide-on-close", "div", pswp.scrollWrap);
            }
            container = pswp.topBar;
          } else {
            element.classList.add("pswp__hide-on-close");
            if (appendTo === "wrapper") {
              container = pswp.scrollWrap;
            }
          }
          (_container = container) === null || _container === void 0 || _container.appendChild(pswp.applyFilters("uiElement", element, data));
        }
      };
      arrowPrev = {
        name: "arrowPrev",
        className: "pswp__button--arrow--prev",
        title: "Previous",
        order: 10,
        isButton: true,
        appendTo: "wrapper",
        html: {
          isCustomSVG: true,
          size: 60,
          inner: '<path d="M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z" id="pswp__icn-arrow"/>',
          outlineID: "pswp__icn-arrow"
        },
        onClick: "prev",
        onInit: initArrowButton
      };
      arrowNext = {
        name: "arrowNext",
        className: "pswp__button--arrow--next",
        title: "Next",
        order: 11,
        isButton: true,
        appendTo: "wrapper",
        html: {
          isCustomSVG: true,
          size: 60,
          inner: '<use xlink:href="#pswp__icn-arrow"/>',
          outlineID: "pswp__icn-arrow"
        },
        onClick: "next",
        onInit: (el, pswp) => {
          initArrowButton(el, pswp, true);
        }
      };
      closeButton = {
        name: "close",
        title: "Close",
        order: 20,
        isButton: true,
        html: {
          isCustomSVG: true,
          inner: '<path d="M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z" id="pswp__icn-close"/>',
          outlineID: "pswp__icn-close"
        },
        onClick: "close"
      };
      zoomButton = {
        name: "zoom",
        title: "Zoom",
        order: 10,
        isButton: true,
        html: {
          isCustomSVG: true,
          // eslint-disable-next-line max-len
          inner: '<path d="M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z" id="pswp__icn-zoom"/><path fill="currentColor" class="pswp__zoom-icn-bar-h" d="M11 16v-2h6v2z"/><path fill="currentColor" class="pswp__zoom-icn-bar-v" d="M13 12h2v6h-2z"/>',
          outlineID: "pswp__icn-zoom"
        },
        onClick: "toggleZoom"
      };
      loadingIndicator = {
        name: "preloader",
        appendTo: "bar",
        order: 7,
        html: {
          isCustomSVG: true,
          // eslint-disable-next-line max-len
          inner: '<path fill-rule="evenodd" clip-rule="evenodd" d="M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z" id="pswp__icn-loading"/>',
          outlineID: "pswp__icn-loading"
        },
        onInit: (indicatorElement, pswp) => {
          let isVisible;
          let delayTimeout = null;
          const toggleIndicatorClass = (className, add) => {
            indicatorElement.classList.toggle("pswp__preloader--" + className, add);
          };
          const setIndicatorVisibility = (visible) => {
            if (isVisible !== visible) {
              isVisible = visible;
              toggleIndicatorClass("active", visible);
            }
          };
          const updatePreloaderVisibility = () => {
            var _pswp$currSlide;
            if (!((_pswp$currSlide = pswp.currSlide) !== null && _pswp$currSlide !== void 0 && _pswp$currSlide.content.isLoading())) {
              setIndicatorVisibility(false);
              if (delayTimeout) {
                clearTimeout(delayTimeout);
                delayTimeout = null;
              }
              return;
            }
            if (!delayTimeout) {
              delayTimeout = setTimeout(() => {
                var _pswp$currSlide2;
                setIndicatorVisibility(Boolean((_pswp$currSlide2 = pswp.currSlide) === null || _pswp$currSlide2 === void 0 ? void 0 : _pswp$currSlide2.content.isLoading()));
                delayTimeout = null;
              }, pswp.options.preloaderDelay);
            }
          };
          pswp.on("change", updatePreloaderVisibility);
          pswp.on("loadComplete", (e2) => {
            if (pswp.currSlide === e2.slide) {
              updatePreloaderVisibility();
            }
          });
          if (pswp.ui) {
            pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;
          }
        }
      };
      counterIndicator = {
        name: "counter",
        order: 5,
        onInit: (counterElement, pswp) => {
          pswp.on("change", () => {
            counterElement.innerText = pswp.currIndex + 1 + pswp.options.indexIndicatorSep + pswp.getNumItems();
          });
        }
      };
      UI = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          this.isRegistered = false;
          this.uiElementsData = [];
          this.items = [];
          this.updatePreloaderVisibility = () => {
          };
          this._lastUpdatedZoomLevel = void 0;
        }
        init() {
          const {
            pswp
          } = this;
          this.isRegistered = false;
          this.uiElementsData = [closeButton, arrowPrev, arrowNext, zoomButton, loadingIndicator, counterIndicator];
          pswp.dispatch("uiRegister");
          this.uiElementsData.sort((a2, b) => {
            return (a2.order || 0) - (b.order || 0);
          });
          this.items = [];
          this.isRegistered = true;
          this.uiElementsData.forEach((uiElementData) => {
            this.registerElement(uiElementData);
          });
          pswp.on("change", () => {
            var _pswp$element;
            (_pswp$element = pswp.element) === null || _pswp$element === void 0 || _pswp$element.classList.toggle("pswp--one-slide", pswp.getNumItems() === 1);
          });
          pswp.on("zoomPanUpdate", () => this._onZoomPanUpdate());
        }
        /**
         * @param {UIElementData} elementData
         */
        registerElement(elementData) {
          if (this.isRegistered) {
            this.items.push(new UIElement(this.pswp, elementData));
          } else {
            this.uiElementsData.push(elementData);
          }
        }
        /**
         * Fired each time zoom or pan position is changed.
         * Update classes that control visibility of zoom button and cursor icon.
         *
         * @private
         */
        _onZoomPanUpdate() {
          const {
            template,
            currSlide,
            options
          } = this.pswp;
          if (this.pswp.opener.isClosing || !template || !currSlide) {
            return;
          }
          let {
            currZoomLevel
          } = currSlide;
          if (!this.pswp.opener.isOpen) {
            currZoomLevel = currSlide.zoomLevels.initial;
          }
          if (currZoomLevel === this._lastUpdatedZoomLevel) {
            return;
          }
          this._lastUpdatedZoomLevel = currZoomLevel;
          const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary;
          if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {
            setZoomedIn(template, false);
            template.classList.remove("pswp--zoom-allowed");
            return;
          }
          template.classList.add("pswp--zoom-allowed");
          const potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;
          setZoomedIn(template, potentialZoomLevel <= currZoomLevel);
          if (options.imageClickAction === "zoom" || options.imageClickAction === "zoom-or-close") {
            template.classList.add("pswp--click-to-zoom");
          }
        }
      };
      PhotoSwipeEvent = class {
        /**
         * @param {T} type
         * @param {PhotoSwipeEventsMap[T]} [details]
         */
        constructor(type, details) {
          this.type = type;
          this.defaultPrevented = false;
          if (details) {
            Object.assign(this, details);
          }
        }
        preventDefault() {
          this.defaultPrevented = true;
        }
      };
      Eventable = class {
        constructor() {
          this._listeners = {};
          this._filters = {};
          this.pswp = void 0;
          this.options = void 0;
        }
        /**
         * @template {keyof PhotoSwipeFiltersMap} T
         * @param {T} name
         * @param {PhotoSwipeFiltersMap[T]} fn
         * @param {number} priority
         */
        addFilter(name, fn, priority = 100) {
          var _this$_filters$name, _this$_filters$name2, _this$pswp;
          if (!this._filters[name]) {
            this._filters[name] = [];
          }
          (_this$_filters$name = this._filters[name]) === null || _this$_filters$name === void 0 || _this$_filters$name.push({
            fn,
            priority
          });
          (_this$_filters$name2 = this._filters[name]) === null || _this$_filters$name2 === void 0 || _this$_filters$name2.sort((f1, f2) => f1.priority - f2.priority);
          (_this$pswp = this.pswp) === null || _this$pswp === void 0 || _this$pswp.addFilter(name, fn, priority);
        }
        /**
         * @template {keyof PhotoSwipeFiltersMap} T
         * @param {T} name
         * @param {PhotoSwipeFiltersMap[T]} fn
         */
        removeFilter(name, fn) {
          if (this._filters[name]) {
            this._filters[name] = this._filters[name].filter((filter) => filter.fn !== fn);
          }
          if (this.pswp) {
            this.pswp.removeFilter(name, fn);
          }
        }
        /**
         * @template {keyof PhotoSwipeFiltersMap} T
         * @param {T} name
         * @param {Parameters<PhotoSwipeFiltersMap[T]>} args
         * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}
         */
        applyFilters(name, ...args) {
          var _this$_filters$name3;
          (_this$_filters$name3 = this._filters[name]) === null || _this$_filters$name3 === void 0 || _this$_filters$name3.forEach((filter) => {
            args[0] = filter.fn.apply(this, args);
          });
          return args[0];
        }
        /**
         * @template {keyof PhotoSwipeEventsMap} T
         * @param {T} name
         * @param {EventCallback<T>} fn
         */
        on(name, fn) {
          var _this$_listeners$name, _this$pswp2;
          if (!this._listeners[name]) {
            this._listeners[name] = [];
          }
          (_this$_listeners$name = this._listeners[name]) === null || _this$_listeners$name === void 0 || _this$_listeners$name.push(fn);
          (_this$pswp2 = this.pswp) === null || _this$pswp2 === void 0 || _this$pswp2.on(name, fn);
        }
        /**
         * @template {keyof PhotoSwipeEventsMap} T
         * @param {T} name
         * @param {EventCallback<T>} fn
         */
        off(name, fn) {
          var _this$pswp3;
          if (this._listeners[name]) {
            this._listeners[name] = this._listeners[name].filter((listener) => fn !== listener);
          }
          (_this$pswp3 = this.pswp) === null || _this$pswp3 === void 0 || _this$pswp3.off(name, fn);
        }
        /**
         * @template {keyof PhotoSwipeEventsMap} T
         * @param {T} name
         * @param {PhotoSwipeEventsMap[T]} [details]
         * @returns {AugmentedEvent<T>}
         */
        dispatch(name, details) {
          var _this$_listeners$name2;
          if (this.pswp) {
            return this.pswp.dispatch(name, details);
          }
          const event = (
            /** @type {AugmentedEvent<T>} */
            new PhotoSwipeEvent(name, details)
          );
          (_this$_listeners$name2 = this._listeners[name]) === null || _this$_listeners$name2 === void 0 || _this$_listeners$name2.forEach((listener) => {
            listener.call(this, event);
          });
          return event;
        }
      };
      Placeholder = class {
        /**
         * @param {string | false} imageSrc
         * @param {HTMLElement} container
         */
        constructor(imageSrc, container) {
          this.element = createElement("pswp__img pswp__img--placeholder", imageSrc ? "img" : "div", container);
          if (imageSrc) {
            const imgEl = (
              /** @type {HTMLImageElement} */
              this.element
            );
            imgEl.decoding = "async";
            imgEl.alt = "";
            imgEl.src = imageSrc;
            imgEl.setAttribute("role", "presentation");
          }
          this.element.setAttribute("aria-hidden", "true");
        }
        /**
         * @param {number} width
         * @param {number} height
         */
        setDisplayedSize(width, height) {
          if (!this.element) {
            return;
          }
          if (this.element.tagName === "IMG") {
            setWidthHeight(this.element, 250, "auto");
            this.element.style.transformOrigin = "0 0";
            this.element.style.transform = toTransformString(0, 0, width / 250);
          } else {
            setWidthHeight(this.element, width, height);
          }
        }
        destroy() {
          var _this$element;
          if ((_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode) {
            this.element.remove();
          }
          this.element = null;
        }
      };
      Content = class {
        /**
         * @param {SlideData} itemData Slide data
         * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance
         * @param {number} index
         */
        constructor(itemData, instance, index) {
          this.instance = instance;
          this.data = itemData;
          this.index = index;
          this.element = void 0;
          this.placeholder = void 0;
          this.slide = void 0;
          this.displayedImageWidth = 0;
          this.displayedImageHeight = 0;
          this.width = Number(this.data.w) || Number(this.data.width) || 0;
          this.height = Number(this.data.h) || Number(this.data.height) || 0;
          this.isAttached = false;
          this.hasSlide = false;
          this.isDecoding = false;
          this.state = LOAD_STATE.IDLE;
          if (this.data.type) {
            this.type = this.data.type;
          } else if (this.data.src) {
            this.type = "image";
          } else {
            this.type = "html";
          }
          this.instance.dispatch("contentInit", {
            content: this
          });
        }
        removePlaceholder() {
          if (this.placeholder && !this.keepPlaceholder()) {
            setTimeout(() => {
              if (this.placeholder) {
                this.placeholder.destroy();
                this.placeholder = void 0;
              }
            }, 1e3);
          }
        }
        /**
         * Preload content
         *
         * @param {boolean} isLazy
         * @param {boolean} [reload]
         */
        load(isLazy, reload) {
          if (this.slide && this.usePlaceholder()) {
            if (!this.placeholder) {
              const placeholderSrc = this.instance.applyFilters(
                "placeholderSrc",
                // use  image-based placeholder only for the first slide,
                // as rendering (even small stretched thumbnail) is an expensive operation
                this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : false,
                this
              );
              this.placeholder = new Placeholder(placeholderSrc, this.slide.container);
            } else {
              const placeholderEl = this.placeholder.element;
              if (placeholderEl && !placeholderEl.parentElement) {
                this.slide.container.prepend(placeholderEl);
              }
            }
          }
          if (this.element && !reload) {
            return;
          }
          if (this.instance.dispatch("contentLoad", {
            content: this,
            isLazy
          }).defaultPrevented) {
            return;
          }
          if (this.isImageContent()) {
            this.element = createElement("pswp__img", "img");
            if (this.displayedImageWidth) {
              this.loadImage(isLazy);
            }
          } else {
            this.element = createElement("pswp__content", "div");
            this.element.innerHTML = this.data.html || "";
          }
          if (reload && this.slide) {
            this.slide.updateContentSize(true);
          }
        }
        /**
         * Preload image
         *
         * @param {boolean} isLazy
         */
        loadImage(isLazy) {
          var _this$data$src, _this$data$alt;
          if (!this.isImageContent() || !this.element || this.instance.dispatch("contentLoadImage", {
            content: this,
            isLazy
          }).defaultPrevented) {
            return;
          }
          const imageElement = (
            /** @type HTMLImageElement */
            this.element
          );
          this.updateSrcsetSizes();
          if (this.data.srcset) {
            imageElement.srcset = this.data.srcset;
          }
          imageElement.src = (_this$data$src = this.data.src) !== null && _this$data$src !== void 0 ? _this$data$src : "";
          imageElement.alt = (_this$data$alt = this.data.alt) !== null && _this$data$alt !== void 0 ? _this$data$alt : "";
          this.state = LOAD_STATE.LOADING;
          if (imageElement.complete) {
            this.onLoaded();
          } else {
            imageElement.onload = () => {
              this.onLoaded();
            };
            imageElement.onerror = () => {
              this.onError();
            };
          }
        }
        /**
         * Assign slide to content
         *
         * @param {Slide} slide
         */
        setSlide(slide) {
          this.slide = slide;
          this.hasSlide = true;
          this.instance = slide.pswp;
        }
        /**
         * Content load success handler
         */
        onLoaded() {
          this.state = LOAD_STATE.LOADED;
          if (this.slide && this.element) {
            this.instance.dispatch("loadComplete", {
              slide: this.slide,
              content: this
            });
            if (this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode) {
              this.append();
              this.slide.updateContentSize(true);
            }
            if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
              this.removePlaceholder();
            }
          }
        }
        /**
         * Content load error handler
         */
        onError() {
          this.state = LOAD_STATE.ERROR;
          if (this.slide) {
            this.displayError();
            this.instance.dispatch("loadComplete", {
              slide: this.slide,
              isError: true,
              content: this
            });
            this.instance.dispatch("loadError", {
              slide: this.slide,
              content: this
            });
          }
        }
        /**
         * @returns {Boolean} If the content is currently loading
         */
        isLoading() {
          return this.instance.applyFilters("isContentLoading", this.state === LOAD_STATE.LOADING, this);
        }
        /**
         * @returns {Boolean} If the content is in error state
         */
        isError() {
          return this.state === LOAD_STATE.ERROR;
        }
        /**
         * @returns {boolean} If the content is image
         */
        isImageContent() {
          return this.type === "image";
        }
        /**
         * Update content size
         *
         * @param {Number} width
         * @param {Number} height
         */
        setDisplayedSize(width, height) {
          if (!this.element) {
            return;
          }
          if (this.placeholder) {
            this.placeholder.setDisplayedSize(width, height);
          }
          if (this.instance.dispatch("contentResize", {
            content: this,
            width,
            height
          }).defaultPrevented) {
            return;
          }
          setWidthHeight(this.element, width, height);
          if (this.isImageContent() && !this.isError()) {
            const isInitialSizeUpdate = !this.displayedImageWidth && width;
            this.displayedImageWidth = width;
            this.displayedImageHeight = height;
            if (isInitialSizeUpdate) {
              this.loadImage(false);
            } else {
              this.updateSrcsetSizes();
            }
            if (this.slide) {
              this.instance.dispatch("imageSizeChange", {
                slide: this.slide,
                width,
                height,
                content: this
              });
            }
          }
        }
        /**
         * @returns {boolean} If the content can be zoomed
         */
        isZoomable() {
          return this.instance.applyFilters("isContentZoomable", this.isImageContent() && this.state !== LOAD_STATE.ERROR, this);
        }
        /**
         * Update image srcset sizes attribute based on width and height
         */
        updateSrcsetSizes() {
          if (!this.isImageContent() || !this.element || !this.data.srcset) {
            return;
          }
          const image = (
            /** @type HTMLImageElement */
            this.element
          );
          const sizesWidth = this.instance.applyFilters("srcsetSizesWidth", this.displayedImageWidth, this);
          if (!image.dataset.largestUsedSize || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {
            image.sizes = sizesWidth + "px";
            image.dataset.largestUsedSize = String(sizesWidth);
          }
        }
        /**
         * @returns {boolean} If content should use a placeholder (from msrc by default)
         */
        usePlaceholder() {
          return this.instance.applyFilters("useContentPlaceholder", this.isImageContent(), this);
        }
        /**
         * Preload content with lazy-loading param
         */
        lazyLoad() {
          if (this.instance.dispatch("contentLazyLoad", {
            content: this
          }).defaultPrevented) {
            return;
          }
          this.load(true);
        }
        /**
         * @returns {boolean} If placeholder should be kept after content is loaded
         */
        keepPlaceholder() {
          return this.instance.applyFilters("isKeepingPlaceholder", this.isLoading(), this);
        }
        /**
         * Destroy the content
         */
        destroy() {
          this.hasSlide = false;
          this.slide = void 0;
          if (this.instance.dispatch("contentDestroy", {
            content: this
          }).defaultPrevented) {
            return;
          }
          this.remove();
          if (this.placeholder) {
            this.placeholder.destroy();
            this.placeholder = void 0;
          }
          if (this.isImageContent() && this.element) {
            this.element.onload = null;
            this.element.onerror = null;
            this.element = void 0;
          }
        }
        /**
         * Display error message
         */
        displayError() {
          if (this.slide) {
            var _this$instance$option, _this$instance$option2;
            let errorMsgEl = createElement("pswp__error-msg", "div");
            errorMsgEl.innerText = (_this$instance$option = (_this$instance$option2 = this.instance.options) === null || _this$instance$option2 === void 0 ? void 0 : _this$instance$option2.errorMsg) !== null && _this$instance$option !== void 0 ? _this$instance$option : "";
            errorMsgEl = /** @type {HTMLDivElement} */
            this.instance.applyFilters("contentErrorElement", errorMsgEl, this);
            this.element = createElement("pswp__content pswp__error-msg-container", "div");
            this.element.appendChild(errorMsgEl);
            this.slide.container.innerText = "";
            this.slide.container.appendChild(this.element);
            this.slide.updateContentSize(true);
            this.removePlaceholder();
          }
        }
        /**
         * Append the content
         */
        append() {
          if (this.isAttached || !this.element) {
            return;
          }
          this.isAttached = true;
          if (this.state === LOAD_STATE.ERROR) {
            this.displayError();
            return;
          }
          if (this.instance.dispatch("contentAppend", {
            content: this
          }).defaultPrevented) {
            return;
          }
          const supportsDecode = "decode" in this.element;
          if (this.isImageContent()) {
            if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {
              this.isDecoding = true;
              this.element.decode().catch(() => {
              }).finally(() => {
                this.isDecoding = false;
                this.appendImage();
              });
            } else {
              this.appendImage();
            }
          } else if (this.slide && !this.element.parentNode) {
            this.slide.container.appendChild(this.element);
          }
        }
        /**
         * Activate the slide,
         * active slide is generally the current one,
         * meaning the user can see it.
         */
        activate() {
          if (this.instance.dispatch("contentActivate", {
            content: this
          }).defaultPrevented || !this.slide) {
            return;
          }
          if (this.isImageContent() && this.isDecoding && !isSafari()) {
            this.appendImage();
          } else if (this.isError()) {
            this.load(false, true);
          }
          if (this.slide.holderElement) {
            this.slide.holderElement.setAttribute("aria-hidden", "false");
          }
        }
        /**
         * Deactivate the content
         */
        deactivate() {
          this.instance.dispatch("contentDeactivate", {
            content: this
          });
          if (this.slide && this.slide.holderElement) {
            this.slide.holderElement.setAttribute("aria-hidden", "true");
          }
        }
        /**
         * Remove the content from DOM
         */
        remove() {
          this.isAttached = false;
          if (this.instance.dispatch("contentRemove", {
            content: this
          }).defaultPrevented) {
            return;
          }
          if (this.element && this.element.parentNode) {
            this.element.remove();
          }
          if (this.placeholder && this.placeholder.element) {
            this.placeholder.element.remove();
          }
        }
        /**
         * Append the image content to slide container
         */
        appendImage() {
          if (!this.isAttached) {
            return;
          }
          if (this.instance.dispatch("contentAppendImage", {
            content: this
          }).defaultPrevented) {
            return;
          }
          if (this.slide && this.element && !this.element.parentNode) {
            this.slide.container.appendChild(this.element);
          }
          if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {
            this.removePlaceholder();
          }
        }
      };
      MIN_SLIDES_TO_CACHE = 5;
      ContentLoader = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          this.limit = Math.max(pswp.options.preload[0] + pswp.options.preload[1] + 1, MIN_SLIDES_TO_CACHE);
          this._cachedItems = [];
        }
        /**
         * Lazy load nearby slides based on `preload` option.
         *
         * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.
         */
        updateLazy(diff) {
          const {
            pswp
          } = this;
          if (pswp.dispatch("lazyLoad").defaultPrevented) {
            return;
          }
          const {
            preload
          } = pswp.options;
          const isForward = diff === void 0 ? true : diff >= 0;
          let i2;
          for (i2 = 0; i2 <= preload[1]; i2++) {
            this.loadSlideByIndex(pswp.currIndex + (isForward ? i2 : -i2));
          }
          for (i2 = 1; i2 <= preload[0]; i2++) {
            this.loadSlideByIndex(pswp.currIndex + (isForward ? -i2 : i2));
          }
        }
        /**
         * @param {number} initialIndex
         */
        loadSlideByIndex(initialIndex) {
          const index = this.pswp.getLoopedIndex(initialIndex);
          let content = this.getContentByIndex(index);
          if (!content) {
            content = lazyLoadSlide(index, this.pswp);
            if (content) {
              this.addToCache(content);
            }
          }
        }
        /**
         * @param {Slide} slide
         * @returns {Content}
         */
        getContentBySlide(slide) {
          let content = this.getContentByIndex(slide.index);
          if (!content) {
            content = this.pswp.createContentFromData(slide.data, slide.index);
            this.addToCache(content);
          }
          content.setSlide(slide);
          return content;
        }
        /**
         * @param {Content} content
         */
        addToCache(content) {
          this.removeByIndex(content.index);
          this._cachedItems.push(content);
          if (this._cachedItems.length > this.limit) {
            const indexToRemove = this._cachedItems.findIndex((item) => {
              return !item.isAttached && !item.hasSlide;
            });
            if (indexToRemove !== -1) {
              const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];
              removedItem.destroy();
            }
          }
        }
        /**
         * Removes an image from cache, does not destroy() it, just removes.
         *
         * @param {number} index
         */
        removeByIndex(index) {
          const indexToRemove = this._cachedItems.findIndex((item) => item.index === index);
          if (indexToRemove !== -1) {
            this._cachedItems.splice(indexToRemove, 1);
          }
        }
        /**
         * @param {number} index
         * @returns {Content | undefined}
         */
        getContentByIndex(index) {
          return this._cachedItems.find((content) => content.index === index);
        }
        destroy() {
          this._cachedItems.forEach((content) => content.destroy());
          this._cachedItems = [];
        }
      };
      PhotoSwipeBase = class extends Eventable {
        /**
         * Get total number of slides
         *
         * @returns {number}
         */
        getNumItems() {
          var _this$options;
          let numItems = 0;
          const dataSource = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.dataSource;
          if (dataSource && "length" in dataSource) {
            numItems = dataSource.length;
          } else if (dataSource && "gallery" in dataSource) {
            if (!dataSource.items) {
              dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
            }
            if (dataSource.items) {
              numItems = dataSource.items.length;
            }
          }
          const event = this.dispatch("numItems", {
            dataSource,
            numItems
          });
          return this.applyFilters("numItems", event.numItems, dataSource);
        }
        /**
         * @param {SlideData} slideData
         * @param {number} index
         * @returns {Content}
         */
        createContentFromData(slideData, index) {
          return new Content(slideData, this, index);
        }
        /**
         * Get item data by index.
         *
         * "item data" should contain normalized information that PhotoSwipe needs to generate a slide.
         * For example, it may contain properties like
         * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.
         *
         * @param {number} index
         * @returns {SlideData}
         */
        getItemData(index) {
          var _this$options2;
          const dataSource = (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.dataSource;
          let dataSourceItem = {};
          if (Array.isArray(dataSource)) {
            dataSourceItem = dataSource[index];
          } else if (dataSource && "gallery" in dataSource) {
            if (!dataSource.items) {
              dataSource.items = this._getGalleryDOMElements(dataSource.gallery);
            }
            dataSourceItem = dataSource.items[index];
          }
          let itemData = dataSourceItem;
          if (itemData instanceof Element) {
            itemData = this._domElementToItemData(itemData);
          }
          const event = this.dispatch("itemData", {
            itemData: itemData || {},
            index
          });
          return this.applyFilters("itemData", event.itemData, index);
        }
        /**
         * Get array of gallery DOM elements,
         * based on childSelector and gallery element.
         *
         * @param {HTMLElement} galleryElement
         * @returns {HTMLElement[]}
         */
        _getGalleryDOMElements(galleryElement) {
          var _this$options3, _this$options4;
          if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.children || (_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.childSelector) {
            return getElementsFromOption(this.options.children, this.options.childSelector, galleryElement) || [];
          }
          return [galleryElement];
        }
        /**
         * Converts DOM element to item data object.
         *
         * @param {HTMLElement} element DOM element
         * @returns {SlideData}
         */
        _domElementToItemData(element) {
          const itemData = {
            element
          };
          const linkEl = (
            /** @type {HTMLAnchorElement} */
            element.tagName === "A" ? element : element.querySelector("a")
          );
          if (linkEl) {
            itemData.src = linkEl.dataset.pswpSrc || linkEl.href;
            if (linkEl.dataset.pswpSrcset) {
              itemData.srcset = linkEl.dataset.pswpSrcset;
            }
            itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;
            itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0;
            itemData.w = itemData.width;
            itemData.h = itemData.height;
            if (linkEl.dataset.pswpType) {
              itemData.type = linkEl.dataset.pswpType;
            }
            const thumbnailEl = element.querySelector("img");
            if (thumbnailEl) {
              var _thumbnailEl$getAttri;
              itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;
              itemData.alt = (_thumbnailEl$getAttri = thumbnailEl.getAttribute("alt")) !== null && _thumbnailEl$getAttri !== void 0 ? _thumbnailEl$getAttri : "";
            }
            if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {
              itemData.thumbCropped = true;
            }
          }
          return this.applyFilters("domItemData", itemData, element, linkEl);
        }
        /**
         * Lazy-load by slide data
         *
         * @param {SlideData} itemData Data about the slide
         * @param {number} index
         * @returns {Content} Image that is being decoded or false.
         */
        lazyLoadData(itemData, index) {
          return lazyLoadData(itemData, this, index);
        }
      };
      MIN_OPACITY = 3e-3;
      Opener = class {
        /**
         * @param {PhotoSwipe} pswp
         */
        constructor(pswp) {
          this.pswp = pswp;
          this.isClosed = true;
          this.isOpen = false;
          this.isClosing = false;
          this.isOpening = false;
          this._duration = void 0;
          this._useAnimation = false;
          this._croppedZoom = false;
          this._animateRootOpacity = false;
          this._animateBgOpacity = false;
          this._placeholder = void 0;
          this._opacityElement = void 0;
          this._cropContainer1 = void 0;
          this._cropContainer2 = void 0;
          this._thumbBounds = void 0;
          this._prepareOpen = this._prepareOpen.bind(this);
          pswp.on("firstZoomPan", this._prepareOpen);
        }
        open() {
          this._prepareOpen();
          this._start();
        }
        close() {
          if (this.isClosed || this.isClosing || this.isOpening) {
            return;
          }
          const slide = this.pswp.currSlide;
          this.isOpen = false;
          this.isOpening = false;
          this.isClosing = true;
          this._duration = this.pswp.options.hideAnimationDuration;
          if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {
            this._duration = 0;
          }
          this._applyStartProps();
          setTimeout(() => {
            this._start();
          }, this._croppedZoom ? 30 : 0);
        }
        /** @private */
        _prepareOpen() {
          this.pswp.off("firstZoomPan", this._prepareOpen);
          if (!this.isOpening) {
            const slide = this.pswp.currSlide;
            this.isOpening = true;
            this.isClosing = false;
            this._duration = this.pswp.options.showAnimationDuration;
            if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {
              this._duration = 0;
            }
            this._applyStartProps();
          }
        }
        /** @private */
        _applyStartProps() {
          const {
            pswp
          } = this;
          const slide = this.pswp.currSlide;
          const {
            options
          } = pswp;
          if (options.showHideAnimationType === "fade") {
            options.showHideOpacity = true;
            this._thumbBounds = void 0;
          } else if (options.showHideAnimationType === "none") {
            options.showHideOpacity = false;
            this._duration = 0;
            this._thumbBounds = void 0;
          } else if (this.isOpening && pswp._initialThumbBounds) {
            this._thumbBounds = pswp._initialThumbBounds;
          } else {
            this._thumbBounds = this.pswp.getThumbBounds();
          }
          this._placeholder = slide === null || slide === void 0 ? void 0 : slide.getPlaceholderElement();
          pswp.animations.stopAll();
          this._useAnimation = Boolean(this._duration && this._duration > 50);
          this._animateZoom = Boolean(this._thumbBounds) && (slide === null || slide === void 0 ? void 0 : slide.content.usePlaceholder()) && (!this.isClosing || !pswp.mainScroll.isShifted());
          if (!this._animateZoom) {
            this._animateRootOpacity = true;
            if (this.isOpening && slide) {
              slide.zoomAndPanToInitial();
              slide.applyCurrentZoomPan();
            }
          } else {
            var _options$showHideOpac;
            this._animateRootOpacity = (_options$showHideOpac = options.showHideOpacity) !== null && _options$showHideOpac !== void 0 ? _options$showHideOpac : false;
          }
          this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;
          this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;
          if (!this._useAnimation) {
            this._duration = 0;
            this._animateZoom = false;
            this._animateBgOpacity = false;
            this._animateRootOpacity = true;
            if (this.isOpening) {
              if (pswp.element) {
                pswp.element.style.opacity = String(MIN_OPACITY);
              }
              pswp.applyBgOpacity(1);
            }
            return;
          }
          if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {
            var _this$pswp$currSlide;
            this._croppedZoom = true;
            this._cropContainer1 = this.pswp.container;
            this._cropContainer2 = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.holderElement;
            if (pswp.container) {
              pswp.container.style.overflow = "hidden";
              pswp.container.style.width = pswp.viewportSize.x + "px";
            }
          } else {
            this._croppedZoom = false;
          }
          if (this.isOpening) {
            if (this._animateRootOpacity) {
              if (pswp.element) {
                pswp.element.style.opacity = String(MIN_OPACITY);
              }
              pswp.applyBgOpacity(1);
            } else {
              if (this._animateBgOpacity && pswp.bg) {
                pswp.bg.style.opacity = String(MIN_OPACITY);
              }
              if (pswp.element) {
                pswp.element.style.opacity = "1";
              }
            }
            if (this._animateZoom) {
              this._setClosedStateZoomPan();
              if (this._placeholder) {
                this._placeholder.style.willChange = "transform";
                this._placeholder.style.opacity = String(MIN_OPACITY);
              }
            }
          } else if (this.isClosing) {
            if (pswp.mainScroll.itemHolders[0]) {
              pswp.mainScroll.itemHolders[0].el.style.display = "none";
            }
            if (pswp.mainScroll.itemHolders[2]) {
              pswp.mainScroll.itemHolders[2].el.style.display = "none";
            }
            if (this._croppedZoom) {
              if (pswp.mainScroll.x !== 0) {
                pswp.mainScroll.resetPosition();
                pswp.mainScroll.resize();
              }
            }
          }
        }
        /** @private */
        _start() {
          if (this.isOpening && this._useAnimation && this._placeholder && this._placeholder.tagName === "IMG") {
            new Promise((resolve) => {
              let decoded = false;
              let isDelaying = true;
              decodeImage(
                /** @type {HTMLImageElement} */
                this._placeholder
              ).finally(() => {
                decoded = true;
                if (!isDelaying) {
                  resolve(true);
                }
              });
              setTimeout(() => {
                isDelaying = false;
                if (decoded) {
                  resolve(true);
                }
              }, 50);
              setTimeout(resolve, 250);
            }).finally(() => this._initiate());
          } else {
            this._initiate();
          }
        }
        /** @private */
        _initiate() {
          var _this$pswp$element, _this$pswp$element2;
          (_this$pswp$element = this.pswp.element) === null || _this$pswp$element === void 0 || _this$pswp$element.style.setProperty("--pswp-transition-duration", this._duration + "ms");
          this.pswp.dispatch(this.isOpening ? "openingAnimationStart" : "closingAnimationStart");
          this.pswp.dispatch(
            /** @type {'initialZoomIn' | 'initialZoomOut'} */
            "initialZoom" + (this.isOpening ? "In" : "Out")
          );
          (_this$pswp$element2 = this.pswp.element) === null || _this$pswp$element2 === void 0 || _this$pswp$element2.classList.toggle("pswp--ui-visible", this.isOpening);
          if (this.isOpening) {
            if (this._placeholder) {
              this._placeholder.style.opacity = "1";
            }
            this._animateToOpenState();
          } else if (this.isClosing) {
            this._animateToClosedState();
          }
          if (!this._useAnimation) {
            this._onAnimationComplete();
          }
        }
        /** @private */
        _onAnimationComplete() {
          const {
            pswp
          } = this;
          this.isOpen = this.isOpening;
          this.isClosed = this.isClosing;
          this.isOpening = false;
          this.isClosing = false;
          pswp.dispatch(this.isOpen ? "openingAnimationEnd" : "closingAnimationEnd");
          pswp.dispatch(
            /** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */
            "initialZoom" + (this.isOpen ? "InEnd" : "OutEnd")
          );
          if (this.isClosed) {
            pswp.destroy();
          } else if (this.isOpen) {
            var _pswp$currSlide;
            if (this._animateZoom && pswp.container) {
              pswp.container.style.overflow = "visible";
              pswp.container.style.width = "100%";
            }
            (_pswp$currSlide = pswp.currSlide) === null || _pswp$currSlide === void 0 || _pswp$currSlide.applyCurrentZoomPan();
          }
        }
        /** @private */
        _animateToOpenState() {
          const {
            pswp
          } = this;
          if (this._animateZoom) {
            if (this._croppedZoom && this._cropContainer1 && this._cropContainer2) {
              this._animateTo(this._cropContainer1, "transform", "translate3d(0,0,0)");
              this._animateTo(this._cropContainer2, "transform", "none");
            }
            if (pswp.currSlide) {
              pswp.currSlide.zoomAndPanToInitial();
              this._animateTo(pswp.currSlide.container, "transform", pswp.currSlide.getCurrentTransform());
            }
          }
          if (this._animateBgOpacity && pswp.bg) {
            this._animateTo(pswp.bg, "opacity", String(pswp.options.bgOpacity));
          }
          if (this._animateRootOpacity && pswp.element) {
            this._animateTo(pswp.element, "opacity", "1");
          }
        }
        /** @private */
        _animateToClosedState() {
          const {
            pswp
          } = this;
          if (this._animateZoom) {
            this._setClosedStateZoomPan(true);
          }
          if (this._animateBgOpacity && pswp.bgOpacity > 0.01 && pswp.bg) {
            this._animateTo(pswp.bg, "opacity", "0");
          }
          if (this._animateRootOpacity && pswp.element) {
            this._animateTo(pswp.element, "opacity", "0");
          }
        }
        /**
         * @private
         * @param {boolean} [animate]
         */
        _setClosedStateZoomPan(animate) {
          if (!this._thumbBounds)
            return;
          const {
            pswp
          } = this;
          const {
            innerRect
          } = this._thumbBounds;
          const {
            currSlide,
            viewportSize
          } = pswp;
          if (this._croppedZoom && innerRect && this._cropContainer1 && this._cropContainer2) {
            const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;
            const containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;
            const containerTwoPanX = viewportSize.x - innerRect.w;
            const containerTwoPanY = viewportSize.y - innerRect.h;
            if (animate) {
              this._animateTo(this._cropContainer1, "transform", toTransformString(containerOnePanX, containerOnePanY));
              this._animateTo(this._cropContainer2, "transform", toTransformString(containerTwoPanX, containerTwoPanY));
            } else {
              setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);
              setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);
            }
          }
          if (currSlide) {
            equalizePoints(currSlide.pan, innerRect || this._thumbBounds);
            currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;
            if (animate) {
              this._animateTo(currSlide.container, "transform", currSlide.getCurrentTransform());
            } else {
              currSlide.applyCurrentZoomPan();
            }
          }
        }
        /**
         * @private
         * @param {HTMLElement} target
         * @param {'transform' | 'opacity'} prop
         * @param {string} propValue
         */
        _animateTo(target, prop, propValue) {
          if (!this._duration) {
            target.style[prop] = propValue;
            return;
          }
          const {
            animations
          } = this.pswp;
          const animProps = {
            duration: this._duration,
            easing: this.pswp.options.easing,
            onComplete: () => {
              if (!animations.activeAnimations.length) {
                this._onAnimationComplete();
              }
            },
            target
          };
          animProps[prop] = propValue;
          animations.startTransition(animProps);
        }
      };
      defaultOptions = {
        allowPanToNext: true,
        spacing: 0.1,
        loop: true,
        pinchToClose: true,
        closeOnVerticalDrag: true,
        hideAnimationDuration: 333,
        showAnimationDuration: 333,
        zoomAnimationDuration: 333,
        escKey: true,
        arrowKeys: true,
        trapFocus: true,
        returnFocus: true,
        maxWidthToAnimate: 4e3,
        clickToCloseNonZoomable: true,
        imageClickAction: "zoom-or-close",
        bgClickAction: "close",
        tapAction: "toggle-controls",
        doubleTapAction: "zoom",
        indexIndicatorSep: " / ",
        preloaderDelay: 2e3,
        bgOpacity: 0.8,
        index: 0,
        errorMsg: "The image cannot be loaded",
        preload: [1, 2],
        easing: "cubic-bezier(.4,0,.22,1)"
      };
      PhotoSwipe = class extends PhotoSwipeBase {
        /**
         * @param {PhotoSwipeOptions} [options]
         */
        constructor(options) {
          super();
          this.options = this._prepareOptions(options || {});
          this.offset = {
            x: 0,
            y: 0
          };
          this._prevViewportSize = {
            x: 0,
            y: 0
          };
          this.viewportSize = {
            x: 0,
            y: 0
          };
          this.bgOpacity = 1;
          this.currIndex = 0;
          this.potentialIndex = 0;
          this.isOpen = false;
          this.isDestroying = false;
          this.hasMouse = false;
          this._initialItemData = {};
          this._initialThumbBounds = void 0;
          this.topBar = void 0;
          this.element = void 0;
          this.template = void 0;
          this.container = void 0;
          this.scrollWrap = void 0;
          this.currSlide = void 0;
          this.events = new DOMEvents();
          this.animations = new Animations();
          this.mainScroll = new MainScroll(this);
          this.gestures = new Gestures(this);
          this.opener = new Opener(this);
          this.keyboard = new Keyboard(this);
          this.contentLoader = new ContentLoader(this);
        }
        /** @returns {boolean} */
        init() {
          if (this.isOpen || this.isDestroying) {
            return false;
          }
          this.isOpen = true;
          this.dispatch("init");
          this.dispatch("beforeOpen");
          this._createMainStructure();
          let rootClasses = "pswp--open";
          if (this.gestures.supportsTouch) {
            rootClasses += " pswp--touch";
          }
          if (this.options.mainClass) {
            rootClasses += " " + this.options.mainClass;
          }
          if (this.element) {
            this.element.className += " " + rootClasses;
          }
          this.currIndex = this.options.index || 0;
          this.potentialIndex = this.currIndex;
          this.dispatch("firstUpdate");
          this.scrollWheel = new ScrollWheel(this);
          if (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) {
            this.currIndex = 0;
          }
          if (!this.gestures.supportsTouch) {
            this.mouseDetected();
          }
          this.updateSize();
          this.offset.y = window.pageYOffset;
          this._initialItemData = this.getItemData(this.currIndex);
          this.dispatch("gettingData", {
            index: this.currIndex,
            data: this._initialItemData,
            slide: void 0
          });
          this._initialThumbBounds = this.getThumbBounds();
          this.dispatch("initialLayout");
          this.on("openingAnimationEnd", () => {
            const {
              itemHolders
            } = this.mainScroll;
            if (itemHolders[0]) {
              itemHolders[0].el.style.display = "block";
              this.setContent(itemHolders[0], this.currIndex - 1);
            }
            if (itemHolders[2]) {
              itemHolders[2].el.style.display = "block";
              this.setContent(itemHolders[2], this.currIndex + 1);
            }
            this.appendHeavy();
            this.contentLoader.updateLazy();
            this.events.add(window, "resize", this._handlePageResize.bind(this));
            this.events.add(window, "scroll", this._updatePageScrollOffset.bind(this));
            this.dispatch("bindEvents");
          });
          if (this.mainScroll.itemHolders[1]) {
            this.setContent(this.mainScroll.itemHolders[1], this.currIndex);
          }
          this.dispatch("change");
          this.opener.open();
          this.dispatch("afterInit");
          return true;
        }
        /**
         * Get looped slide index
         * (for example, -1 will return the last slide)
         *
         * @param {number} index
         * @returns {number}
         */
        getLoopedIndex(index) {
          const numSlides = this.getNumItems();
          if (this.options.loop) {
            if (index > numSlides - 1) {
              index -= numSlides;
            }
            if (index < 0) {
              index += numSlides;
            }
          }
          return clamp(index, 0, numSlides - 1);
        }
        appendHeavy() {
          this.mainScroll.itemHolders.forEach((itemHolder) => {
            var _itemHolder$slide;
            (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.appendHeavy();
          });
        }
        /**
         * Change the slide
         * @param {number} index New index
         */
        goTo(index) {
          this.mainScroll.moveIndexBy(this.getLoopedIndex(index) - this.potentialIndex);
        }
        /**
         * Go to the next slide.
         */
        next() {
          this.goTo(this.potentialIndex + 1);
        }
        /**
         * Go to the previous slide.
         */
        prev() {
          this.goTo(this.potentialIndex - 1);
        }
        /**
         * @see slide/slide.js zoomTo
         *
         * @param {Parameters<Slide['zoomTo']>} args
         */
        zoomTo(...args) {
          var _this$currSlide;
          (_this$currSlide = this.currSlide) === null || _this$currSlide === void 0 || _this$currSlide.zoomTo(...args);
        }
        /**
         * @see slide/slide.js toggleZoom
         */
        toggleZoom() {
          var _this$currSlide2;
          (_this$currSlide2 = this.currSlide) === null || _this$currSlide2 === void 0 || _this$currSlide2.toggleZoom();
        }
        /**
         * Close the gallery.
         * After closing transition ends - destroy it
         */
        close() {
          if (!this.opener.isOpen || this.isDestroying) {
            return;
          }
          this.isDestroying = true;
          this.dispatch("close");
          this.events.removeAll();
          this.opener.close();
        }
        /**
         * Destroys the gallery:
         * - instantly closes the gallery
         * - unbinds events,
         * - cleans intervals and timeouts
         * - removes elements from DOM
         */
        destroy() {
          var _this$element;
          if (!this.isDestroying) {
            this.options.showHideAnimationType = "none";
            this.close();
            return;
          }
          this.dispatch("destroy");
          this._listeners = {};
          if (this.scrollWrap) {
            this.scrollWrap.ontouchmove = null;
            this.scrollWrap.ontouchend = null;
          }
          (_this$element = this.element) === null || _this$element === void 0 || _this$element.remove();
          this.mainScroll.itemHolders.forEach((itemHolder) => {
            var _itemHolder$slide2;
            (_itemHolder$slide2 = itemHolder.slide) === null || _itemHolder$slide2 === void 0 || _itemHolder$slide2.destroy();
          });
          this.contentLoader.destroy();
          this.events.removeAll();
        }
        /**
         * Refresh/reload content of a slide by its index
         *
         * @param {number} slideIndex
         */
        refreshSlideContent(slideIndex) {
          this.contentLoader.removeByIndex(slideIndex);
          this.mainScroll.itemHolders.forEach((itemHolder, i2) => {
            var _this$currSlide$index, _this$currSlide3;
            let potentialHolderIndex = ((_this$currSlide$index = (_this$currSlide3 = this.currSlide) === null || _this$currSlide3 === void 0 ? void 0 : _this$currSlide3.index) !== null && _this$currSlide$index !== void 0 ? _this$currSlide$index : 0) - 1 + i2;
            if (this.canLoop()) {
              potentialHolderIndex = this.getLoopedIndex(potentialHolderIndex);
            }
            if (potentialHolderIndex === slideIndex) {
              this.setContent(itemHolder, slideIndex, true);
              if (i2 === 1) {
                var _itemHolder$slide3;
                this.currSlide = itemHolder.slide;
                (_itemHolder$slide3 = itemHolder.slide) === null || _itemHolder$slide3 === void 0 || _itemHolder$slide3.setIsActive(true);
              }
            }
          });
          this.dispatch("change");
        }
        /**
         * Set slide content
         *
         * @param {ItemHolder} holder mainScroll.itemHolders array item
         * @param {number} index Slide index
         * @param {boolean} [force] If content should be set even if index wasn't changed
         */
        setContent(holder, index, force) {
          if (this.canLoop()) {
            index = this.getLoopedIndex(index);
          }
          if (holder.slide) {
            if (holder.slide.index === index && !force) {
              return;
            }
            holder.slide.destroy();
            holder.slide = void 0;
          }
          if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {
            return;
          }
          const itemData = this.getItemData(index);
          holder.slide = new Slide(itemData, index, this);
          if (index === this.currIndex) {
            this.currSlide = holder.slide;
          }
          holder.slide.append(holder.el);
        }
        /** @returns {Point} */
        getViewportCenterPoint() {
          return {
            x: this.viewportSize.x / 2,
            y: this.viewportSize.y / 2
          };
        }
        /**
         * Update size of all elements.
         * Executed on init and on page resize.
         *
         * @param {boolean} [force] Update size even if size of viewport was not changed.
         */
        updateSize(force) {
          if (this.isDestroying) {
            return;
          }
          const newViewportSize = getViewportSize(this.options, this);
          if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {
            return;
          }
          equalizePoints(this._prevViewportSize, newViewportSize);
          this.dispatch("beforeResize");
          equalizePoints(this.viewportSize, this._prevViewportSize);
          this._updatePageScrollOffset();
          this.dispatch("viewportSize");
          this.mainScroll.resize(this.opener.isOpen);
          if (!this.hasMouse && window.matchMedia("(any-hover: hover)").matches) {
            this.mouseDetected();
          }
          this.dispatch("resize");
        }
        /**
         * @param {number} opacity
         */
        applyBgOpacity(opacity) {
          this.bgOpacity = Math.max(opacity, 0);
          if (this.bg) {
            this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);
          }
        }
        /**
         * Whether mouse is detected
         */
        mouseDetected() {
          if (!this.hasMouse) {
            var _this$element2;
            this.hasMouse = true;
            (_this$element2 = this.element) === null || _this$element2 === void 0 || _this$element2.classList.add("pswp--has_mouse");
          }
        }
        /**
         * Page resize event handler
         *
         * @private
         */
        _handlePageResize() {
          this.updateSize();
          if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {
            setTimeout(() => {
              this.updateSize();
            }, 500);
          }
        }
        /**
         * Page scroll offset is used
         * to get correct coordinates
         * relative to PhotoSwipe viewport.
         *
         * @private
         */
        _updatePageScrollOffset() {
          this.setScrollOffset(0, window.pageYOffset);
        }
        /**
         * @param {number} x
         * @param {number} y
         */
        setScrollOffset(x, y) {
          this.offset.x = x;
          this.offset.y = y;
          this.dispatch("updateScrollOffset");
        }
        /**
         * Create main HTML structure of PhotoSwipe,
         * and add it to DOM
         *
         * @private
         */
        _createMainStructure() {
          this.element = createElement("pswp", "div");
          this.element.setAttribute("tabindex", "-1");
          this.element.setAttribute("role", "dialog");
          this.template = this.element;
          this.bg = createElement("pswp__bg", "div", this.element);
          this.scrollWrap = createElement("pswp__scroll-wrap", "section", this.element);
          this.container = createElement("pswp__container", "div", this.scrollWrap);
          this.scrollWrap.setAttribute("aria-roledescription", "carousel");
          this.container.setAttribute("aria-live", "off");
          this.container.setAttribute("id", "pswp__items");
          this.mainScroll.appendHolders();
          this.ui = new UI(this);
          this.ui.init();
          (this.options.appendToEl || document.body).appendChild(this.element);
        }
        /**
         * Get position and dimensions of small thumbnail
         *   {x:,y:,w:}
         *
         * Height is optional (calculated based on the large image)
         *
         * @returns {Bounds | undefined}
         */
        getThumbBounds() {
          return getThumbBounds(this.currIndex, this.currSlide ? this.currSlide.data : this._initialItemData, this);
        }
        /**
         * If the PhotoSwipe can have continuous loop
         * @returns Boolean
         */
        canLoop() {
          return this.options.loop && this.getNumItems() > 2;
        }
        /**
         * @private
         * @param {PhotoSwipeOptions} options
         * @returns {PreparedPhotoSwipeOptions}
         */
        _prepareOptions(options) {
          if (window.matchMedia("(prefers-reduced-motion), (update: slow)").matches) {
            options.showHideAnimationType = "none";
            options.zoomAnimationDuration = 0;
          }
          return __spreadValues(__spreadValues({}, defaultOptions), options);
        }
      };
    }
  });

  // js/modules/call-popup.js
  var require_call_popup = __commonJS({
    "js/modules/call-popup.js"() {
      var $popupHandler = document.querySelectorAll(".open-call-popup");
      var $popupElement = document.querySelector("#call-popup");
      var $popupCloser = document.querySelector("#call-popup-closer");
      var $callPopupBanner = document.querySelector("#call-popup-banner");
      if (!$popupElement)
        return;
      $popupHandler.forEach((btnHandler) => {
        btnHandler.addEventListener("click", () => {
          $popupElement.classList.add("show-popup");
        });
      });
      $popupCloser.addEventListener("click", () => {
        $popupElement.classList.remove("show-popup");
      });
      if ($popupElement.addEventListener("click", (el) => {
        if (el.target == $popupElement) {
          $popupElement.classList.remove("show-popup");
        }
      }))
        ;
    }
  });

  // js/modules/about.js
  var aboutSlider = document.querySelector(".about-slider");
  if (aboutSlider) {
    swiper = new Swiper(".about-slider", {
      autoplay: {
        delay: 5e3,
        disableOnInteraction: false
      },
      speed: 1e3,
      spaceBetween: 20,
      loop: true,
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      }
    });
  }
  var swiper;
  var certificates = document.querySelector(".certificates-section");
  if (certificates) {
    swiper = new Swiper(".certificates-section", {
      slidesPerView: 3,
      speed: 1e3,
      spaceBetween: 16,
      autoplay: {
        delay: 5e3,
        disableOnInteraction: false
      },
      breakpoints: {
        200: {
          slidesPerView: 1
        },
        480: {
          slidesPerView: 2
        },
        700: {
          slidesPerView: 3
        }
      },
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      }
      // pagination: {
      //   el: ".swiper-pagination",
      //   dynamicBullets: true,
      // },
    });
  }
  var swiper;

  // js/modules/front-page.js
  var mobileServiceSlider = document.querySelector(".home-service-slider");
  if (mobileServiceSlider) {
    swiper = new Swiper(".home-service-slider", {
      slidesPerView: "auto",
      spaceBetween: 14,
      loop: true,
      speed: 800,
      autoplay: {
        delay: 3e3,
        disableOnInteraction: false
      }
    });
  }
  var swiper;
  function homePageTabs() {
    const homePageTabs2 = document.querySelector("#homePageTabs");
    if (!homePageTabs2)
      return;
    const tabTitleGroup = homePageTabs2.querySelector("#tabTitleGroup");
    const tabContentGroup = homePageTabs2.querySelector("#tabContentGroup");
    const tabDecriptionGroup = homePageTabs2.querySelectorAll("#content-tab");
    if (!tabTitleGroup || !tabContentGroup)
      return;
    const tabTitleGroupInner = tabTitleGroup.querySelectorAll("div.tab-title");
    const tabContentGroupInner = tabContentGroup.querySelectorAll("div.tab-content");
    if (!tabTitleGroupInner || !tabContentGroupInner)
      return;
    tabTitleGroupInner[0].classList.add("active");
    tabContentGroupInner[0].classList.add("active");
    tabTitleGroupInner.forEach((tabTitle) => {
      tabTitle.addEventListener("click", () => {
        if (tabTitle.classList.contains("active")) {
          tabTitle.classList.remove("active");
        } else {
          tabTitleGroupInner.forEach((tabs) => {
            tabs.classList.remove("active");
          });
          tabTitle.classList.add("active");
        }
        tabTitle.classList.add("active");
        tabContentGroupInner.forEach((tabContent) => {
          tabContent.classList.remove("active");
          if (tabContent.dataset.tab === tabTitle.dataset.tab) {
            tabContent.classList.add("active");
          }
        });
      });
    });
    tabContentGroupInner.forEach((tabContentGroup2) => {
      const radioButtons = tabContentGroup2.querySelector(".radio-buttons");
      const radioButtonContents = tabContentGroup2.querySelector(
        ".radio-button-content"
      );
      if (!radioButtons || !radioButtonContents)
        return;
      const titles = radioButtons.querySelectorAll(".title");
      const contents = radioButtonContents.querySelectorAll(".content");
      if (!titles || !contents)
        return;
      titles.forEach((title) => {
        title.addEventListener("click", () => {
          contents.forEach((content) => {
            content.classList.remove("active");
            if (content.dataset.value === title.dataset.value) {
              content.classList.add("active");
            }
          });
        });
      });
    });
  }
  homePageTabs();
  var insuranceSlider = document.querySelector(".insurance-slider");
  if (insuranceSlider) {
    swiper = new Swiper(".insurance-slider", {
      slidesPerView: "auto",
      spaceBetween: 50,
      loop: true,
      speed: 800,
      autoplay: {
        delay: 3e3
      }
    });
  }
  var swiper;
  var accordionItemHeaders = document.querySelectorAll(
    ".accordion-item-header"
  );
  if (accordionItemHeaders) {
    accordionItemHeaders.forEach((accordionItemHeader) => {
      const accordionItemBody = accordionItemHeader.nextElementSibling;
      if (accordionItemHeader.classList.contains("active")) {
        accordionItemBody.style.maxHeight = accordionItemBody.scrollHeight + "px";
      }
      accordionItemHeader.addEventListener("click", () => {
        if (accordionItemHeader.classList.contains("active")) {
          accordionItemHeader.classList.remove("active");
          accordionItemBody.style.maxHeight = 0;
        } else {
          accordionItemHeader.classList.add("active");
          accordionItemBody.style.maxHeight = accordionItemBody.scrollHeight + "px";
        }
      });
    });
  }
  var testimonial = document.getElementsByClassName("testimonial-slider");
  if (testimonial) {
    swiper = new Swiper(".testimonial-slider", {
      slidesPerView: "auto",
      spaceBetween: 16,
      centeredSlides: false,
      // loop: true,
      autoplay: {
        delay: 4e3,
        disableOnInteraction: true,
        pauseOnMouseEnter: true
      },
      breakpoints: {
        768: {
          slidesPerView: "auto",
          spaceBetween: 16
        }
      },
      pagination: {
        el: ".swiper-pagination"
      }
    });
  }
  var swiper;

  // js/modules/menu.js
  var mobile = document.querySelector(".hamburger-menu");
  var close_mobile = document.getElementById("close-menu");
  if (mobile) {
    (function() {
      mobile.addEventListener("click", function() {
        document.querySelector(".mobile-menu").classList.toggle("disply-menu");
        document.querySelector(".mobile-menu-detail").classList.toggle("active");
        document.body.style.overflow = "hidden";
        return false;
      });
      close_mobile.addEventListener("click", function() {
        document.querySelector(".mobile-menu-detail").classList.remove("active");
        document.querySelector(".mobile-menu").classList.remove("disply-menu");
        document.body.style.overflow = "auto";
      });
    })();
    let mobileMenuContainer = document.querySelector(".menu-contain");
    let menuItemsHasChildren = mobileMenuContainer.querySelectorAll(
      "li.menu-item-has-children"
    );
    for (let i2 = 0; i2 < menuItemsHasChildren.length; i2++) {
      menuItemsHasChildren[i2].addEventListener("click", function(event) {
        event.stopPropagation();
        let subMenu = this.getElementsByClassName("sub-menu");
        if (subMenu[0].classList.contains("active-sub")) {
          subMenu[0].style.height = 0;
          subMenu[0].classList.remove("active-sub");
          menuItemsHasChildren[i2].classList.remove("active-2");
        } else {
          subMenu[0].classList.add("active-sub");
          subMenu[0].style.height = subMenu[0].scrollHeight + "px";
          menuItemsHasChildren[i2].classList.add("active-2");
        }
      });
    }
  }

  // js/modules/blog-cart.js
  var blogSlider = document.querySelector(".front-blogs-slider");
  if (blogSlider) {
    swiper = new Swiper(".front-blogs-slider", {
      slidesPerView: 5,
      spaceBetween: 20,
      loop: true,
      pagination: {
        el: ".swiper-pagination",
        clickable: true
      },
      autoplay: {
        delay: 5e3,
        disableOnInteraction: false
      },
      breakpoints: {
        999: {
          slidesPerView: 3
        },
        680: {
          slidesPerView: 2
        },
        280: {
          slidesPerView: 1
        }
      }
    });
  }
  var swiper;

  // js/modules/blogs.js
  var specialSlider = document.querySelector(".special-blog-slider");
  if (specialSlider) {
    swiper = new Swiper(".special-blog-slider", {
      autoplay: {
        delay: 5e3,
        disableOnInteraction: false
      },
      speed: 1e3,
      loop: true,
      spaceBetween: 20,
      pagination: {
        el: ".swiper-pagination",
        type: "fraction"
      },
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      },
      on: {
        init: function() {
          var progressBarItems = document.querySelectorAll(
            ".swiper-progress-bar"
          );
          progressBarItems.forEach(function(item, index) {
            item.classList.remove("animate");
            item.classList.remove("active");
            if (index === 0) {
              item.classList.add("animate");
              item.classList.add("active");
            }
          });
        },
        slideChangeTransitionStart: function() {
          var progressBarItems = document.querySelectorAll(
            ".swiper-progress-bar"
          );
          progressBarItems.forEach(function(item) {
            item.classList.remove("animate");
            item.classList.remove("active");
          });
          progressBarItems[0].classList.add("active");
        },
        slideChangeTransitionEnd: function() {
          var progressBarItems = document.querySelectorAll(
            ".swiper-progress-bar"
          );
          progressBarItems[0].classList.add("animate");
        }
      }
    });
  }
  var swiper;

  // js/modules/quick-access.js
  var sectionHeadings = document.querySelectorAll("#content-single h2 ,#content-single h3");
  var scrollList = document.querySelector(".scroll-list");
  if (sectionHeadings && scrollList) {
    let scrollList2 = document.querySelector(".scroll-list");
    let counter = 1;
    sectionHeadings.forEach(function(heading, index) {
      let randomId = "section-" + counter;
      heading.id = randomId;
      let contentHeadings = document.querySelectorAll("#content-single h2 , #content-single h3");
      contentHeadings[index].id = randomId;
      let listItem = document.createElement("li");
      if (contentHeadings[index].tagName === "H3") {
        listItem.classList.add("sub-li");
      }
      let link = document.createElement("a");
      link.textContent = heading.textContent;
      link.href = "#" + randomId;
      listItem.appendChild(link);
      scrollList2.appendChild(listItem);
      counter++;
    });
  }

  // js/modules/single-service.js
  var serviceBox = document.querySelectorAll(".service-box");
  if (serviceBox) {
    serviceBox.forEach((box) => {
      box.addEventListener("click", () => {
        if (box.classList.contains("active")) {
          box.classList.remove("active");
        } else {
          serviceBox.forEach((otherBox) => {
            otherBox.classList.remove("active");
          });
          box.classList.add("active");
        }
      });
    });
  }
  var doctorsSlider = document.querySelector(".doctors-slider");
  if (doctorsSlider) {
    swiper = new Swiper(".doctors-slider", {
      // autoplay: {
      //     delay: 5000,
      //     disableOnInteraction: false,
      // },
      spaceBetween: 20,
      speed: 1e3,
      loop: true,
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev"
      }
    });
  }
  var swiper;
  var mainVideo = document.getElementById("mainVideo");
  if (mainVideo) {
    const videoThumbnails = document.querySelectorAll(".video-thumbnail");
    videoThumbnails.forEach((thumbnail) => {
      thumbnail.addEventListener("click", () => {
        const videoSrc = thumbnail.getAttribute("data-video-src");
        const videoposter = thumbnail.getAttribute("data-poster-src");
        mainVideo.src = videoSrc;
        mainVideo.poster = videoposter;
      });
    });
  }

  // js/modules/toastify.js
  var import_toastify_js = __toESM(require_toastify());
  var successColor = "#4caf50";
  var errorColor = "#ef5350";
  var successText = "\u0639\u0645\u0644\u06CC\u0627\u062A \u0628\u0627 \u0645\u0648\u0641\u0642\u06CC\u062A \u0627\u0646\u062C\u0627\u0645 \u0634\u062F";
  var errorText = "\u0639\u0645\u0644\u06CC\u0627\u062A \u0628\u0627 \u062E\u0637\u0627 \u0645\u0648\u0627\u062C\u0647 \u0634\u062F";
  var successFormText = "\u0641\u0631\u0645 \u0628\u0627 \u0645\u0648\u0641\u0642\u06CC\u062A \u0627\u0631\u0633\u0627\u0644 \u0634\u062F";
  var successToast = (0, import_toastify_js.default)({
    text: successText,
    style: {
      background: successColor
    }
  });
  var errorToast = (0, import_toastify_js.default)({
    text: errorText,
    style: {
      background: errorColor
    }
  });
  var successFormToast = (0, import_toastify_js.default)({
    text: successFormText,
    style: {
      background: successColor
    }
  });

  // js/modules/contact.js
  function contact() {
    const form = document.querySelector("#contact_form");
    if (!form)
      return;
    form.addEventListener("submit", (e2) => {
      e2.preventDefault();
      const formData = new FormData(form);
      formData.append("nonce", rest_details.nonce);
      jQuery(($) => {
        $.ajax({
          url: rest_details.url + "cynApi/v1/contactForm",
          type: "post",
          cache: false,
          processData: false,
          contentType: false,
          data: formData,
          success: (res) => {
            successFormToast.showToast();
            form.reset();
          },
          error: (err) => {
            errorToast.showToast();
          }
        });
      });
    });
  }
  contact();

  // js/modules/testimonial.js
  function testimonial2() {
    const formComment = document.querySelector("#service_comment_form");
    if (!formComment)
      return;
    formComment.addEventListener("submit", (e2) => {
      e2.preventDefault();
      const formData = new FormData(formComment);
      formData.append("nonce", rest_details.nonce);
      jQuery(($) => {
        $.ajax({
          url: rest_details.url + "cynApi/v1/testimonialForm",
          type: "post",
          cache: false,
          processData: false,
          contentType: false,
          data: formData,
          success: (res) => {
            successFormToast.showToast();
            formComment.reset();
          },
          error: (err) => {
            errorToast.showToast();
          }
        });
      });
    });
  }
  testimonial2();

  // js/modules/mobile-category-list.js
  var mobileCategoryList = document.querySelector("#mobile-category-list");
  if (mobileCategoryList) {
    let options = mobileCategoryList.querySelectorAll("option");
    for (let i2 = 0; i2 < options.length; i2++) {
      mobileCategoryList.addEventListener("change", function() {
        window.location = this.value;
      });
    }
  }

  // js/modules/ticker.js
  console.clear();
  var speed = 50;
  var allTicker = document.querySelectorAll(".ticker-custom");
  if (allTicker) {
    for (let i2 = 0; i2 < allTicker.length; i2++) {
      let target = allTicker[i2];
      const original_html = target.innerHTML;
      const new_html = "<div class='ticker-items'>" + original_html + "</div>";
      target.innerHTML = new_html;
      target.innerHTML = target.innerHTML + new_html;
      const tickerWidth = document.querySelector(".ticker-items").offsetWidth;
      const initDuration = tickerWidth / speed;
      gsap.to(".ticker-items", {
        duration: initDuration,
        xPercent: -100,
        ease: "none",
        repeat: -1
      });
    }
  }

  // js/modules/plyr.js
  var import_plyr = __toESM(require_plyr_min());
  controls:
    [
      "play-large",
      // The large play button in the center
      "restart",
      // Restart playback
      "rewind",
      // Rewind by the seek time (default 10 seconds)
      "play",
      // Play/pause playback
      "fast-forward",
      // Fast forward by the seek time (default 10 seconds)
      "progress",
      // The progress bar and scrubber for playback and buffering
      "current-time",
      // The current time of playback
      "duration",
      // The full duration of the media
      "mute",
      // Toggle mute
      "volume",
      // Volume control
      "captions",
      // Toggle captions
      "settings",
      // Settings menu
      "pip",
      // Picture-in-picture (currently Safari only)
      "airplay",
      // Airplay (currently Safari only)
      "download",
      // Show a download button with a link to either the current source or a custom URL you specify in your options
      "fullscreen"
      // Toggle fullscreen
    ];
  var players = import_plyr.default.setup(".audio-player", {
    controls: ["play", "progress", "current-time", "mute", "volume"]
  });
  var player = import_plyr.default.setup(".video-player", {
    controls: ["play", "progress", "current-time", "mute", "fullscreen"]
  });

  // js/libs/photoswipe-lightbox.esm.min.js
  function t(t2, i2, s2) {
    const h2 = document.createElement(i2);
    return t2 && (h2.className = t2), s2 && s2.appendChild(h2), h2;
  }
  function i(t2, i2, s2) {
    t2.style.width = "number" == typeof i2 ? "".concat(i2, "px") : i2, t2.style.height = "number" == typeof s2 ? "".concat(s2, "px") : s2;
  }
  var s = "idle";
  var h = "loading";
  var e = "loaded";
  var n = "error";
  function o(t2, i2, s2 = document) {
    let h2 = [];
    if (t2 instanceof Element)
      h2 = [t2];
    else if (t2 instanceof NodeList || Array.isArray(t2))
      h2 = Array.from(t2);
    else {
      const e2 = "string" == typeof t2 ? t2 : i2;
      e2 && (h2 = Array.from(s2.querySelectorAll(e2)));
    }
    return h2;
  }
  function r() {
    return !(!navigator.vendor || !navigator.vendor.match(/apple/i));
  }
  var l = class {
    constructor(t2, i2) {
      this.type = t2, this.defaultPrevented = false, i2 && Object.assign(this, i2);
    }
    preventDefault() {
      this.defaultPrevented = true;
    }
  };
  var a = class {
    constructor(i2, s2) {
      if (this.element = t("pswp__img pswp__img--placeholder", i2 ? "img" : "div", s2), i2) {
        const t2 = this.element;
        t2.decoding = "async", t2.alt = "", t2.src = i2, t2.setAttribute("role", "presentation");
      }
      this.element.setAttribute("aria-hidden", "true");
    }
    setDisplayedSize(t2, s2) {
      this.element && ("IMG" === this.element.tagName ? (i(this.element, 250, "auto"), this.element.style.transformOrigin = "0 0", this.element.style.transform = function(t3, i2, s3) {
        let h2 = "translate3d(".concat(t3, "px,").concat(i2 || 0, "px,0)");
        return void 0 !== s3 && (h2 += " scale3d(".concat(s3, ",").concat(s3, ",1)")), h2;
      }(0, 0, t2 / 250)) : i(this.element, t2, s2));
    }
    destroy() {
      var t2;
      null !== (t2 = this.element) && void 0 !== t2 && t2.parentNode && this.element.remove(), this.element = null;
    }
  };
  var d = class {
    constructor(t2, i2, h2) {
      this.instance = i2, this.data = t2, this.index = h2, this.element = void 0, this.placeholder = void 0, this.slide = void 0, this.displayedImageWidth = 0, this.displayedImageHeight = 0, this.width = Number(this.data.w) || Number(this.data.width) || 0, this.height = Number(this.data.h) || Number(this.data.height) || 0, this.isAttached = false, this.hasSlide = false, this.isDecoding = false, this.state = s, this.data.type ? this.type = this.data.type : this.data.src ? this.type = "image" : this.type = "html", this.instance.dispatch("contentInit", { content: this });
    }
    removePlaceholder() {
      this.placeholder && !this.keepPlaceholder() && setTimeout(() => {
        this.placeholder && (this.placeholder.destroy(), this.placeholder = void 0);
      }, 1e3);
    }
    load(i2, s2) {
      if (this.slide && this.usePlaceholder())
        if (this.placeholder) {
          const t2 = this.placeholder.element;
          t2 && !t2.parentElement && this.slide.container.prepend(t2);
        } else {
          const t2 = this.instance.applyFilters("placeholderSrc", !(!this.data.msrc || !this.slide.isFirstSlide) && this.data.msrc, this);
          this.placeholder = new a(t2, this.slide.container);
        }
      this.element && !s2 || this.instance.dispatch("contentLoad", { content: this, isLazy: i2 }).defaultPrevented || (this.isImageContent() ? (this.element = t("pswp__img", "img"), this.displayedImageWidth && this.loadImage(i2)) : (this.element = t("pswp__content", "div"), this.element.innerHTML = this.data.html || ""), s2 && this.slide && this.slide.updateContentSize(true));
    }
    loadImage(t2) {
      var i2, s2;
      if (!this.isImageContent() || !this.element || this.instance.dispatch("contentLoadImage", { content: this, isLazy: t2 }).defaultPrevented)
        return;
      const e2 = this.element;
      this.updateSrcsetSizes(), this.data.srcset && (e2.srcset = this.data.srcset), e2.src = null !== (i2 = this.data.src) && void 0 !== i2 ? i2 : "", e2.alt = null !== (s2 = this.data.alt) && void 0 !== s2 ? s2 : "", this.state = h, e2.complete ? this.onLoaded() : (e2.onload = () => {
        this.onLoaded();
      }, e2.onerror = () => {
        this.onError();
      });
    }
    setSlide(t2) {
      this.slide = t2, this.hasSlide = true, this.instance = t2.pswp;
    }
    onLoaded() {
      this.state = e, this.slide && this.element && (this.instance.dispatch("loadComplete", { slide: this.slide, content: this }), this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode && (this.append(), this.slide.updateContentSize(true)), this.state !== e && this.state !== n || this.removePlaceholder());
    }
    onError() {
      this.state = n, this.slide && (this.displayError(), this.instance.dispatch("loadComplete", { slide: this.slide, isError: true, content: this }), this.instance.dispatch("loadError", { slide: this.slide, content: this }));
    }
    isLoading() {
      return this.instance.applyFilters("isContentLoading", this.state === h, this);
    }
    isError() {
      return this.state === n;
    }
    isImageContent() {
      return "image" === this.type;
    }
    setDisplayedSize(t2, s2) {
      if (this.element && (this.placeholder && this.placeholder.setDisplayedSize(t2, s2), !this.instance.dispatch("contentResize", { content: this, width: t2, height: s2 }).defaultPrevented && (i(this.element, t2, s2), this.isImageContent() && !this.isError()))) {
        const i2 = !this.displayedImageWidth && t2;
        this.displayedImageWidth = t2, this.displayedImageHeight = s2, i2 ? this.loadImage(false) : this.updateSrcsetSizes(), this.slide && this.instance.dispatch("imageSizeChange", { slide: this.slide, width: t2, height: s2, content: this });
      }
    }
    isZoomable() {
      return this.instance.applyFilters("isContentZoomable", this.isImageContent() && this.state !== n, this);
    }
    updateSrcsetSizes() {
      if (!this.isImageContent() || !this.element || !this.data.srcset)
        return;
      const t2 = this.element, i2 = this.instance.applyFilters("srcsetSizesWidth", this.displayedImageWidth, this);
      (!t2.dataset.largestUsedSize || i2 > parseInt(t2.dataset.largestUsedSize, 10)) && (t2.sizes = i2 + "px", t2.dataset.largestUsedSize = String(i2));
    }
    usePlaceholder() {
      return this.instance.applyFilters("useContentPlaceholder", this.isImageContent(), this);
    }
    lazyLoad() {
      this.instance.dispatch("contentLazyLoad", { content: this }).defaultPrevented || this.load(true);
    }
    keepPlaceholder() {
      return this.instance.applyFilters("isKeepingPlaceholder", this.isLoading(), this);
    }
    destroy() {
      this.hasSlide = false, this.slide = void 0, this.instance.dispatch("contentDestroy", { content: this }).defaultPrevented || (this.remove(), this.placeholder && (this.placeholder.destroy(), this.placeholder = void 0), this.isImageContent() && this.element && (this.element.onload = null, this.element.onerror = null, this.element = void 0));
    }
    displayError() {
      if (this.slide) {
        var i2, s2;
        let h2 = t("pswp__error-msg", "div");
        h2.innerText = null !== (i2 = null === (s2 = this.instance.options) || void 0 === s2 ? void 0 : s2.errorMsg) && void 0 !== i2 ? i2 : "", h2 = this.instance.applyFilters("contentErrorElement", h2, this), this.element = t("pswp__content pswp__error-msg-container", "div"), this.element.appendChild(h2), this.slide.container.innerText = "", this.slide.container.appendChild(this.element), this.slide.updateContentSize(true), this.removePlaceholder();
      }
    }
    append() {
      if (this.isAttached || !this.element)
        return;
      if (this.isAttached = true, this.state === n)
        return void this.displayError();
      if (this.instance.dispatch("contentAppend", { content: this }).defaultPrevented)
        return;
      const t2 = "decode" in this.element;
      this.isImageContent() ? t2 && this.slide && (!this.slide.isActive || r()) ? (this.isDecoding = true, this.element.decode().catch(() => {
      }).finally(() => {
        this.isDecoding = false, this.appendImage();
      })) : this.appendImage() : this.slide && !this.element.parentNode && this.slide.container.appendChild(this.element);
    }
    activate() {
      !this.instance.dispatch("contentActivate", { content: this }).defaultPrevented && this.slide && (this.isImageContent() && this.isDecoding && !r() ? this.appendImage() : this.isError() && this.load(false, true), this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "false"));
    }
    deactivate() {
      this.instance.dispatch("contentDeactivate", { content: this }), this.slide && this.slide.holderElement && this.slide.holderElement.setAttribute("aria-hidden", "true");
    }
    remove() {
      this.isAttached = false, this.instance.dispatch("contentRemove", { content: this }).defaultPrevented || (this.element && this.element.parentNode && this.element.remove(), this.placeholder && this.placeholder.element && this.placeholder.element.remove());
    }
    appendImage() {
      this.isAttached && (this.instance.dispatch("contentAppendImage", { content: this }).defaultPrevented || (this.slide && this.element && !this.element.parentNode && this.slide.container.appendChild(this.element), this.state !== e && this.state !== n || this.removePlaceholder()));
    }
  };
  function c(t2, i2, s2, h2, e2) {
    let n2 = 0;
    if (i2.paddingFn)
      n2 = i2.paddingFn(s2, h2, e2)[t2];
    else if (i2.padding)
      n2 = i2.padding[t2];
    else {
      const s3 = "padding" + t2[0].toUpperCase() + t2.slice(1);
      i2[s3] && (n2 = i2[s3]);
    }
    return Number(n2) || 0;
  }
  var u = class {
    constructor(t2, i2, s2, h2) {
      this.pswp = h2, this.options = t2, this.itemData = i2, this.index = s2, this.panAreaSize = null, this.elementSize = null, this.fit = 1, this.fill = 1, this.vFill = 1, this.initial = 1, this.secondary = 1, this.max = 1, this.min = 1;
    }
    update(t2, i2, s2) {
      const h2 = { x: t2, y: i2 };
      this.elementSize = h2, this.panAreaSize = s2;
      const e2 = s2.x / h2.x, n2 = s2.y / h2.y;
      this.fit = Math.min(1, e2 < n2 ? e2 : n2), this.fill = Math.min(1, e2 > n2 ? e2 : n2), this.vFill = Math.min(1, n2), this.initial = this.t(), this.secondary = this.i(), this.max = Math.max(this.initial, this.secondary, this.o()), this.min = Math.min(this.fit, this.initial, this.secondary), this.pswp && this.pswp.dispatch("zoomLevelsUpdate", { zoomLevels: this, slideData: this.itemData });
    }
    l(t2) {
      const i2 = t2 + "ZoomLevel", s2 = this.options[i2];
      if (s2)
        return "function" == typeof s2 ? s2(this) : "fill" === s2 ? this.fill : "fit" === s2 ? this.fit : Number(s2);
    }
    i() {
      let t2 = this.l("secondary");
      return t2 || (t2 = Math.min(1, 3 * this.fit), this.elementSize && t2 * this.elementSize.x > 4e3 && (t2 = 4e3 / this.elementSize.x), t2);
    }
    t() {
      return this.l("initial") || this.fit;
    }
    o() {
      return this.l("max") || Math.max(1, 4 * this.fit);
    }
  };
  function p(t2, i2, s2) {
    const h2 = i2.createContentFromData(t2, s2);
    let e2;
    const { options: n2 } = i2;
    if (n2) {
      let o2;
      e2 = new u(n2, t2, -1), o2 = i2.pswp ? i2.pswp.viewportSize : function(t3, i3) {
        if (t3.getViewportSizeFn) {
          const s3 = t3.getViewportSizeFn(t3, i3);
          if (s3)
            return s3;
        }
        return { x: document.documentElement.clientWidth, y: window.innerHeight };
      }(n2, i2);
      const r2 = function(t3, i3, s3, h3) {
        return { x: i3.x - c("left", t3, i3, s3, h3) - c("right", t3, i3, s3, h3), y: i3.y - c("top", t3, i3, s3, h3) - c("bottom", t3, i3, s3, h3) };
      }(n2, o2, t2, s2);
      e2.update(h2.width, h2.height, r2);
    }
    return h2.lazyLoad(), e2 && h2.setDisplayedSize(Math.ceil(h2.width * e2.initial), Math.ceil(h2.height * e2.initial)), h2;
  }
  var v = class extends class extends class {
    constructor() {
      this.u = {}, this.p = {}, this.pswp = void 0, this.options = void 0;
    }
    addFilter(t2, i2, s2 = 100) {
      var h2, e2, n2;
      this.p[t2] || (this.p[t2] = []), null === (h2 = this.p[t2]) || void 0 === h2 || h2.push({ fn: i2, priority: s2 }), null === (e2 = this.p[t2]) || void 0 === e2 || e2.sort((t3, i3) => t3.priority - i3.priority), null === (n2 = this.pswp) || void 0 === n2 || n2.addFilter(t2, i2, s2);
    }
    removeFilter(t2, i2) {
      this.p[t2] && (this.p[t2] = this.p[t2].filter((t3) => t3.fn !== i2)), this.pswp && this.pswp.removeFilter(t2, i2);
    }
    applyFilters(t2, ...i2) {
      var s2;
      return null === (s2 = this.p[t2]) || void 0 === s2 || s2.forEach((t3) => {
        i2[0] = t3.fn.apply(this, i2);
      }), i2[0];
    }
    on(t2, i2) {
      var s2, h2;
      this.u[t2] || (this.u[t2] = []), null === (s2 = this.u[t2]) || void 0 === s2 || s2.push(i2), null === (h2 = this.pswp) || void 0 === h2 || h2.on(t2, i2);
    }
    off(t2, i2) {
      var s2;
      this.u[t2] && (this.u[t2] = this.u[t2].filter((t3) => i2 !== t3)), null === (s2 = this.pswp) || void 0 === s2 || s2.off(t2, i2);
    }
    dispatch(t2, i2) {
      var s2;
      if (this.pswp)
        return this.pswp.dispatch(t2, i2);
      const h2 = new l(t2, i2);
      return null === (s2 = this.u[t2]) || void 0 === s2 || s2.forEach((t3) => {
        t3.call(this, h2);
      }), h2;
    }
  } {
    getNumItems() {
      var t2;
      let i2 = 0;
      const s2 = null === (t2 = this.options) || void 0 === t2 ? void 0 : t2.dataSource;
      s2 && "length" in s2 ? i2 = s2.length : s2 && "gallery" in s2 && (s2.items || (s2.items = this.v(s2.gallery)), s2.items && (i2 = s2.items.length));
      const h2 = this.dispatch("numItems", { dataSource: s2, numItems: i2 });
      return this.applyFilters("numItems", h2.numItems, s2);
    }
    createContentFromData(t2, i2) {
      return new d(t2, this, i2);
    }
    getItemData(t2) {
      var i2;
      const s2 = null === (i2 = this.options) || void 0 === i2 ? void 0 : i2.dataSource;
      let h2 = {};
      Array.isArray(s2) ? h2 = s2[t2] : s2 && "gallery" in s2 && (s2.items || (s2.items = this.v(s2.gallery)), h2 = s2.items[t2]);
      let e2 = h2;
      e2 instanceof Element && (e2 = this.m(e2));
      const n2 = this.dispatch("itemData", { itemData: e2 || {}, index: t2 });
      return this.applyFilters("itemData", n2.itemData, t2);
    }
    v(t2) {
      var i2, s2;
      return null !== (i2 = this.options) && void 0 !== i2 && i2.children || null !== (s2 = this.options) && void 0 !== s2 && s2.childSelector ? o(this.options.children, this.options.childSelector, t2) || [] : [t2];
    }
    m(t2) {
      const i2 = { element: t2 }, s2 = "A" === t2.tagName ? t2 : t2.querySelector("a");
      if (s2) {
        i2.src = s2.dataset.pswpSrc || s2.href, s2.dataset.pswpSrcset && (i2.srcset = s2.dataset.pswpSrcset), i2.width = s2.dataset.pswpWidth ? parseInt(s2.dataset.pswpWidth, 10) : 0, i2.height = s2.dataset.pswpHeight ? parseInt(s2.dataset.pswpHeight, 10) : 0, i2.w = i2.width, i2.h = i2.height, s2.dataset.pswpType && (i2.type = s2.dataset.pswpType);
        const e2 = t2.querySelector("img");
        var h2;
        if (e2)
          i2.msrc = e2.currentSrc || e2.src, i2.alt = null !== (h2 = e2.getAttribute("alt")) && void 0 !== h2 ? h2 : "";
        (s2.dataset.pswpCropped || s2.dataset.cropped) && (i2.thumbCropped = true);
      }
      return this.applyFilters("domItemData", i2, t2, s2);
    }
    lazyLoadData(t2, i2) {
      return p(t2, this, i2);
    }
  } {
    constructor(t2) {
      super(), this.options = t2 || {}, this.g = 0, this.shouldOpen = false, this._ = void 0, this.onThumbnailsClick = this.onThumbnailsClick.bind(this);
    }
    init() {
      o(this.options.gallery, this.options.gallerySelector).forEach((t2) => {
        t2.addEventListener("click", this.onThumbnailsClick, false);
      });
    }
    onThumbnailsClick(t2) {
      if (function(t3) {
        return "button" in t3 && 1 === t3.button || t3.ctrlKey || t3.metaKey || t3.altKey || t3.shiftKey;
      }(t2) || window.pswp)
        return;
      let i2 = { x: t2.clientX, y: t2.clientY };
      i2.x || i2.y || (i2 = null);
      let s2 = this.getClickedIndex(t2);
      s2 = this.applyFilters("clickedIndex", s2, t2, this);
      const h2 = { gallery: t2.currentTarget };
      s2 >= 0 && (t2.preventDefault(), this.loadAndOpen(s2, h2, i2));
    }
    getClickedIndex(t2) {
      if (this.options.getClickedIndexFn)
        return this.options.getClickedIndexFn.call(this, t2);
      const i2 = t2.target, s2 = o(this.options.children, this.options.childSelector, t2.currentTarget).findIndex((t3) => t3 === i2 || t3.contains(i2));
      return -1 !== s2 ? s2 : this.options.children || this.options.childSelector ? -1 : 0;
    }
    loadAndOpen(t2, i2, s2) {
      if (window.pswp || !this.options)
        return false;
      if (!i2 && this.options.gallery && this.options.children) {
        const t3 = o(this.options.gallery);
        t3[0] && (i2 = { gallery: t3[0] });
      }
      return this.options.index = t2, this.options.initialPointerPos = s2, this.shouldOpen = true, this.preload(t2, i2), true;
    }
    preload(t2, i2) {
      const { options: s2 } = this;
      i2 && (s2.dataSource = i2);
      const h2 = [], e2 = typeof s2.pswpModule;
      if ("function" == typeof (n2 = s2.pswpModule) && n2.prototype && n2.prototype.goTo)
        h2.push(Promise.resolve(s2.pswpModule));
      else {
        if ("string" === e2)
          throw new Error("pswpModule as string is no longer supported");
        if ("function" !== e2)
          throw new Error("pswpModule is not valid");
        h2.push(s2.pswpModule());
      }
      var n2;
      "function" == typeof s2.openPromise && h2.push(s2.openPromise()), false !== s2.preloadFirstSlide && t2 >= 0 && (this._ = function(t3, i3) {
        const s3 = i3.getItemData(t3);
        if (!i3.dispatch("lazyLoadSlide", { index: t3, itemData: s3 }).defaultPrevented)
          return p(s3, i3, t3);
      }(t2, this));
      const o2 = ++this.g;
      Promise.all(h2).then((t3) => {
        if (this.shouldOpen) {
          const i3 = t3[0];
          this.I(i3, o2);
        }
      });
    }
    I(t2, i2) {
      if (i2 !== this.g && this.shouldOpen)
        return;
      if (this.shouldOpen = false, window.pswp)
        return;
      const s2 = "object" == typeof t2 ? new t2.default(this.options) : new t2(this.options);
      this.pswp = s2, window.pswp = s2, Object.keys(this.u).forEach((t3) => {
        var i3;
        null === (i3 = this.u[t3]) || void 0 === i3 || i3.forEach((i4) => {
          s2.on(t3, i4);
        });
      }), Object.keys(this.p).forEach((t3) => {
        var i3;
        null === (i3 = this.p[t3]) || void 0 === i3 || i3.forEach((i4) => {
          s2.addFilter(t3, i4.fn, i4.priority);
        });
      }), this._ && (s2.contentLoader.addToCache(this._), this._ = void 0), s2.on("destroy", () => {
        this.pswp = void 0, delete window.pswp;
      }), s2.init();
    }
    destroy() {
      var t2;
      null === (t2 = this.pswp) || void 0 === t2 || t2.destroy(), this.shouldOpen = false, this.u = {}, o(this.options.gallery, this.options.gallerySelector).forEach((t3) => {
        t3.removeEventListener("click", this.onThumbnailsClick, false);
      });
    }
  };

  // js/modules/image-opener.js
  var lightbox = new v({
    // may select multiple "galleries"
    gallery: ".certificate-gallery",
    // Elements within gallery (slides)
    children: "#static-thumbnails",
    // setup PhotoSwipe Core dynamic import
    pswpModule: () => Promise.resolve().then(() => (init_photoswipe_esm(), photoswipe_esm_exports))
  });
  lightbox.init();

  // js/index.js
  var import_call_popup = __toESM(require_call_popup());
})();
/*!
  * PhotoSwipe Lightbox 5.4.4 - https://photoswipe.com
  * (c) 2024 Dmytro Semenov
  */
/*! Bundled license information:

toastify-js/src/toastify.js:
  (*!
   * Toastify js 1.12.0
   * https://github.com/apvarun/toastify-js
   * @license MIT licensed
   *
   * Copyright (C) 2018 Varun A P
   *)

photoswipe/dist/photoswipe.esm.js:
  (*!
    * PhotoSwipe 5.4.4 - https://photoswipe.com
    * (c) 2024 Dmytro Semenov
    *)
*/
